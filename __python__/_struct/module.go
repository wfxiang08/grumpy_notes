package _struct
import πg "grumpy"
var Code *πg.Code
func init() {
	Code = πg.NewCode("<module>", "build/src/__python__/_struct.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
		var πR *πg.Object; _ = πR
		var πE *πg.BaseException; _ = πE
		ß := πg.InternStr("")
		ß0 := πg.InternStr("0")
		ß9 := πg.InternStr("9")
		ßB := πg.InternStr("B")
		ßException := πg.InternStr("Exception")
		ßH := πg.InternStr("H")
		ßI := πg.InternStr("I")
		ßINFINITY := πg.InternStr("INFINITY")
		ßIndexError := πg.InternStr("IndexError")
		ßKeyError := πg.InternStr("KeyError")
		ßL := πg.InternStr("L")
		ßNAN := πg.InternStr("NAN")
		ßNone := πg.InternStr("None")
		ßOverflowError := πg.InternStr("OverflowError")
		ßQ := πg.InternStr("Q")
		ßStructError := πg.InternStr("StructError")
		ßTypeError := πg.InternStr("TypeError")
		ßValueError := πg.InternStr("ValueError")
		ß__metaclass__ := πg.InternStr("__metaclass__")
		ß__module__ := πg.InternStr("__module__")
		ß__name__ := πg.InternStr("__name__")
		ß_clearcache := πg.InternStr("_clearcache")
		ßabs := πg.InternStr("abs")
		ßalignment := πg.InternStr("alignment")
		ßappend := πg.InternStr("append")
		ßb := πg.InternStr("b")
		ßbig := πg.InternStr("big")
		ßbig_endian_format := πg.InternStr("big_endian_format")
		ßbuffer := πg.InternStr("buffer")
		ßbyteorder := πg.InternStr("byteorder")
		ßbytes := πg.InternStr("bytes")
		ßc := πg.InternStr("c")
		ßcalcsize := πg.InternStr("calcsize")
		ßchr := πg.InternStr("chr")
		ßcopysign := πg.InternStr("copysign")
		ßd := πg.InternStr("d")
		ßdefault := πg.InternStr("default")
		ßerror := πg.InternStr("error")
		ßf := πg.InternStr("f")
		ßfloat := πg.InternStr("float")
		ßfloat_pack := πg.InternStr("float_pack")
		ßfloat_unpack := πg.InternStr("float_unpack")
		ßformatmode := πg.InternStr("formatmode")
		ßfrexp := πg.InternStr("frexp")
		ßgetNum := πg.InternStr("getNum")
		ßgetmode := πg.InternStr("getmode")
		ßh := πg.InternStr("h")
		ßi := πg.InternStr("i")
		ßinf := πg.InternStr("inf")
		ßint := πg.InternStr("int")
		ßisinf := πg.InternStr("isinf")
		ßisinstance := πg.InternStr("isinstance")
		ßisnan := πg.InternStr("isnan")
		ßjoin := πg.InternStr("join")
		ßl := πg.InternStr("l")
		ßldexp := πg.InternStr("ldexp")
		ßlen := πg.InternStr("len")
		ßlist := πg.InternStr("list")
		ßlittle := πg.InternStr("little")
		ßmath := πg.InternStr("math")
		ßnan := πg.InternStr("nan")
		ßord := πg.InternStr("ord")
		ßp := πg.InternStr("p")
		ßpack := πg.InternStr("pack")
		ßpack_char := πg.InternStr("pack_char")
		ßpack_float := πg.InternStr("pack_float")
		ßpack_int := πg.InternStr("pack_int")
		ßpack_into := πg.InternStr("pack_into")
		ßpack_signed_int := πg.InternStr("pack_signed_int")
		ßpack_unsigned_int := πg.InternStr("pack_unsigned_int")
		ßpop := πg.InternStr("pop")
		ßq := πg.InternStr("q")
		ßrange := πg.InternStr("range")
		ßreverse := πg.InternStr("reverse")
		ßround_to_nearest := πg.InternStr("round_to_nearest")
		ßs := πg.InternStr("s")
		ßsize := πg.InternStr("size")
		ßstr := πg.InternStr("str")
		ßsys := πg.InternStr("sys")
		ßtuple := πg.InternStr("tuple")
		ßunpack := πg.InternStr("unpack")
		ßunpack_char := πg.InternStr("unpack_char")
		ßunpack_float := πg.InternStr("unpack_float")
		ßunpack_from := πg.InternStr("unpack_from")
		ßunpack_int := πg.InternStr("unpack_int")
		ßunpack_signed_int := πg.InternStr("unpack_signed_int")
		ßx := πg.InternStr("x")
		var πTemp001 *πg.Object
		_ = πTemp001
		var πTemp002 []*πg.Object
		_ = πTemp002
		var πTemp003 *πg.Dict
		_ = πTemp003
		var πTemp004 *πg.Object
		_ = πTemp004
		var πTemp005 *πg.Object
		_ = πTemp005
		var πTemp006 []πg.Param
		_ = πTemp006
		var πTemp007 *πg.Object
		_ = πTemp007
		var πTemp008 *πg.Object
		_ = πTemp008
		var πTemp009 *πg.Object
		_ = πTemp009
		var πTemp010 *πg.Object
		_ = πTemp010
		var πTemp011 *πg.Object
		_ = πTemp011
		var πTemp012 *πg.Object
		_ = πTemp012
		var πTemp013 *πg.Object
		_ = πTemp013
		var πTemp014 *πg.Object
		_ = πTemp014
		var πTemp015 *πg.Object
		_ = πTemp015
		var πTemp016 *πg.Object
		_ = πTemp016
		var πTemp017 *πg.Object
		_ = πTemp017
		var πTemp018 *πg.Dict
		_ = πTemp018
		var πTemp019 *πg.Object
		_ = πTemp019
		var πTemp020 *πg.Object
		_ = πTemp020
		var πTemp021 *πg.Object
		_ = πTemp021
		var πTemp022 *πg.Object
		_ = πTemp022
		var πTemp023 *πg.Object
		_ = πTemp023
		var πTemp024 *πg.Object
		_ = πTemp024
		var πTemp025 *πg.Object
		_ = πTemp025
		var πTemp026 *πg.Object
		_ = πTemp026
		for ; πF.State() >= 0; πF.PopCheckpoint() {
			switch πF.State() {
			case 0:
			default: panic("unexpected function state")
			}
			// line 8: """Functions to convert between Python values and C structs.
			πF.SetLineno(8)
			// line 44: import math
			πF.SetLineno(44)
			if πTemp002, πE = πg.ImportModule(πF, "math"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßmath.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 45: import sys
			πF.SetLineno(45)
			if πTemp002, πE = πg.ImportModule(πF, "sys"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßsys.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 50: class StructError(Exception):
			πF.SetLineno(50)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßException); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp003 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp003.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("StructError", "build/src/__python__/_struct.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp003
				_ = πClass
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 51: pass
					πF.SetLineno(51)
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp004, πE = πTemp003.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp004 == nil {
				πTemp004 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp004.Call(πF, []*πg.Object{πg.NewStr("StructError").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp003.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStructError.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 52: error = StructError
			πF.SetLineno(52)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßerror.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 54: bytes = str
			πF.SetLineno(54)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßbytes.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 57: def unpack_int(data, index, size, le):
			πF.SetLineno(57)
			πTemp006 = make([]πg.Param, 4)
			πTemp006[0] = πg.Param{Name: "data", Def: nil}
			πTemp006[1] = πg.Param{Name: "index", Def: nil}
			πTemp006[2] = πg.Param{Name: "size", Def: nil}
			πTemp006[3] = πg.Param{Name: "le", Def: nil}
			πTemp001 = πg.NewFunction(πg.NewCode("unpack_int", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µdata *πg.Object = πArgs[0]; _ = µdata
				var µindex *πg.Object = πArgs[1]; _ = µindex
				var µsize *πg.Object = πArgs[2]; _ = µsize
				var µle *πg.Object = πArgs[3]; _ = µle
				var µ_bytes *πg.Object = πg.UnboundLocal; _ = µ_bytes
				var µnumber *πg.Object = πg.UnboundLocal; _ = µnumber
				var µb *πg.Object = πg.UnboundLocal; _ = µb
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 []*πg.Object
				_ = πTemp008
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 3: goto Label3
					case 4: goto Label4
					default: panic("unexpected function state")
					}
					// line 58: _bytes = [b for b in data[index:index + size]]
					πF.SetLineno(58)
					πTemp003 = make([]πg.Param, 0)
					πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/_struct.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µb *πg.Object = πg.UnboundLocal; _ = µb
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1: goto Label1
								case 2: goto Label2
								case 4: goto Label4
								default: panic("unexpected function state")
								}
								if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
									continue
								}
								if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
									continue
								}
								if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
									continue
								}
								if πTemp003, πE = πg.Add(πF, µindex, µsize); πE != nil {
									continue
								}
								if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µindex, πTemp003, πg.None}, nil); πE != nil {
									continue
								}
								if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
									continue
								}
								if πTemp003, πE = πg.GetItem(πF, µdata, πTemp002); πE != nil {
									continue
								}
								if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
									continue
								}
								πF.PushCheckpoint(2)
								πTemp004 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp004 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp005 = !isStop
								} else {
									πTemp005 = true
									µb = πTemp002
								}
								if πE != nil || !πTemp005 {
									continue
								}
								πF.PushCheckpoint(1)            
								// line 58: _bytes = [b for b in data[index:index + size]]
								πF.SetLineno(58)
								if πE = πg.CheckLocal(πF, µb, "b"); πE != nil {
									continue
								}
								πF.PushCheckpoint(4)
								return µb, nil
							Label4:
								πTemp002 = πSent
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
						continue
					}
					µ_bytes = πTemp001
					if πE = πg.CheckLocal(πF, µle, "le"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µle, ßlittle.ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label1
					}
					goto Label2
					// line 59: if le == 'little':
					πF.SetLineno(59)
				Label1:
					// line 60: _bytes.reverse()
					πF.SetLineno(60)
					if πE = πg.CheckLocal(πF, µ_bytes, "_bytes"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µ_bytes, ßreverse, nil); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					goto Label2
				Label2:
					// line 61: number = 0
					πF.SetLineno(61)
					µnumber = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µ_bytes, "_bytes"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Iter(πF, µ_bytes); πE != nil {
						continue
					}
					πF.PushCheckpoint(4)
					πTemp005 = false
				Label3:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp005 {
						πF.PopCheckpoint()
						goto Label5
					}
					if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp006 = !isStop
					} else {
						πTemp006 = true
						µb = πTemp004
					}
					if πE != nil || !πTemp006 {
						continue
					}
					πF.PushCheckpoint(3)            
					// line 63: number = number << 8 | b
					πF.SetLineno(63)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πTemp007, πE = πg.LShift(πF, µnumber, πg.NewInt(8).ToObject()); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µb, "b"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Or(πF, πTemp007, µb); πE != nil {
						continue
					}
					µnumber = πTemp004
					continue
				Label4:
					if πE != nil || πR != nil {
						continue
					}
				Label5:
					// line 64: return int(number)
					πF.SetLineno(64)
					πTemp008 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					πTemp008[0] = µnumber
					if πTemp001, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp008)
					πR = πTemp004
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßunpack_int.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 67: def unpack_signed_int(data, index, size, le):
			πF.SetLineno(67)
			πTemp006 = make([]πg.Param, 4)
			πTemp006[0] = πg.Param{Name: "data", Def: nil}
			πTemp006[1] = πg.Param{Name: "index", Def: nil}
			πTemp006[2] = πg.Param{Name: "size", Def: nil}
			πTemp006[3] = πg.Param{Name: "le", Def: nil}
			πTemp004 = πg.NewFunction(πg.NewCode("unpack_signed_int", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µdata *πg.Object = πArgs[0]; _ = µdata
				var µindex *πg.Object = πArgs[1]; _ = µindex
				var µsize *πg.Object = πArgs[2]; _ = µsize
				var µle *πg.Object = πArgs[3]; _ = µle
				var µnumber *πg.Object = πg.UnboundLocal; _ = µnumber
				var µmax *πg.Object = πg.UnboundLocal; _ = µmax
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 68: number = unpack_int(data, index, size, le)
					πF.SetLineno(68)
					πTemp001 = πF.MakeArgs(4)
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					πTemp001[0] = µdata
					if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
						continue
					}
					πTemp001[1] = µindex
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					πTemp001[2] = µsize
					if πE = πg.CheckLocal(πF, µle, "le"); πE != nil {
						continue
					}
					πTemp001[3] = µle
					if πTemp002, πE = πg.ResolveGlobal(πF, ßunpack_int); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µnumber = πTemp003
					// line 69: max = (1 << (size * 8))
					πF.SetLineno(69)
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Mul(πF, µsize, πg.NewInt(8).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp003); πE != nil {
						continue
					}
					µmax = πTemp002
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp006, πE = πg.Mul(πF, µsize, πg.NewInt(8).ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, πTemp006, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp005); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GT(πF, µnumber, πTemp003); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label1
					}
					goto Label2
					// line 70: if number > (1 << (size * 8 - 1)) - 1:
					πF.SetLineno(70)
				Label1:
					// line 71: number = int(-1 * (max - number))
					πF.SetLineno(71)
					πTemp001 = πF.MakeArgs(1)
					if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µmax, "max"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, µmax, µnumber); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Mul(πF, πTemp003, πTemp004); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µnumber = πTemp003
					goto Label2
				Label2:
					// line 72: return number
					πF.SetLineno(72)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					πR = µnumber
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßunpack_signed_int.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 74: INFINITY = 1e200 * 1e200
			πF.SetLineno(74)
			if πTemp005, πE = πg.Mul(πF, πg.NewFloat(1e+200).ToObject(), πg.NewFloat(1e+200).ToObject()); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßINFINITY.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 75: NAN = INFINITY / INFINITY
			πF.SetLineno(75)
			if πTemp007, πE = πg.ResolveGlobal(πF, ßINFINITY); πE != nil {
				continue
			}
			if πTemp008, πE = πg.ResolveGlobal(πF, ßINFINITY); πE != nil {
				continue
			}
			if πTemp005, πE = πg.Div(πF, πTemp007, πTemp008); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNAN.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 78: def unpack_char(data, index, size, le):
			πF.SetLineno(78)
			πTemp006 = make([]πg.Param, 4)
			πTemp006[0] = πg.Param{Name: "data", Def: nil}
			πTemp006[1] = πg.Param{Name: "index", Def: nil}
			πTemp006[2] = πg.Param{Name: "size", Def: nil}
			πTemp006[3] = πg.Param{Name: "le", Def: nil}
			πTemp005 = πg.NewFunction(πg.NewCode("unpack_char", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µdata *πg.Object = πArgs[0]; _ = µdata
				var µindex *πg.Object = πArgs[1]; _ = µindex
				var µsize *πg.Object = πArgs[2]; _ = µsize
				var µle *πg.Object = πArgs[3]; _ = µle
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 79: return data[index:index + size]
					πF.SetLineno(79)
					if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Add(πF, µindex, µsize); πE != nil {
						continue
					}
					if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µindex, πTemp002, πg.None}, nil); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, µdata, πTemp001); πE != nil {
						continue
					}
					πR = πTemp002
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßunpack_char.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 82: def pack_int(number, size, le):
			πF.SetLineno(82)
			πTemp006 = make([]πg.Param, 3)
			πTemp006[0] = πg.Param{Name: "number", Def: nil}
			πTemp006[1] = πg.Param{Name: "size", Def: nil}
			πTemp006[2] = πg.Param{Name: "le", Def: nil}
			πTemp007 = πg.NewFunction(πg.NewCode("pack_int", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µnumber *πg.Object = πArgs[0]; _ = µnumber
				var µsize *πg.Object = πArgs[1]; _ = µsize
				var µle *πg.Object = πArgs[2]; _ = µle
				var µx *πg.Object = πg.UnboundLocal; _ = µx
				var µres *πg.Object = πg.UnboundLocal; _ = µres
				var µi *πg.Object = πg.UnboundLocal; _ = µi
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πTemp007 []πg.Param
				_ = πTemp007
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 1: goto Label1
					case 2: goto Label2
					default: panic("unexpected function state")
					}
					// line 83: x = number
					πF.SetLineno(83)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					µx = µnumber
					// line 84: res = []
					πF.SetLineno(84)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					µres = πTemp002
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					πTemp001[0] = µsize
					if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
						continue
					}
					πF.PushCheckpoint(2)
					πTemp005 = false
				Label1:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp005 {
						πF.PopCheckpoint()
						goto Label3
					}
					if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp006 = !isStop
					} else {
						πTemp006 = true
						µi = πTemp003
					}
					if πE != nil || !πTemp006 {
						continue
					}
					πF.PushCheckpoint(1)            
					// line 86: res.append(x & 0xff)
					πF.SetLineno(86)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.And(πF, µx, πg.NewInt(255).ToObject()); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πE = πg.CheckLocal(πF, µres, "res"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetAttr(πF, µres, ßappend, nil); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 87: x = x >> 8
					πF.SetLineno(87)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.RShift(πF, µx, πg.NewInt(8).ToObject()); πE != nil {
						continue
					}
					µx = πTemp003
					continue
				Label2:
					if πE != nil || πR != nil {
						continue
					}
				Label3:
					if πE = πg.CheckLocal(πF, µle, "le"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µle, ßbig.ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label4
					}
					goto Label5
					// line 88: if le == 'big':
					πF.SetLineno(88)
				Label4:
					// line 89: res.reverse()
					πF.SetLineno(89)
					if πE = πg.CheckLocal(πF, µres, "res"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µres, ßreverse, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					goto Label5
				Label5:
					// line 90: return ''.join(chr(x) for x in res)
					πF.SetLineno(90)
					πTemp001 = πF.MakeArgs(1)
					πTemp007 = make([]πg.Param, 0)
					πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/_struct.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µx *πg.Object = πg.UnboundLocal; _ = µx
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1: goto Label1
								case 2: goto Label2
								case 4: goto Label4
								default: panic("unexpected function state")
								}
								if πE = πg.CheckLocal(πF, µres, "res"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.Iter(πF, µres); πE != nil {
									continue
								}
								πF.PushCheckpoint(2)
								πTemp002 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp002 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp003 = !isStop
								} else {
									πTemp003 = true
									µx = πTemp004
								}
								if πE != nil || !πTemp003 {
									continue
								}
								πF.PushCheckpoint(1)            
								// line 90: return ''.join(chr(x) for x in res)
								πF.SetLineno(90)
								πTemp005 = πF.MakeArgs(1)
								if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
									continue
								}
								πTemp005[0] = µx
								if πTemp004, πE = πg.ResolveGlobal(πF, ßchr); πE != nil {
									continue
								}
								if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp005)
								πF.PushCheckpoint(4)
								return πTemp006, nil
							Label4:
								πTemp004 = πSent
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πTemp003, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					πR = πTemp004
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßpack_int.ToObject(), πTemp007); πE != nil {
				continue
			}
			// line 93: def pack_signed_int(number, size, le):
			πF.SetLineno(93)
			πTemp006 = make([]πg.Param, 3)
			πTemp006[0] = πg.Param{Name: "number", Def: nil}
			πTemp006[1] = πg.Param{Name: "size", Def: nil}
			πTemp006[2] = πg.Param{Name: "le", Def: nil}
			πTemp008 = πg.NewFunction(πg.NewCode("pack_signed_int", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µnumber *πg.Object = πArgs[0]; _ = µnumber
				var µsize *πg.Object = πArgs[1]; _ = µsize
				var µle *πg.Object = πArgs[2]; _ = µle
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					πTemp002 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					πTemp002[0] = µnumber
					if πTemp003, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
						continue
					}
					πTemp002[1] = πTemp003
					if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
						continue
					}
					πTemp001 = πg.GetBool(!πTemp005).ToObject()
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label1
					}
					goto Label2
					// line 94: if not isinstance(number, int):
					πF.SetLineno(94)
				Label1:
					πTemp002 = πF.MakeArgs(1)
					πTemp002[0] = πg.NewStr("argument for i,I,l,L,q,Q,h,H must be integer").ToObject()
					if πTemp001, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					// line 95: raise StructError("argument for i,I,l,L,q,Q,h,H must be integer")
					πF.SetLineno(95)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label2
				Label2:
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp008, πE = πg.Mul(πF, πg.NewInt(8).ToObject(), µsize); πE != nil {
						continue
					}
					if πTemp007, πE = πg.Sub(πF, πTemp008, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp007); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, πTemp006, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GT(πF, µnumber, πTemp004); πE != nil {
						continue
					}
					πTemp001 = πTemp003
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label3
					}
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πTemp006, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp009, πE = πg.Mul(πF, πg.NewInt(8).ToObject(), µsize); πE != nil {
						continue
					}
					if πTemp008, πE = πg.Sub(πF, πTemp009, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp008); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Mul(πF, πTemp006, πTemp007); πE != nil {
						continue
					}
					if πTemp003, πE = πg.LT(πF, µnumber, πTemp004); πE != nil {
						continue
					}
					πTemp001 = πTemp003
				Label3:
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label4
					}
					goto Label5
					// line 96: if number > (1 << (8 * size - 1)) - 1 or number < -1 * (1 << (8 * size - 1)):
					πF.SetLineno(96)
				Label4:
					πTemp002 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("Number:%i too large to convert").ToObject(), µnumber); πE != nil {
						continue
					}
					πTemp002[0] = πTemp001
					if πTemp001, πE = πg.ResolveGlobal(πF, ßOverflowError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					// line 97: raise OverflowError("Number:%i too large to convert" % number)
					πF.SetLineno(97)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label5
				Label5:
					// line 98: return pack_int(number, size, le)
					πF.SetLineno(98)
					πTemp002 = πF.MakeArgs(3)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					πTemp002[0] = µnumber
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					πTemp002[1] = µsize
					if πE = πg.CheckLocal(πF, µle, "le"); πE != nil {
						continue
					}
					πTemp002[2] = µle
					if πTemp001, πE = πg.ResolveGlobal(πF, ßpack_int); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					πR = πTemp003
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßpack_signed_int.ToObject(), πTemp008); πE != nil {
				continue
			}
			// line 101: def pack_unsigned_int(number, size, le):
			πF.SetLineno(101)
			πTemp006 = make([]πg.Param, 3)
			πTemp006[0] = πg.Param{Name: "number", Def: nil}
			πTemp006[1] = πg.Param{Name: "size", Def: nil}
			πTemp006[2] = πg.Param{Name: "le", Def: nil}
			πTemp009 = πg.NewFunction(πg.NewCode("pack_unsigned_int", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µnumber *πg.Object = πArgs[0]; _ = µnumber
				var µsize *πg.Object = πArgs[1]; _ = µsize
				var µle *πg.Object = πArgs[2]; _ = µle
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					πTemp002 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					πTemp002[0] = µnumber
					if πTemp003, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
						continue
					}
					πTemp002[1] = πTemp003
					if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
						continue
					}
					πTemp001 = πg.GetBool(!πTemp005).ToObject()
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label1
					}
					goto Label2
					// line 102: if not isinstance(number, int):
					πF.SetLineno(102)
				Label1:
					πTemp002 = πF.MakeArgs(1)
					πTemp002[0] = πg.NewStr("argument for i,I,l,L,q,Q,h,H must be integer").ToObject()
					if πTemp001, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					// line 103: raise StructError("argument for i,I,l,L,q,Q,h,H must be integer")
					πF.SetLineno(103)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label2
				Label2:
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LT(πF, µnumber, πg.NewInt(0).ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label3
					}
					goto Label4
					// line 104: if number < 0:
					πF.SetLineno(104)
				Label3:
					πTemp002 = πF.MakeArgs(1)
					πTemp002[0] = πg.NewStr("can't convert negative long to unsigned").ToObject()
					if πTemp001, πE = πg.ResolveGlobal(πF, ßTypeError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					// line 105: raise TypeError("can't convert negative long to unsigned")
					πF.SetLineno(105)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label4
				Label4:
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp006, πE = πg.Mul(πF, πg.NewInt(8).ToObject(), µsize); πE != nil {
						continue
					}
					if πTemp004, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp006); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GT(πF, µnumber, πTemp003); πE != nil {
						continue
					}
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label5
					}
					goto Label6
					// line 106: if number > (1 << (8 * size)) - 1:
					πF.SetLineno(106)
				Label5:
					πTemp002 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("Number:%i too large to convert").ToObject(), µnumber); πE != nil {
						continue
					}
					πTemp002[0] = πTemp001
					if πTemp001, πE = πg.ResolveGlobal(πF, ßOverflowError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					// line 107: raise OverflowError("Number:%i too large to convert" % number)
					πF.SetLineno(107)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label6
				Label6:
					// line 108: return pack_int(number, size, le)
					πF.SetLineno(108)
					πTemp002 = πF.MakeArgs(3)
					if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
						continue
					}
					πTemp002[0] = µnumber
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					πTemp002[1] = µsize
					if πE = πg.CheckLocal(πF, µle, "le"); πE != nil {
						continue
					}
					πTemp002[2] = µle
					if πTemp001, πE = πg.ResolveGlobal(πF, ßpack_int); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					πR = πTemp003
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßpack_unsigned_int.ToObject(), πTemp009); πE != nil {
				continue
			}
			// line 111: def pack_char(char, size, le):
			πF.SetLineno(111)
			πTemp006 = make([]πg.Param, 3)
			πTemp006[0] = πg.Param{Name: "char", Def: nil}
			πTemp006[1] = πg.Param{Name: "size", Def: nil}
			πTemp006[2] = πg.Param{Name: "le", Def: nil}
			πTemp010 = πg.NewFunction(πg.NewCode("pack_char", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µchar *πg.Object = πArgs[0]; _ = µchar
				var µsize *πg.Object = πArgs[1]; _ = µsize
				var µle *πg.Object = πArgs[2]; _ = µle
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 112: return str(char)
					πF.SetLineno(112)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µchar, "char"); πE != nil {
						continue
					}
					πTemp001[0] = µchar
					if πTemp002, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					πR = πTemp003
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßpack_char.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 115: def isinf(x):
			πF.SetLineno(115)
			πTemp006 = make([]πg.Param, 1)
			πTemp006[0] = πg.Param{Name: "x", Def: nil}
			πTemp011 = πg.NewFunction(πg.NewCode("isinf", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µx *πg.Object = πArgs[0]; _ = µx
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 bool
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 116: return x != 0.0 and x / 2 == x
					πF.SetLineno(116)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.NE(πF, µx, πg.NewFloat(0.0).ToObject()); πE != nil {
						continue
					}
					πTemp001 = πTemp003
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if !πTemp002 {
						goto Label1
					}
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Div(πF, µx, πg.NewInt(2).ToObject()); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Eq(πF, πTemp004, µx); πE != nil {
						continue
					}
					πTemp001 = πTemp003
				Label1:
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßisinf.ToObject(), πTemp011); πE != nil {
				continue
			}
			// line 119: def isnan(v):
			πF.SetLineno(119)
			πTemp006 = make([]πg.Param, 1)
			πTemp006[0] = πg.Param{Name: "v", Def: nil}
			πTemp012 = πg.NewFunction(πg.NewCode("isnan", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µv *πg.Object = πArgs[0]; _ = µv
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 bool
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 120: return v != v * 1.0 or (v == 1.0 and v == 2.0)
					πF.SetLineno(120)
					if πE = πg.CheckLocal(πF, µv, "v"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µv, "v"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Mul(πF, µv, πg.NewFloat(1.0).ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.NE(πF, µv, πTemp004); πE != nil {
						continue
					}
					πTemp001 = πTemp003
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label1
					}
					if πE = πg.CheckLocal(πF, µv, "v"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Eq(πF, µv, πg.NewFloat(1.0).ToObject()); πE != nil {
						continue
					}
					πTemp003 = πTemp004
					if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
						continue
					}
					if !πTemp005 {
						goto Label2
					}
					if πE = πg.CheckLocal(πF, µv, "v"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Eq(πF, µv, πg.NewFloat(2.0).ToObject()); πE != nil {
						continue
					}
					πTemp003 = πTemp004
				Label2:
					πTemp001 = πTemp003
				Label1:
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßisnan.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 123: def pack_float(x, size, le):
			πF.SetLineno(123)
			πTemp006 = make([]πg.Param, 3)
			πTemp006[0] = πg.Param{Name: "x", Def: nil}
			πTemp006[1] = πg.Param{Name: "size", Def: nil}
			πTemp006[2] = πg.Param{Name: "le", Def: nil}
			πTemp013 = πg.NewFunction(πg.NewCode("pack_float", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µx *πg.Object = πArgs[0]; _ = µx
				var µsize *πg.Object = πArgs[1]; _ = µsize
				var µle *πg.Object = πArgs[2]; _ = µle
				var µunsigned *πg.Object = πg.UnboundLocal; _ = µunsigned
				var µresult *πg.Object = πg.UnboundLocal; _ = µresult
				var µi *πg.Object = πg.UnboundLocal; _ = µi
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 []πg.Param
				_ = πTemp008
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 1: goto Label1
					case 2: goto Label2
					default: panic("unexpected function state")
					}
					// line 124: unsigned = float_pack(x, size)
					πF.SetLineno(124)
					πTemp001 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					πTemp001[0] = µx
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					πTemp001[1] = µsize
					if πTemp002, πE = πg.ResolveGlobal(πF, ßfloat_pack); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µunsigned = πTemp003
					// line 125: result = []
					πF.SetLineno(125)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					µresult = πTemp002
					πTemp001 = πF.MakeArgs(1)
					πTemp001[0] = πg.NewInt(8).ToObject()
					if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
						continue
					}
					πF.PushCheckpoint(2)
					πTemp005 = false
				Label1:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp005 {
						πF.PopCheckpoint()
						goto Label3
					}
					if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp006 = !isStop
					} else {
						πTemp006 = true
						µi = πTemp003
					}
					if πE != nil || !πTemp006 {
						continue
					}
					πF.PushCheckpoint(1)            
					// line 127: result.append((unsigned >> (i * 8)) & 0xFF)
					πF.SetLineno(127)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µunsigned, "unsigned"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					if πTemp007, πE = πg.Mul(πF, µi, πg.NewInt(8).ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.RShift(πF, µunsigned, πTemp007); πE != nil {
						continue
					}
					if πTemp003, πE = πg.And(πF, πTemp004, πg.NewInt(255).ToObject()); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					continue
				Label2:
					if πE != nil || πR != nil {
						continue
					}
				Label3:
					if πE = πg.CheckLocal(πF, µle, "le"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µle, ßbig.ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label4
					}
					goto Label5
					// line 128: if le == "big":
					πF.SetLineno(128)
				Label4:
					// line 129: result.reverse()
					πF.SetLineno(129)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µresult, ßreverse, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					goto Label5
				Label5:
					// line 130: return ''.join(chr(x) for x in result)
					πF.SetLineno(130)
					πTemp001 = πF.MakeArgs(1)
					πTemp008 = make([]πg.Param, 0)
					πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/_struct.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µx *πg.Object = πg.UnboundLocal; _ = µx
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1: goto Label1
								case 2: goto Label2
								case 4: goto Label4
								default: panic("unexpected function state")
								}
								if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.Iter(πF, µresult); πE != nil {
									continue
								}
								πF.PushCheckpoint(2)
								πTemp002 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp002 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp003 = !isStop
								} else {
									πTemp003 = true
									µx = πTemp004
								}
								if πE != nil || !πTemp003 {
									continue
								}
								πF.PushCheckpoint(1)            
								// line 130: return ''.join(chr(x) for x in result)
								πF.SetLineno(130)
								πTemp005 = πF.MakeArgs(1)
								if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
									continue
								}
								πTemp005[0] = µx
								if πTemp004, πE = πg.ResolveGlobal(πF, ßchr); πE != nil {
									continue
								}
								if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp005)
								πF.PushCheckpoint(4)
								return πTemp006, nil
							Label4:
								πTemp004 = πSent
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πTemp003, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					πR = πTemp004
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßpack_float.ToObject(), πTemp013); πE != nil {
				continue
			}
			// line 133: def unpack_float(data, index, size, le):
			πF.SetLineno(133)
			πTemp006 = make([]πg.Param, 4)
			πTemp006[0] = πg.Param{Name: "data", Def: nil}
			πTemp006[1] = πg.Param{Name: "index", Def: nil}
			πTemp006[2] = πg.Param{Name: "size", Def: nil}
			πTemp006[3] = πg.Param{Name: "le", Def: nil}
			πTemp014 = πg.NewFunction(πg.NewCode("unpack_float", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µdata *πg.Object = πArgs[0]; _ = µdata
				var µindex *πg.Object = πArgs[1]; _ = µindex
				var µsize *πg.Object = πArgs[2]; _ = µsize
				var µle *πg.Object = πArgs[3]; _ = µle
				var µbinary *πg.Object = πg.UnboundLocal; _ = µbinary
				var µunsigned *πg.Object = πg.UnboundLocal; _ = µunsigned
				var µi *πg.Object = πg.UnboundLocal; _ = µi
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πTemp006 []*πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 bool
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 3: goto Label3
					case 4: goto Label4
					default: panic("unexpected function state")
					}
					// line 134: binary = [data[i] for i in range(index, index + 8)]
					πF.SetLineno(134)
					πTemp003 = make([]πg.Param, 0)
					πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/_struct.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µi *πg.Object = πg.UnboundLocal; _ = µi
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1: goto Label1
								case 2: goto Label2
								case 4: goto Label4
								default: panic("unexpected function state")
								}
								πTemp002 = πF.MakeArgs(2)
								if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
									continue
								}
								πTemp002[0] = µindex
								if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
									continue
								}
								if πTemp003, πE = πg.Add(πF, µindex, πg.NewInt(8).ToObject()); πE != nil {
									continue
								}
								πTemp002[1] = πTemp003
								if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
									continue
								}
								if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp002)
								if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
									continue
								}
								πF.PushCheckpoint(2)
								πTemp005 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp005 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp006 = !isStop
								} else {
									πTemp006 = true
									µi = πTemp003
								}
								if πE != nil || !πTemp006 {
									continue
								}
								πF.PushCheckpoint(1)            
								// line 134: binary = [data[i] for i in range(index, index + 8)]
								πF.SetLineno(134)
								if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
									continue
								}
								πTemp003 = µi
								if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
									continue
								}
								if πTemp004, πE = πg.GetItem(πF, µdata, πTemp003); πE != nil {
									continue
								}
								πF.PushCheckpoint(4)
								return πTemp004, nil
							Label4:
								πTemp003 = πSent
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
						continue
					}
					µbinary = πTemp001
					if πE = πg.CheckLocal(πF, µle, "le"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µle, ßbig.ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label1
					}
					goto Label2
					// line 135: if le == "big":
					πF.SetLineno(135)
				Label1:
					// line 136: binary.reverse()
					πF.SetLineno(136)
					if πE = πg.CheckLocal(πF, µbinary, "binary"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µbinary, ßreverse, nil); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					goto Label2
				Label2:
					// line 137: unsigned = 0
					πF.SetLineno(137)
					µunsigned = πg.NewInt(0).ToObject()
					πTemp006 = πF.MakeArgs(1)
					πTemp006[0] = πg.NewInt(8).ToObject()
					if πTemp004, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
						continue
					}
					if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πTemp001, πE = πg.Iter(πF, πTemp007); πE != nil {
						continue
					}
					πF.PushCheckpoint(4)
					πTemp005 = false
				Label3:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp005 {
						πF.PopCheckpoint()
						goto Label5
					}
					if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp008 = !isStop
					} else {
						πTemp008 = true
						µi = πTemp004
					}
					if πE != nil || !πTemp008 {
						continue
					}
					πF.PushCheckpoint(3)            
					// line 140: unsigned |= ord(binary[i]) << (i * 8)
					πF.SetLineno(140)
					if πE = πg.CheckLocal(πF, µunsigned, "unsigned"); πE != nil {
						continue
					}
					πTemp006 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp007 = µi
					if πE = πg.CheckLocal(πF, µbinary, "binary"); πE != nil {
						continue
					}
					if πTemp009, πE = πg.GetItem(πF, µbinary, πTemp007); πE != nil {
						continue
					}
					πTemp006[0] = πTemp009
					if πTemp007, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
						continue
					}
					if πTemp009, πE = πTemp007.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					if πTemp007, πE = πg.Mul(πF, µi, πg.NewInt(8).ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.LShift(πF, πTemp009, πTemp007); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IOr(πF, µunsigned, πTemp004); πE != nil {
						continue
					}
					µunsigned = πTemp007
					continue
				Label4:
					if πE != nil || πR != nil {
						continue
					}
				Label5:
					// line 141: return float_unpack(unsigned, size, le)
					πF.SetLineno(141)
					πTemp006 = πF.MakeArgs(3)
					if πE = πg.CheckLocal(πF, µunsigned, "unsigned"); πE != nil {
						continue
					}
					πTemp006[0] = µunsigned
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					πTemp006[1] = µsize
					if πE = πg.CheckLocal(πF, µle, "le"); πE != nil {
						continue
					}
					πTemp006[2] = µle
					if πTemp001, πE = πg.ResolveGlobal(πF, ßfloat_unpack); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					πR = πTemp004
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßunpack_float.ToObject(), πTemp014); πE != nil {
				continue
			}
			// line 144: def round_to_nearest(x):
			πF.SetLineno(144)
			πTemp006 = make([]πg.Param, 1)
			πTemp006[0] = πg.Param{Name: "x", Def: nil}
			πTemp015 = πg.NewFunction(πg.NewCode("round_to_nearest", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µx *πg.Object = πArgs[0]; _ = µx
				var µint_part *πg.Object = πg.UnboundLocal; _ = µint_part
				var µfrac_part *πg.Object = πg.UnboundLocal; _ = µfrac_part
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 bool
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 145: """Python 3 style round:  round a float x to the nearest int, but
					πF.SetLineno(145)
					// line 155: int_part = int(x)
					πF.SetLineno(155)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					πTemp001[0] = µx
					if πTemp002, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µint_part = πTemp003
					// line 156: frac_part = x - int_part
					πF.SetLineno(156)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µint_part, "int_part"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Sub(πF, µx, µint_part); πE != nil {
						continue
					}
					µfrac_part = πTemp002
					if πE = πg.CheckLocal(πF, µfrac_part, "frac_part"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GT(πF, µfrac_part, πg.NewFloat(0.5).ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp003
					if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp004 {
						goto Label1
					}
					if πE = πg.CheckLocal(πF, µfrac_part, "frac_part"); πE != nil {
						continue
					}
					if πTemp006, πE = πg.Eq(πF, µfrac_part, πg.NewFloat(0.5).ToObject()); πE != nil {
						continue
					}
					πTemp003 = πTemp006
					if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
						continue
					}
					if !πTemp005 {
						goto Label2
					}
					if πE = πg.CheckLocal(πF, µint_part, "int_part"); πE != nil {
						continue
					}
					if πTemp007, πE = πg.And(πF, µint_part, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.Eq(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					πTemp003 = πTemp006
				Label2:
					πTemp002 = πTemp003
				Label1:
					if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp004 {
						goto Label3
					}
					goto Label4
					// line 157: if frac_part > 0.5 or frac_part == 0.5 and int_part & 1 == 1:
					πF.SetLineno(157)
				Label3:
					// line 158: int_part += 1
					πF.SetLineno(158)
					if πE = πg.CheckLocal(πF, µint_part, "int_part"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IAdd(πF, µint_part, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					µint_part = πTemp002
					goto Label4
				Label4:
					// line 159: return int_part
					πF.SetLineno(159)
					if πE = πg.CheckLocal(πF, µint_part, "int_part"); πE != nil {
						continue
					}
					πR = µint_part
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßround_to_nearest.ToObject(), πTemp015); πE != nil {
				continue
			}
			// line 162: def float_unpack(Q, size, le):
			πF.SetLineno(162)
			πTemp006 = make([]πg.Param, 3)
			πTemp006[0] = πg.Param{Name: "Q", Def: nil}
			πTemp006[1] = πg.Param{Name: "size", Def: nil}
			πTemp006[2] = πg.Param{Name: "le", Def: nil}
			πTemp016 = πg.NewFunction(πg.NewCode("float_unpack", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µQ *πg.Object = πArgs[0]; _ = µQ
				var µsize *πg.Object = πArgs[1]; _ = µsize
				var µle *πg.Object = πArgs[2]; _ = µle
				var µMIN_EXP *πg.Object = πg.UnboundLocal; _ = µMIN_EXP
				var µMAX_EXP *πg.Object = πg.UnboundLocal; _ = µMAX_EXP
				var µMANT_DIG *πg.Object = πg.UnboundLocal; _ = µMANT_DIG
				var µBITS *πg.Object = πg.UnboundLocal; _ = µBITS
				var µsign *πg.Object = πg.UnboundLocal; _ = µsign
				var µexp *πg.Object = πg.UnboundLocal; _ = µexp
				var µmant *πg.Object = πg.UnboundLocal; _ = µmant
				var µresult *πg.Object = πg.UnboundLocal; _ = µresult
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 bool
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 []*πg.Object
				_ = πTemp009
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 163: """Convert a 32-bit or 64-bit integer created
					πF.SetLineno(163)
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µsize, πg.NewInt(8).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label1
					}
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µsize, πg.NewInt(4).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label2
					}
					goto Label3
					// line 166: if size == 8:
					πF.SetLineno(166)
				Label1:
					// line 167: MIN_EXP = -1021  # = sys.float_info.min_exp
					πF.SetLineno(167)
					if πTemp001, πE = πg.Neg(πF, πg.NewInt(1021).ToObject()); πE != nil {
						continue
					}
					µMIN_EXP = πTemp001
					// line 168: MAX_EXP = 1024   # = sys.float_info.max_exp
					πF.SetLineno(168)
					µMAX_EXP = πg.NewInt(1024).ToObject()
					// line 169: MANT_DIG = 53    # = sys.float_info.mant_dig
					πF.SetLineno(169)
					µMANT_DIG = πg.NewInt(53).ToObject()
					// line 170: BITS = 64
					πF.SetLineno(170)
					µBITS = πg.NewInt(64).ToObject()
					goto Label4
					// line 171: elif size == 4:
					πF.SetLineno(171)
				Label2:
					// line 172: MIN_EXP = -125   # C's FLT_MIN_EXP
					πF.SetLineno(172)
					if πTemp001, πE = πg.Neg(πF, πg.NewInt(125).ToObject()); πE != nil {
						continue
					}
					µMIN_EXP = πTemp001
					// line 173: MAX_EXP = 128    # FLT_MAX_EXP
					πF.SetLineno(173)
					µMAX_EXP = πg.NewInt(128).ToObject()
					// line 174: MANT_DIG = 24    # FLT_MANT_DIG
					πF.SetLineno(174)
					µMANT_DIG = πg.NewInt(24).ToObject()
					// line 175: BITS = 32
					πF.SetLineno(175)
					µBITS = πg.NewInt(32).ToObject()
					goto Label4
				Label3:
					πTemp003 = πF.MakeArgs(1)
					πTemp003[0] = πg.NewStr("invalid size value").ToObject()
					if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					// line 177: raise ValueError("invalid size value")
					πF.SetLineno(177)
					πE = πF.Raise(πTemp004, nil, nil)
					continue
					goto Label4
				Label4:
					if πE = πg.CheckLocal(πF, µQ, "Q"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µBITS, "BITS"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.RShift(πF, µQ, µBITS); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label5
					}
					goto Label6
					// line 179: if Q >> BITS:
					πF.SetLineno(179)
				Label5:
					πTemp003 = πF.MakeArgs(1)
					πTemp003[0] = πg.NewStr("input out of range").ToObject()
					if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					// line 180: raise ValueError("input out of range")
					πF.SetLineno(180)
					πE = πF.Raise(πTemp004, nil, nil)
					continue
					goto Label6
				Label6:
					// line 183: sign = Q >> BITS - 1
					πF.SetLineno(183)
					if πE = πg.CheckLocal(πF, µQ, "Q"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µBITS, "BITS"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, µBITS, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.RShift(πF, µQ, πTemp004); πE != nil {
						continue
					}
					µsign = πTemp001
					// line 184: exp = (Q & ((1 << BITS - 1) - (1 << MANT_DIG - 1))) >> MANT_DIG - 1
					πF.SetLineno(184)
					if πE = πg.CheckLocal(πF, µQ, "Q"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µBITS, "BITS"); πE != nil {
						continue
					}
					if πTemp007, πE = πg.Sub(πF, µBITS, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp007); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp008, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp008); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, πTemp006, πTemp007); πE != nil {
						continue
					}
					if πTemp004, πE = πg.And(πF, µQ, πTemp005); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.RShift(πF, πTemp004, πTemp005); πE != nil {
						continue
					}
					µexp = πTemp001
					// line 185: mant = Q & ((1 << MANT_DIG - 1) - 1)
					πF.SetLineno(185)
					if πE = πg.CheckLocal(πF, µQ, "Q"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp006, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp006); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.And(πF, µQ, πTemp004); πE != nil {
						continue
					}
					µmant = πTemp001
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMAX_EXP, "MAX_EXP"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMIN_EXP, "MIN_EXP"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µMAX_EXP, µMIN_EXP); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Add(πF, πTemp005, πg.NewInt(2).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µexp, πTemp004); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label7
					}
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µexp, πg.NewInt(0).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label8
					}
					goto Label9
					// line 187: if exp == MAX_EXP - MIN_EXP + 2:
					πF.SetLineno(187)
				Label7:
					// line 189: result = float('nan') if mant else float('inf')
					πF.SetLineno(189)
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, µmant); πE != nil {
						continue
					}
					if !πTemp002 {
						goto Label11
					}
					πTemp003 = πF.MakeArgs(1)
					πTemp003[0] = ßnan.ToObject()
					if πTemp004, πE = πg.ResolveGlobal(πF, ßfloat); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					πTemp001 = πTemp005
					goto Label12
				Label11:
					πTemp003 = πF.MakeArgs(1)
					πTemp003[0] = ßinf.ToObject()
					if πTemp004, πE = πg.ResolveGlobal(πF, ßfloat); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					πTemp001 = πTemp005
				Label12:
					µresult = πTemp001
					goto Label10
					// line 190: elif exp == 0:
					πF.SetLineno(190)
				Label8:
					// line 192: result = math.ldexp(float(mant), MIN_EXP - MANT_DIG)
					πF.SetLineno(192)
					πTemp003 = πF.MakeArgs(2)
					πTemp009 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					πTemp009[0] = µmant
					if πTemp001, πE = πg.ResolveGlobal(πF, ßfloat); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp009)
					πTemp003[0] = πTemp004
					if πE = πg.CheckLocal(πF, µMIN_EXP, "MIN_EXP"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Sub(πF, µMIN_EXP, µMANT_DIG); πE != nil {
						continue
					}
					πTemp003[1] = πTemp001
					if πTemp001, πE = πg.ResolveGlobal(πF, ßmath); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßldexp, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					µresult = πTemp001
					goto Label10
				Label9:
					// line 195: mant += 1 << MANT_DIG - 1
					πF.SetLineno(195)
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp004); πE != nil {
						continue
					}
					if πTemp004, πE = πg.IAdd(πF, µmant, πTemp001); πE != nil {
						continue
					}
					µmant = πTemp004
					// line 196: result = math.ldexp(float(mant), exp + MIN_EXP - MANT_DIG - 1)
					πF.SetLineno(196)
					πTemp003 = πF.MakeArgs(2)
					πTemp009 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					πTemp009[0] = µmant
					if πTemp001, πE = πg.ResolveGlobal(πF, ßfloat); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp009)
					πTemp003[0] = πTemp004
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMIN_EXP, "MIN_EXP"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Add(πF, µexp, µMIN_EXP); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, πTemp005, µMANT_DIG); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					πTemp003[1] = πTemp001
					if πTemp001, πE = πg.ResolveGlobal(πF, ßmath); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßldexp, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					µresult = πTemp001
					goto Label10
				Label10:
					// line 197: return -result if sign else result
					πF.SetLineno(197)
					if πE = πg.CheckLocal(πF, µsign, "sign"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, µsign); πE != nil {
						continue
					}
					if !πTemp002 {
						goto Label13
					}
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Neg(πF, µresult); πE != nil {
						continue
					}
					πTemp001 = πTemp004
					goto Label14
				Label13:
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001 = µresult
				Label14:
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßfloat_unpack.ToObject(), πTemp016); πE != nil {
				continue
			}
			// line 200: def float_pack(x, size):
			πF.SetLineno(200)
			πTemp006 = make([]πg.Param, 2)
			πTemp006[0] = πg.Param{Name: "x", Def: nil}
			πTemp006[1] = πg.Param{Name: "size", Def: nil}
			πTemp017 = πg.NewFunction(πg.NewCode("float_pack", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µx *πg.Object = πArgs[0]; _ = µx
				var µsize *πg.Object = πArgs[1]; _ = µsize
				var µMIN_EXP *πg.Object = πg.UnboundLocal; _ = µMIN_EXP
				var µMAX_EXP *πg.Object = πg.UnboundLocal; _ = µMAX_EXP
				var µMANT_DIG *πg.Object = πg.UnboundLocal; _ = µMANT_DIG
				var µBITS *πg.Object = πg.UnboundLocal; _ = µBITS
				var µsign *πg.Object = πg.UnboundLocal; _ = µsign
				var µmant *πg.Object = πg.UnboundLocal; _ = µmant
				var µexp *πg.Object = πg.UnboundLocal; _ = µexp
				var µm *πg.Object = πg.UnboundLocal; _ = µm
				var µe *πg.Object = πg.UnboundLocal; _ = µe
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 bool
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 []*πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 201: """Convert a Python float x into a 64-bit unsigned integer
					πF.SetLineno(201)
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µsize, πg.NewInt(8).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label1
					}
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µsize, πg.NewInt(4).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label2
					}
					goto Label3
					// line 204: if size == 8:
					πF.SetLineno(204)
				Label1:
					// line 205: MIN_EXP = -1021  # = sys.float_info.min_exp
					πF.SetLineno(205)
					if πTemp001, πE = πg.Neg(πF, πg.NewInt(1021).ToObject()); πE != nil {
						continue
					}
					µMIN_EXP = πTemp001
					// line 206: MAX_EXP = 1024   # = sys.float_info.max_exp
					πF.SetLineno(206)
					µMAX_EXP = πg.NewInt(1024).ToObject()
					// line 207: MANT_DIG = 53    # = sys.float_info.mant_dig
					πF.SetLineno(207)
					µMANT_DIG = πg.NewInt(53).ToObject()
					// line 208: BITS = 64
					πF.SetLineno(208)
					µBITS = πg.NewInt(64).ToObject()
					goto Label4
					// line 209: elif size == 4:
					πF.SetLineno(209)
				Label2:
					// line 210: MIN_EXP = -125   # C's FLT_MIN_EXP
					πF.SetLineno(210)
					if πTemp001, πE = πg.Neg(πF, πg.NewInt(125).ToObject()); πE != nil {
						continue
					}
					µMIN_EXP = πTemp001
					// line 211: MAX_EXP = 128    # FLT_MAX_EXP
					πF.SetLineno(211)
					µMAX_EXP = πg.NewInt(128).ToObject()
					// line 212: MANT_DIG = 24    # FLT_MANT_DIG
					πF.SetLineno(212)
					µMANT_DIG = πg.NewInt(24).ToObject()
					// line 213: BITS = 32
					πF.SetLineno(213)
					µBITS = πg.NewInt(32).ToObject()
					goto Label4
				Label3:
					πTemp003 = πF.MakeArgs(1)
					πTemp003[0] = πg.NewStr("invalid size value").ToObject()
					if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					// line 215: raise ValueError("invalid size value")
					πF.SetLineno(215)
					πE = πF.Raise(πTemp004, nil, nil)
					continue
					goto Label4
				Label4:
					// line 217: sign = math.copysign(1.0, x) < 0.0
					πF.SetLineno(217)
					πTemp003 = πF.MakeArgs(2)
					πTemp003[0] = πg.NewFloat(1.0).ToObject()
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					πTemp003[1] = µx
					if πTemp004, πE = πg.ResolveGlobal(πF, ßmath); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßcopysign, nil); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					if πTemp001, πE = πg.LT(πF, πTemp004, πg.NewFloat(0.0).ToObject()); πE != nil {
						continue
					}
					µsign = πTemp001
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					πTemp003[0] = µx
					if πTemp001, πE = πg.ResolveGlobal(πF, ßmath); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßisinf, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label5
					}
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					πTemp003[0] = µx
					if πTemp001, πE = πg.ResolveGlobal(πF, ßmath); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßisnan, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label6
					}
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µx, πg.NewFloat(0.0).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label7
					}
					goto Label8
					// line 218: if math.isinf(x):
					πF.SetLineno(218)
				Label5:
					// line 219: mant = 0
					πF.SetLineno(219)
					µmant = πg.NewInt(0).ToObject()
					// line 220: exp = MAX_EXP - MIN_EXP + 2
					πF.SetLineno(220)
					if πE = πg.CheckLocal(πF, µMAX_EXP, "MAX_EXP"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMIN_EXP, "MIN_EXP"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, µMAX_EXP, µMIN_EXP); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(2).ToObject()); πE != nil {
						continue
					}
					µexp = πTemp001
					goto Label9
					// line 221: elif math.isnan(x):
					πF.SetLineno(221)
				Label6:
					// line 222: mant = 1 << (MANT_DIG - 2)  # other values possible
					πF.SetLineno(222)
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(2).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp004); πE != nil {
						continue
					}
					µmant = πTemp001
					// line 223: exp = MAX_EXP - MIN_EXP + 2
					πF.SetLineno(223)
					if πE = πg.CheckLocal(πF, µMAX_EXP, "MAX_EXP"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMIN_EXP, "MIN_EXP"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, µMAX_EXP, µMIN_EXP); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(2).ToObject()); πE != nil {
						continue
					}
					µexp = πTemp001
					goto Label9
					// line 224: elif x == 0.0:
					πF.SetLineno(224)
				Label7:
					// line 225: mant = 0
					πF.SetLineno(225)
					µmant = πg.NewInt(0).ToObject()
					// line 226: exp = 0
					πF.SetLineno(226)
					µexp = πg.NewInt(0).ToObject()
					goto Label9
				Label8:
					// line 228: m, e = math.frexp(abs(x))  # abs(x) == m * 2**e
					πF.SetLineno(228)
					πTemp003 = πF.MakeArgs(1)
					πTemp006 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					πTemp006[0] = µx
					if πTemp001, πE = πg.ResolveGlobal(πF, ßabs); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					πTemp003[0] = πTemp004
					if πTemp001, πE = πg.ResolveGlobal(πF, ßmath); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßfrexp, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp001); πE != nil {
						continue
					}
					µm = πTemp004
					µe = πTemp005
					// line 229: exp = e - (MIN_EXP - 1)
					πF.SetLineno(229)
					if πE = πg.CheckLocal(πF, µe, "e"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMIN_EXP, "MIN_EXP"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, µMIN_EXP, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Sub(πF, µe, πTemp004); πE != nil {
						continue
					}
					µexp = πTemp001
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GT(πF, µexp, πg.NewInt(0).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label10
					}
					goto Label11
					// line 230: if exp > 0:
					πF.SetLineno(230)
				Label10:
					// line 232: mant = round_to_nearest(m * (1 << MANT_DIG))
					πF.SetLineno(232)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µm, "m"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), µMANT_DIG); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mul(πF, µm, πTemp004); πE != nil {
						continue
					}
					πTemp003[0] = πTemp001
					if πTemp001, πE = πg.ResolveGlobal(πF, ßround_to_nearest); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					µmant = πTemp004
					// line 233: mant -= 1 << MANT_DIG - 1
					πF.SetLineno(233)
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp004); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ISub(πF, µmant, πTemp001); πE != nil {
						continue
					}
					µmant = πTemp004
					goto Label12
				Label11:
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Add(πF, µexp, µMANT_DIG); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Sub(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GE(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label13
					}
					goto Label14
					// line 236: if exp + MANT_DIG - 1 >= 0:
					πF.SetLineno(236)
				Label13:
					// line 237: mant = round_to_nearest(m * (1 << exp + MANT_DIG - 1))
					πF.SetLineno(237)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µm, "m"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp007, πE = πg.Add(πF, µexp, µMANT_DIG); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp005); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mul(πF, µm, πTemp004); πE != nil {
						continue
					}
					πTemp003[0] = πTemp001
					if πTemp001, πE = πg.ResolveGlobal(πF, ßround_to_nearest); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					µmant = πTemp004
					goto Label15
				Label14:
					// line 239: mant = 0
					πF.SetLineno(239)
					µmant = πg.NewInt(0).ToObject()
					goto Label15
				Label15:
					// line 240: exp = 0
					πF.SetLineno(240)
					µexp = πg.NewInt(0).ToObject()
					goto Label12
				Label12:
					// line 243: assert 0 <= mant <= 1 << MANT_DIG - 1
					πF.SetLineno(243)
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LE(πF, πg.NewInt(0).ToObject(), µmant); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if !πTemp002 {
						goto Label16
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp005); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LE(πF, µmant, πTemp004); πE != nil {
						continue
					}
				Label16:
					if πE = πg.Assert(πF, πTemp001, nil); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp005); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µmant, πTemp004); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label17
					}
					goto Label18
					// line 244: if mant == 1 << MANT_DIG - 1:
					πF.SetLineno(244)
				Label17:
					// line 245: mant = 0
					πF.SetLineno(245)
					µmant = πg.NewInt(0).ToObject()
					// line 246: exp += 1
					πF.SetLineno(246)
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.IAdd(πF, µexp, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					µexp = πTemp001
					goto Label18
				Label18:
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMAX_EXP, "MAX_EXP"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMIN_EXP, "MIN_EXP"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µMAX_EXP, µMIN_EXP); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Add(πF, πTemp005, πg.NewInt(2).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GE(πF, µexp, πTemp004); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label19
					}
					goto Label20
					// line 250: if exp >= MAX_EXP - MIN_EXP + 2:
					πF.SetLineno(250)
				Label19:
					πTemp003 = πF.MakeArgs(1)
					πTemp003[0] = πg.NewStr("float too large to pack in this format").ToObject()
					if πTemp001, πE = πg.ResolveGlobal(πF, ßOverflowError); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					// line 251: raise OverflowError("float too large to pack in this format")
					πF.SetLineno(251)
					πE = πF.Raise(πTemp004, nil, nil)
					continue
					goto Label20
				Label20:
					goto Label9
				Label9:
					// line 254: assert 0 <= mant < 1 << MANT_DIG - 1
					πF.SetLineno(254)
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LE(πF, πg.NewInt(0).ToObject(), µmant); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if !πTemp002 {
						goto Label21
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.LShift(πF, πg.NewInt(1).ToObject(), πTemp005); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LT(πF, µmant, πTemp004); πE != nil {
						continue
					}
				Label21:
					if πE = πg.Assert(πF, πTemp001, nil); πE != nil {
						continue
					}
					// line 255: assert 0 <= exp <= MAX_EXP - MIN_EXP + 2
					πF.SetLineno(255)
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LE(πF, πg.NewInt(0).ToObject(), µexp); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if !πTemp002 {
						goto Label22
					}
					if πE = πg.CheckLocal(πF, µMAX_EXP, "MAX_EXP"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMIN_EXP, "MIN_EXP"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µMAX_EXP, µMIN_EXP); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Add(πF, πTemp005, πg.NewInt(2).ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LE(πF, µexp, πTemp004); πE != nil {
						continue
					}
				Label22:
					if πE = πg.Assert(πF, πTemp001, nil); πE != nil {
						continue
					}
					// line 256: assert 0 <= sign <= 1
					πF.SetLineno(256)
					if πE = πg.CheckLocal(πF, µsign, "sign"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.LE(πF, πg.NewInt(0).ToObject(), µsign); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if !πTemp002 {
						goto Label23
					}
					if πTemp001, πE = πg.LE(πF, µsign, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
				Label23:
					if πE = πg.Assert(πF, πTemp001, nil); πE != nil {
						continue
					}
					// line 257: return ((sign << BITS - 1) | (exp << MANT_DIG - 1)) | mant
					πF.SetLineno(257)
					if πE = πg.CheckLocal(πF, µsign, "sign"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µBITS, "BITS"); πE != nil {
						continue
					}
					if πTemp007, πE = πg.Sub(πF, µBITS, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.LShift(πF, µsign, πTemp007); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µexp, "exp"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µMANT_DIG, "MANT_DIG"); πE != nil {
						continue
					}
					if πTemp008, πE = πg.Sub(πF, µMANT_DIG, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.LShift(πF, µexp, πTemp008); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Or(πF, πTemp005, πTemp007); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µmant, "mant"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Or(πF, πTemp004, µmant); πE != nil {
						continue
					}
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßfloat_pack.ToObject(), πTemp017); πE != nil {
				continue
			}
			// line 260: big_endian_format = {
			πF.SetLineno(260)
			πTemp003 = πg.NewDict()
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(1).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßx.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(1).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßb.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(1).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_unsigned_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßB.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(1).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_char); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_char); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßc.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(1).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßs.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(1).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßp.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(2).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßh.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(2).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_unsigned_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßH.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(4).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßi.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(4).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_unsigned_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßI.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(4).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßl.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(4).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_unsigned_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßL.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(8).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_signed_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßq.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(8).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_unsigned_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_int); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßQ.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(4).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_float); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_float); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßf.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp018 = πg.NewDict()
			if πE = πTemp018.SetItem(πF, ßsize.ToObject(), πg.NewInt(8).ToObject()); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßalignment.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßpack_float); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp019, πE = πg.ResolveGlobal(πF, ßunpack_float); πE != nil {
				continue
			}
			if πE = πTemp018.SetItem(πF, ßunpack.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp018.ToObject()
			if πE = πTemp003.SetItem(πF, ßd.ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp003.ToObject()
			if πE = πF.Globals().SetItem(πF, ßbig_endian_format.ToObject(), πTemp019); πE != nil {
				continue
			}
			// line 278: default = big_endian_format
			πF.SetLineno(278)
			if πTemp019, πE = πg.ResolveGlobal(πF, ßbig_endian_format); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßdefault.ToObject(), πTemp019); πE != nil {
				continue
			}
			// line 279: formatmode = {'<': (default, 'little'),
			πF.SetLineno(279)
			πTemp003 = πg.NewDict()
			if πTemp020, πE = πg.ResolveGlobal(πF, ßdefault); πE != nil {
				continue
			}
			πTemp019 = πg.NewTuple2(πTemp020, ßlittle.ToObject()).ToObject()
			if πE = πTemp003.SetItem(πF, πg.NewStr("<").ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp020, πE = πg.ResolveGlobal(πF, ßdefault); πE != nil {
				continue
			}
			πTemp019 = πg.NewTuple2(πTemp020, ßbig.ToObject()).ToObject()
			if πE = πTemp003.SetItem(πF, πg.NewStr(">").ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp020, πE = πg.ResolveGlobal(πF, ßdefault); πE != nil {
				continue
			}
			πTemp019 = πg.NewTuple2(πTemp020, ßbig.ToObject()).ToObject()
			if πE = πTemp003.SetItem(πF, πg.NewStr("!").ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp020, πE = πg.ResolveGlobal(πF, ßdefault); πE != nil {
				continue
			}
			if πTemp021, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
				continue
			}
			if πTemp022, πE = πg.GetAttr(πF, πTemp021, ßbyteorder, nil); πE != nil {
				continue
			}
			πTemp019 = πg.NewTuple2(πTemp020, πTemp022).ToObject()
			if πE = πTemp003.SetItem(πF, πg.NewStr("=").ToObject(), πTemp019); πE != nil {
				continue
			}
			if πTemp020, πE = πg.ResolveGlobal(πF, ßdefault); πE != nil {
				continue
			}
			if πTemp021, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
				continue
			}
			if πTemp022, πE = πg.GetAttr(πF, πTemp021, ßbyteorder, nil); πE != nil {
				continue
			}
			πTemp019 = πg.NewTuple2(πTemp020, πTemp022).ToObject()
			if πE = πTemp003.SetItem(πF, πg.NewStr("@").ToObject(), πTemp019); πE != nil {
				continue
			}
			πTemp019 = πTemp003.ToObject()
			if πE = πF.Globals().SetItem(πF, ßformatmode.ToObject(), πTemp019); πE != nil {
				continue
			}
			// line 287: def getmode(fmt):
			πF.SetLineno(287)
			πTemp006 = make([]πg.Param, 1)
			πTemp006[0] = πg.Param{Name: "fmt", Def: nil}
			πTemp019 = πg.NewFunction(πg.NewCode("getmode", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µfmt *πg.Object = πArgs[0]; _ = µfmt
				var µformatdef *πg.Object = πg.UnboundLocal; _ = µformatdef
				var µendianness *πg.Object = πg.UnboundLocal; _ = µendianness
				var µindex *πg.Object = πg.UnboundLocal; _ = µindex
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.BaseException
				_ = πTemp004
				var πTemp005 *πg.Traceback
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 2: goto Label2
					default: panic("unexpected function state")
					}
					// line 288: try:
					πF.SetLineno(288)
					πF.PushCheckpoint(2)
					// line 289: formatdef, endianness = formatmode[fmt[0]]
					πF.SetLineno(289)
					πTemp002 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µfmt, πTemp002); πE != nil {
						continue
					}
					πTemp001 = πTemp003
					if πTemp003, πE = πg.ResolveGlobal(πF, ßformatmode); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
						continue
					}
					µformatdef = πTemp001
					µendianness = πTemp003
					// line 290: index = 1
					πF.SetLineno(290)
					µindex = πg.NewInt(1).ToObject()
					πF.PopCheckpoint()
					goto Label1
				Label2:
					if πE == nil {
					  continue
					}
					πE = nil
					πTemp004, πTemp005 = πF.ExcInfo()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßIndexError); πE != nil {
						continue
					}
					if πTemp003, πE = πg.ResolveGlobal(πF, ßKeyError); πE != nil {
						continue
					}
					πTemp001 = πg.NewTuple2(πTemp002, πTemp003).ToObject()
					if πTemp006, πE = πg.IsInstance(πF, πTemp004.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πTemp006 {
						goto Label3
					}
					πE = πF.Raise(πTemp004.ToObject(), nil, πTemp005.ToObject())
					continue
					// line 291: except (IndexError, KeyError):
					πF.SetLineno(291)
				Label3:
					// line 292: formatdef, endianness = formatmode['@']
					πF.SetLineno(292)
					πTemp001 = πg.NewStr("@").ToObject()
					if πTemp003, πE = πg.ResolveGlobal(πF, ßformatmode); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
						continue
					}
					µformatdef = πTemp001
					µendianness = πTemp003
					// line 293: index = 0
					πF.SetLineno(293)
					µindex = πg.NewInt(0).ToObject()
					πF.RestoreExc(nil, nil)
					goto Label1
				Label1:
					// line 294: return formatdef, endianness, index
					πF.SetLineno(294)
					if πE = πg.CheckLocal(πF, µformatdef, "formatdef"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µendianness, "endianness"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
						continue
					}
					πTemp001 = πg.NewTuple3(µformatdef, µendianness, µindex).ToObject()
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßgetmode.ToObject(), πTemp019); πE != nil {
				continue
			}
			// line 297: def getNum(fmt, i):
			πF.SetLineno(297)
			πTemp006 = make([]πg.Param, 2)
			πTemp006[0] = πg.Param{Name: "fmt", Def: nil}
			πTemp006[1] = πg.Param{Name: "i", Def: nil}
			πTemp020 = πg.NewFunction(πg.NewCode("getNum", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µfmt *πg.Object = πArgs[0]; _ = µfmt
				var µi *πg.Object = πArgs[1]; _ = µi
				var µnum *πg.Object = πg.UnboundLocal; _ = µnum
				var µcur *πg.Object = πg.UnboundLocal; _ = µcur
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 bool
				_ = πTemp003
				var πTemp004 bool
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πTemp006 []*πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 1: goto Label1
					case 2: goto Label2
					default: panic("unexpected function state")
					}
					// line 298: num = None
					πF.SetLineno(298)
					if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					µnum = πTemp001
					// line 299: cur = fmt[i]
					πF.SetLineno(299)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001 = µi
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, µfmt, πTemp001); πE != nil {
						continue
					}
					µcur = πTemp002
					// line 300: while ('0' <= cur) and (cur <= '9'):
					πF.SetLineno(300)
					πF.PushCheckpoint(2)
					πTemp003 = false
				Label1:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp003 {
						πF.PopCheckpoint()
						goto Label3
					}
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.LE(πF, ß0.ToObject(), µcur); πE != nil {
						continue
					}
					πTemp001 = πTemp002
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if !πTemp005 {
						goto Label4
					}
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.LE(πF, µcur, ß9.ToObject()); πE != nil {
						continue
					}
					πTemp001 = πTemp002
				Label4:
					if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πE != nil || !πTemp004 {
						continue
					}
					πF.PushCheckpoint(1)            
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Eq(πF, µnum, πTemp002); πE != nil {
						continue
					}
					if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp004 {
						goto Label5
					}
					goto Label6
					// line 301: if num == None:
					πF.SetLineno(301)
				Label5:
					// line 302: num = int(cur)
					πF.SetLineno(302)
					πTemp006 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					πTemp006[0] = µcur
					if πTemp001, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					µnum = πTemp002
					goto Label7
				Label6:
					// line 304: num = 10 * num + int(cur)
					πF.SetLineno(304)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Mul(πF, πg.NewInt(10).ToObject(), µnum); πE != nil {
						continue
					}
					πTemp006 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					πTemp006[0] = µcur
					if πTemp007, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
						continue
					}
					if πTemp008, πE = πTemp007.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πTemp001, πE = πg.Add(πF, πTemp002, πTemp008); πE != nil {
						continue
					}
					µnum = πTemp001
					goto Label7
				Label7:
					// line 305: i += 1
					πF.SetLineno(305)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.IAdd(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					µi = πTemp001
					// line 306: cur = fmt[i]
					πF.SetLineno(306)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001 = µi
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, µfmt, πTemp001); πE != nil {
						continue
					}
					µcur = πTemp002
					continue
				Label2:
					if πE != nil || πR != nil {
						continue
					}
				Label3:
					// line 307: return num, i
					πF.SetLineno(307)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001 = πg.NewTuple2(µnum, µi).ToObject()
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßgetNum.ToObject(), πTemp020); πE != nil {
				continue
			}
			// line 310: def calcsize(fmt):
			πF.SetLineno(310)
			πTemp006 = make([]πg.Param, 1)
			πTemp006[0] = πg.Param{Name: "fmt", Def: nil}
			πTemp021 = πg.NewFunction(πg.NewCode("calcsize", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µfmt *πg.Object = πArgs[0]; _ = µfmt
				var µformatdef *πg.Object = πg.UnboundLocal; _ = µformatdef
				var µendianness *πg.Object = πg.UnboundLocal; _ = µendianness
				var µi *πg.Object = πg.UnboundLocal; _ = µi
				var µnum *πg.Object = πg.UnboundLocal; _ = µnum
				var µresult *πg.Object = πg.UnboundLocal; _ = µresult
				var µcur *πg.Object = πg.UnboundLocal; _ = µcur
				var µformat *πg.Object = πg.UnboundLocal; _ = µformat
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				var πTemp008 *πg.BaseException
				_ = πTemp008
				var πTemp009 *πg.Traceback
				_ = πTemp009
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 1: goto Label1
					case 2: goto Label2
					case 5: goto Label5
					default: panic("unexpected function state")
					}
					// line 311: """calcsize(fmt) -> int
					πF.SetLineno(311)
					// line 315: formatdef, endianness, i = getmode(fmt)
					πF.SetLineno(315)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πTemp002, πE = πg.ResolveGlobal(πF, ßgetmode); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp003); πE != nil {
						continue
					}
					µformatdef = πTemp002
					µendianness = πTemp004
					µi = πTemp005
					// line 316: num = 0
					πF.SetLineno(316)
					µnum = πg.NewInt(0).ToObject()
					// line 317: result = 0
					πF.SetLineno(317)
					µresult = πg.NewInt(0).ToObject()
					// line 318: while i < len(fmt):
					πF.SetLineno(318)
					πF.PushCheckpoint(2)
					πTemp006 = false
				Label1:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp006 {
						πF.PopCheckpoint()
						goto Label3
					}
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.LT(πF, µi, πTemp004); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πE != nil || !πTemp007 {
						continue
					}
					πF.PushCheckpoint(1)            
					// line 319: num, i = getNum(fmt, i)
					πF.SetLineno(319)
					πTemp001 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001[1] = µi
					if πTemp002, πE = πg.ResolveGlobal(πF, ßgetNum); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
						continue
					}
					µnum = πTemp002
					µi = πTemp004
					// line 320: cur = fmt[i]
					πF.SetLineno(320)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp002 = µi
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µfmt, πTemp002); πE != nil {
						continue
					}
					µcur = πTemp003
					// line 321: try:
					πF.SetLineno(321)
					πF.PushCheckpoint(5)
					// line 322: format = formatdef[cur]
					πF.SetLineno(322)
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					πTemp002 = µcur
					if πE = πg.CheckLocal(πF, µformatdef, "formatdef"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µformatdef, πTemp002); πE != nil {
						continue
					}
					µformat = πTemp003
					πF.PopCheckpoint()
					goto Label4
				Label5:
					if πE == nil {
					  continue
					}
					πE = nil
					πTemp008, πTemp009 = πF.ExcInfo()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßKeyError); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsInstance(πF, πTemp008.ToObject(), πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label6
					}
					πE = πF.Raise(πTemp008.ToObject(), nil, πTemp009.ToObject())
					continue
					// line 323: except KeyError:
					πF.SetLineno(323)
				Label6:
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s is not a valid format").ToObject(), µcur); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 324: raise StructError("%s is not a valid format" % cur)
					πF.SetLineno(324)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					πF.RestoreExc(nil, nil)
					goto Label4
				Label4:
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					if πTemp002, πE = πg.NE(πF, µnum, πTemp003); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label7
					}
					goto Label8
					// line 325: if num != None:
					πF.SetLineno(325)
				Label7:
					// line 326: result += num * format['size']
					πF.SetLineno(326)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					πTemp003 = ßsize.ToObject()
					if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, µformat, πTemp003); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Mul(πF, µnum, πTemp004); πE != nil {
						continue
					}
					if πTemp003, πE = πg.IAdd(πF, µresult, πTemp002); πE != nil {
						continue
					}
					µresult = πTemp003
					goto Label9
				Label8:
					// line 328: result += format['size']
					πF.SetLineno(328)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp002 = ßsize.ToObject()
					if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µformat, πTemp002); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IAdd(πF, µresult, πTemp003); πE != nil {
						continue
					}
					µresult = πTemp002
					goto Label9
				Label9:
					// line 329: num = 0
					πF.SetLineno(329)
					µnum = πg.NewInt(0).ToObject()
					// line 330: i += 1
					πF.SetLineno(330)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IAdd(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					µi = πTemp002
					continue
				Label2:
					if πE != nil || πR != nil {
						continue
					}
				Label3:
					// line 331: return result
					πF.SetLineno(331)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πR = µresult
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßcalcsize.ToObject(), πTemp021); πE != nil {
				continue
			}
			// line 334: def pack(fmt, *args):
			πF.SetLineno(334)
			πTemp006 = make([]πg.Param, 1)
			πTemp006[0] = πg.Param{Name: "fmt", Def: nil}
			πTemp022 = πg.NewFunction(πg.NewCode("pack", "build/src/__python__/_struct.py", πTemp006, πg.CodeFlagVarArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µfmt *πg.Object = πArgs[0]; _ = µfmt
				var µargs *πg.Object = πArgs[1]; _ = µargs
				var µformatdef *πg.Object = πg.UnboundLocal; _ = µformatdef
				var µendianness *πg.Object = πg.UnboundLocal; _ = µendianness
				var µi *πg.Object = πg.UnboundLocal; _ = µi
				var µn_args *πg.Object = πg.UnboundLocal; _ = µn_args
				var µresult *πg.Object = πg.UnboundLocal; _ = µresult
				var µnum *πg.Object = πg.UnboundLocal; _ = µnum
				var µcur *πg.Object = πg.UnboundLocal; _ = µcur
				var µformat *πg.Object = πg.UnboundLocal; _ = µformat
				var µnum_s *πg.Object = πg.UnboundLocal; _ = µnum_s
				var µpadding *πg.Object = πg.UnboundLocal; _ = µpadding
				var µvar *πg.Object = πg.UnboundLocal; _ = µvar
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				var πTemp008 *πg.BaseException
				_ = πTemp008
				var πTemp009 *πg.Traceback
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 []*πg.Object
				_ = πTemp011
				var πTemp012 []*πg.Object
				_ = πTemp012
				var πTemp013 []*πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 bool
				_ = πTemp016
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 1: goto Label1
					case 2: goto Label2
					case 27: goto Label27
					case 28: goto Label28
					case 5: goto Label5
					default: panic("unexpected function state")
					}
					// line 335: """pack(fmt, v1, v2, ...) -> string
					πF.SetLineno(335)
					// line 338: formatdef, endianness, i = getmode(fmt)
					πF.SetLineno(338)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πTemp002, πE = πg.ResolveGlobal(πF, ßgetmode); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp003); πE != nil {
						continue
					}
					µformatdef = πTemp002
					µendianness = πTemp004
					µi = πTemp005
					// line 339: args = list(args)
					πF.SetLineno(339)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					πTemp001[0] = µargs
					if πTemp002, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µargs = πTemp003
					// line 340: n_args = len(args)
					πF.SetLineno(340)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					πTemp001[0] = µargs
					if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µn_args = πTemp003
					// line 341: result = []
					πF.SetLineno(341)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					µresult = πTemp002
					// line 342: while i < len(fmt):
					πF.SetLineno(342)
					πF.PushCheckpoint(2)
					πTemp006 = false
				Label1:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp006 {
						πF.PopCheckpoint()
						goto Label3
					}
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.LT(πF, µi, πTemp004); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πE != nil || !πTemp007 {
						continue
					}
					πF.PushCheckpoint(1)            
					// line 343: num, i = getNum(fmt, i)
					πF.SetLineno(343)
					πTemp001 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001[1] = µi
					if πTemp002, πE = πg.ResolveGlobal(πF, ßgetNum); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
						continue
					}
					µnum = πTemp002
					µi = πTemp004
					// line 344: cur = fmt[i]
					πF.SetLineno(344)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp002 = µi
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µfmt, πTemp002); πE != nil {
						continue
					}
					µcur = πTemp003
					// line 345: try:
					πF.SetLineno(345)
					πF.PushCheckpoint(5)
					// line 346: format = formatdef[cur]
					πF.SetLineno(346)
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					πTemp002 = µcur
					if πE = πg.CheckLocal(πF, µformatdef, "formatdef"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µformatdef, πTemp002); πE != nil {
						continue
					}
					µformat = πTemp003
					πF.PopCheckpoint()
					goto Label4
				Label5:
					if πE == nil {
					  continue
					}
					πE = nil
					πTemp008, πTemp009 = πF.ExcInfo()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßKeyError); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsInstance(πF, πTemp008.ToObject(), πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label6
					}
					πE = πF.Raise(πTemp008.ToObject(), nil, πTemp009.ToObject())
					continue
					// line 347: except KeyError:
					πF.SetLineno(347)
				Label6:
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s is not a valid format").ToObject(), µcur); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 348: raise StructError("%s is not a valid format" % cur)
					πF.SetLineno(348)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					πF.RestoreExc(nil, nil)
					goto Label4
				Label4:
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µnum, πTemp003); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label7
					}
					goto Label8
					// line 349: if num == None:
					πF.SetLineno(349)
				Label7:
					// line 350: num_s = 0
					πF.SetLineno(350)
					µnum_s = πg.NewInt(0).ToObject()
					// line 351: num = 1
					πF.SetLineno(351)
					µnum = πg.NewInt(1).ToObject()
					goto Label9
				Label8:
					// line 353: num_s = num
					πF.SetLineno(353)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					µnum_s = µnum
					goto Label9
				Label9:
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µcur, ßx.ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label10
					}
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µcur, ßs.ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label11
					}
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µcur, ßp.ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label12
					}
					goto Label13
					// line 355: if cur == 'x':
					πF.SetLineno(355)
				Label10:
					// line 356: result += [b'\0' * num]
					πF.SetLineno(356)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001 = make([]*πg.Object, 1)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Mul(πF, πg.NewStr("\x00").ToObject(), µnum); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πTemp003, πE = πg.IAdd(πF, µresult, πTemp002); πE != nil {
						continue
					}
					µresult = πTemp003
					goto Label14
					// line 357: elif cur == 's':
					πF.SetLineno(357)
				Label11:
					πTemp001 = πF.MakeArgs(2)
					πTemp002 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µargs, πTemp002); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πTemp002, πE = πg.ResolveGlobal(πF, ßbytes); πE != nil {
						continue
					}
					πTemp001[1] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label15
					}
					goto Label16
					// line 358: if isinstance(args[0], bytes):
					πF.SetLineno(358)
				Label15:
					// line 359: padding = num - len(args[0])
					πF.SetLineno(359)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					πTemp003 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, µargs, πTemp003); πE != nil {
						continue
					}
					πTemp001[0] = πTemp004
					if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.Sub(πF, µnum, πTemp004); πE != nil {
						continue
					}
					µpadding = πTemp002
					// line 360: result += [args[0][:num] + b'\0' * padding]
					πF.SetLineno(360)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001 = make([]*πg.Object, 1)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µnum, πg.None}, nil); πE != nil {
						continue
					}
					πTemp005 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp010, πE = πg.GetItem(πF, µargs, πTemp005); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, πTemp010, πTemp003); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µpadding, "padding"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Mul(πF, πg.NewStr("\x00").ToObject(), µpadding); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Add(πF, πTemp004, πTemp003); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πTemp003, πE = πg.IAdd(πF, µresult, πTemp002); πE != nil {
						continue
					}
					µresult = πTemp003
					// line 361: args.pop(0)
					πF.SetLineno(361)
					πTemp001 = πF.MakeArgs(1)
					πTemp001[0] = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µargs, ßpop, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					goto Label17
				Label16:
					πTemp001 = πF.MakeArgs(1)
					πTemp001[0] = πg.NewStr("arg for string format not a string").ToObject()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 363: raise StructError("arg for string format not a string")
					πF.SetLineno(363)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label17
				Label17:
					goto Label14
					// line 364: elif cur == 'p':
					πF.SetLineno(364)
				Label12:
					πTemp001 = πF.MakeArgs(2)
					πTemp002 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µargs, πTemp002); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πTemp002, πE = πg.ResolveGlobal(πF, ßbytes); πE != nil {
						continue
					}
					πTemp001[1] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label18
					}
					goto Label19
					// line 365: if isinstance(args[0], bytes):
					πF.SetLineno(365)
				Label18:
					// line 366: padding = num - len(args[0]) - 1
					πF.SetLineno(366)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					πTemp004 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetItem(πF, µargs, πTemp004); πE != nil {
						continue
					}
					πTemp001[0] = πTemp005
					if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp003, πE = πg.Sub(πF, µnum, πTemp005); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Sub(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					µpadding = πTemp002
					if πE = πg.CheckLocal(πF, µpadding, "padding"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GT(πF, µpadding, πg.NewInt(0).ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label21
					}
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.LT(πF, µnum, πg.NewInt(255).ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label22
					}
					goto Label23
					// line 368: if padding > 0:
					πF.SetLineno(368)
				Label21:
					// line 369: result += [bytes([len(args[0])]) + args[0]
					πF.SetLineno(369)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001 = make([]*πg.Object, 1)
					πTemp011 = πF.MakeArgs(1)
					πTemp012 = make([]*πg.Object, 1)
					πTemp013 = πF.MakeArgs(1)
					πTemp004 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetItem(πF, µargs, πTemp004); πE != nil {
						continue
					}
					πTemp013[0] = πTemp005
					if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp013, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp013)
					πTemp012[0] = πTemp005
					πTemp004 = πg.NewList(πTemp012...).ToObject()
					πTemp011[0] = πTemp004
					if πTemp004, πE = πg.ResolveGlobal(πF, ßbytes); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp011, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp011)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp010, πE = πg.Sub(πF, µnum, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp010, πg.None}, nil); πE != nil {
						continue
					}
					πTemp014 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp015, πE = πg.GetItem(πF, µargs, πTemp014); πE != nil {
						continue
					}
					if πTemp010, πE = πg.GetItem(πF, πTemp015, πTemp004); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Add(πF, πTemp005, πTemp010); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µpadding, "padding"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Mul(πF, πg.NewStr("\x00").ToObject(), µpadding); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Add(πF, πTemp003, πTemp004); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πTemp003, πE = πg.IAdd(πF, µresult, πTemp002); πE != nil {
						continue
					}
					µresult = πTemp003
					goto Label24
					// line 372: if num < 255:
					πF.SetLineno(372)
				Label22:
					// line 373: result += [bytes([num - 1]) + args[0][:num - 1]]
					πF.SetLineno(373)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001 = make([]*πg.Object, 1)
					πTemp011 = πF.MakeArgs(1)
					πTemp012 = make([]*πg.Object, 1)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Sub(πF, µnum, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					πTemp012[0] = πTemp003
					πTemp003 = πg.NewList(πTemp012...).ToObject()
					πTemp011[0] = πTemp003
					if πTemp003, πE = πg.ResolveGlobal(πF, ßbytes); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp011, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp011)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µnum, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp005, πg.None}, nil); πE != nil {
						continue
					}
					πTemp010 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp014, πE = πg.GetItem(πF, µargs, πTemp010); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetItem(πF, πTemp014, πTemp003); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Add(πF, πTemp004, πTemp005); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πTemp003, πE = πg.IAdd(πF, µresult, πTemp002); πE != nil {
						continue
					}
					µresult = πTemp003
					goto Label24
				Label23:
					// line 375: result += [bytes([255]) + args[0][:num - 1]]
					πF.SetLineno(375)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001 = make([]*πg.Object, 1)
					πTemp011 = πF.MakeArgs(1)
					πTemp012 = make([]*πg.Object, 1)
					πTemp012[0] = πg.NewInt(255).ToObject()
					πTemp003 = πg.NewList(πTemp012...).ToObject()
					πTemp011[0] = πTemp003
					if πTemp003, πE = πg.ResolveGlobal(πF, ßbytes); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp011, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp011)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Sub(πF, µnum, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp005, πg.None}, nil); πE != nil {
						continue
					}
					πTemp010 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp014, πE = πg.GetItem(πF, µargs, πTemp010); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetItem(πF, πTemp014, πTemp003); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Add(πF, πTemp004, πTemp005); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πTemp003, πE = πg.IAdd(πF, µresult, πTemp002); πE != nil {
						continue
					}
					µresult = πTemp003
					goto Label24
				Label24:
					// line 376: args.pop(0)
					πF.SetLineno(376)
					πTemp001 = πF.MakeArgs(1)
					πTemp001[0] = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µargs, ßpop, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					goto Label20
				Label19:
					πTemp001 = πF.MakeArgs(1)
					πTemp001[0] = πg.NewStr("arg for string format not a string").ToObject()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 378: raise StructError("arg for string format not a string")
					πF.SetLineno(378)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label20
				Label20:
					goto Label14
				Label13:
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					πTemp001[0] = µargs
					if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.LT(πF, πTemp004, µnum); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label25
					}
					goto Label26
					// line 381: if len(args) < num:
					πF.SetLineno(381)
				Label25:
					πTemp001 = πF.MakeArgs(1)
					πTemp001[0] = πg.NewStr("insufficient arguments to pack").ToObject()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 382: raise StructError("insufficient arguments to pack")
					πF.SetLineno(382)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label26
				Label26:
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µnum, πg.None}, nil); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, µargs, πTemp003); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
						continue
					}
					πF.PushCheckpoint(28)
					πTemp007 = false
				Label27:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp007 {
						πF.PopCheckpoint()
						goto Label29
					}
					if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp016 = !isStop
					} else {
						πTemp016 = true
						µvar = πTemp003
					}
					if πE != nil || !πTemp016 {
						continue
					}
					πF.PushCheckpoint(27)            
					// line 384: result += [format['pack'](var, format['size'], endianness)]
					πF.SetLineno(384)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001 = make([]*πg.Object, 1)
					πTemp011 = πF.MakeArgs(3)
					if πE = πg.CheckLocal(πF, µvar, "var"); πE != nil {
						continue
					}
					πTemp011[0] = µvar
					πTemp003 = ßsize.ToObject()
					if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, µformat, πTemp003); πE != nil {
						continue
					}
					πTemp011[1] = πTemp004
					if πE = πg.CheckLocal(πF, µendianness, "endianness"); πE != nil {
						continue
					}
					πTemp011[2] = µendianness
					πTemp003 = ßpack.ToObject()
					if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, µformat, πTemp003); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp004.Call(πF, πTemp011, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp011)
					πTemp001[0] = πTemp003
					πTemp003 = πg.NewList(πTemp001...).ToObject()
					if πTemp004, πE = πg.IAdd(πF, µresult, πTemp003); πE != nil {
						continue
					}
					µresult = πTemp004
					continue
				Label28:
					if πE != nil || πR != nil {
						continue
					}
				Label29:
					// line 385: args = args[num:]
					πF.SetLineno(385)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µnum, πg.None, πg.None}, nil); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µargs, πTemp002); πE != nil {
						continue
					}
					µargs = πTemp003
					goto Label14
				Label14:
					// line 386: num = None
					πF.SetLineno(386)
					if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					µnum = πTemp002
					// line 387: i += 1
					πF.SetLineno(387)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IAdd(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					µi = πTemp002
					continue
				Label2:
					if πE != nil || πR != nil {
						continue
					}
				Label3:
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					πTemp001[0] = µargs
					if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.NE(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp006 {
						goto Label30
					}
					goto Label31
					// line 388: if len(args) != 0:
					πF.SetLineno(388)
				Label30:
					πTemp001 = πF.MakeArgs(1)
					πTemp001[0] = πg.NewStr("too many arguments for pack format").ToObject()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 389: raise StructError("too many arguments for pack format")
					πF.SetLineno(389)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label31
				Label31:
					// line 390: return b''.join(result)
					πF.SetLineno(390)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001[0] = µresult
					if πTemp002, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					πR = πTemp003
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßpack.ToObject(), πTemp022); πE != nil {
				continue
			}
			// line 393: def unpack(fmt, data):
			πF.SetLineno(393)
			πTemp006 = make([]πg.Param, 2)
			πTemp006[0] = πg.Param{Name: "fmt", Def: nil}
			πTemp006[1] = πg.Param{Name: "data", Def: nil}
			πTemp023 = πg.NewFunction(πg.NewCode("unpack", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µfmt *πg.Object = πArgs[0]; _ = µfmt
				var µdata *πg.Object = πArgs[1]; _ = µdata
				var µformatdef *πg.Object = πg.UnboundLocal; _ = µformatdef
				var µendianness *πg.Object = πg.UnboundLocal; _ = µendianness
				var µi *πg.Object = πg.UnboundLocal; _ = µi
				var µj *πg.Object = πg.UnboundLocal; _ = µj
				var µnum *πg.Object = πg.UnboundLocal; _ = µnum
				var µresult *πg.Object = πg.UnboundLocal; _ = µresult
				var µlength *πg.Object = πg.UnboundLocal; _ = µlength
				var µcur *πg.Object = πg.UnboundLocal; _ = µcur
				var µformat *πg.Object = πg.UnboundLocal; _ = µformat
				var µn *πg.Object = πg.UnboundLocal; _ = µn
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				var πTemp008 *πg.BaseException
				_ = πTemp008
				var πTemp009 *πg.Traceback
				_ = πTemp009
				var πTemp010 bool
				_ = πTemp010
				var πTemp011 []*πg.Object
				_ = πTemp011
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 19: goto Label19
					case 18: goto Label18
					case 3: goto Label3
					case 4: goto Label4
					case 7: goto Label7
					default: panic("unexpected function state")
					}
					// line 394: """unpack(fmt, string) -> (v1, v2, ...)
					πF.SetLineno(394)
					// line 398: formatdef, endianness, i = getmode(fmt)
					πF.SetLineno(398)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πTemp002, πE = πg.ResolveGlobal(πF, ßgetmode); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp003); πE != nil {
						continue
					}
					µformatdef = πTemp002
					µendianness = πTemp004
					µi = πTemp005
					// line 399: j = 0
					πF.SetLineno(399)
					µj = πg.NewInt(0).ToObject()
					// line 400: num = 0
					πF.SetLineno(400)
					µnum = πg.NewInt(0).ToObject()
					// line 401: result = []
					πF.SetLineno(401)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					µresult = πTemp002
					// line 402: length = calcsize(fmt)
					πF.SetLineno(402)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πTemp002, πE = πg.ResolveGlobal(πF, ßcalcsize); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µlength = πTemp003
					if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					πTemp001[0] = µdata
					if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.NE(πF, µlength, πTemp004); πE != nil {
						continue
					}
					if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp006 {
						goto Label1
					}
					goto Label2
					// line 403: if length != len(data):
					πF.SetLineno(403)
				Label1:
					πTemp001 = πF.MakeArgs(1)
					πTemp001[0] = πg.NewStr("unpack str size does not match format").ToObject()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 404: raise StructError("unpack str size does not match format")
					πF.SetLineno(404)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label2
				Label2:
					// line 405: while i < len(fmt):
					πF.SetLineno(405)
					πF.PushCheckpoint(4)
					πTemp006 = false
				Label3:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp006 {
						πF.PopCheckpoint()
						goto Label5
					}
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.LT(πF, µi, πTemp004); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πE != nil || !πTemp007 {
						continue
					}
					πF.PushCheckpoint(3)            
					// line 406: num, i = getNum(fmt, i)
					πF.SetLineno(406)
					πTemp001 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp001[1] = µi
					if πTemp002, πE = πg.ResolveGlobal(πF, ßgetNum); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
						continue
					}
					µnum = πTemp002
					µi = πTemp004
					// line 407: cur = fmt[i]
					πF.SetLineno(407)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp002 = µi
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µfmt, πTemp002); πE != nil {
						continue
					}
					µcur = πTemp003
					// line 408: i += 1
					πF.SetLineno(408)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IAdd(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					µi = πTemp002
					// line 409: try:
					πF.SetLineno(409)
					πF.PushCheckpoint(7)
					// line 410: format = formatdef[cur]
					πF.SetLineno(410)
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					πTemp002 = µcur
					if πE = πg.CheckLocal(πF, µformatdef, "formatdef"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µformatdef, πTemp002); πE != nil {
						continue
					}
					µformat = πTemp003
					πF.PopCheckpoint()
					goto Label6
				Label7:
					if πE == nil {
					  continue
					}
					πE = nil
					πTemp008, πTemp009 = πF.ExcInfo()
					if πTemp002, πE = πg.ResolveGlobal(πF, ßKeyError); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsInstance(πF, πTemp008.ToObject(), πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label8
					}
					πE = πF.Raise(πTemp008.ToObject(), nil, πTemp009.ToObject())
					continue
					// line 411: except KeyError:
					πF.SetLineno(411)
				Label8:
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s is not a valid format").ToObject(), µcur); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßStructError); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 412: raise StructError("%s is not a valid format" % cur)
					πF.SetLineno(412)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					πF.RestoreExc(nil, nil)
					goto Label6
				Label6:
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, µnum); πE != nil {
						continue
					}
					πTemp002 = πg.GetBool(!πTemp007).ToObject()
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label9
					}
					goto Label10
					// line 414: if not num:
					πF.SetLineno(414)
				Label9:
					// line 415: num = 1
					πF.SetLineno(415)
					µnum = πg.NewInt(1).ToObject()
					goto Label10
				Label10:
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µcur, ßx.ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label11
					}
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µcur, ßs.ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label12
					}
					if πE = πg.CheckLocal(πF, µcur, "cur"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Eq(πF, µcur, ßp.ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label13
					}
					goto Label14
					// line 417: if cur == 'x':
					πF.SetLineno(417)
				Label11:
					// line 418: j += num
					πF.SetLineno(418)
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IAdd(πF, µj, µnum); πE != nil {
						continue
					}
					µj = πTemp002
					goto Label15
					// line 419: elif cur == 's':
					πF.SetLineno(419)
				Label12:
					// line 420: result.append(data[j:j + num])
					πF.SetLineno(420)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Add(πF, µj, µnum); πE != nil {
						continue
					}
					if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µj, πTemp003, πg.None}, nil); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µdata, πTemp002); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 421: j += num
					πF.SetLineno(421)
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IAdd(πF, µj, µnum); πE != nil {
						continue
					}
					µj = πTemp002
					goto Label15
					// line 422: elif cur == 'p':
					πF.SetLineno(422)
				Label13:
					// line 423: n = data[j]
					πF.SetLineno(423)
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					πTemp002 = µj
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µdata, πTemp002); πE != nil {
						continue
					}
					µn = πTemp003
					if πE = πg.CheckLocal(πF, µn, "n"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GE(πF, µn, µnum); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label16
					}
					goto Label17
					// line 424: if n >= num:
					πF.SetLineno(424)
				Label16:
					// line 425: n = num - 1
					πF.SetLineno(425)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Sub(πF, µnum, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					µn = πTemp002
					goto Label17
				Label17:
					// line 426: result.append(data[j + 1:j + n + 1])
					πF.SetLineno(426)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Add(πF, µj, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µn, "n"); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Add(πF, µj, µn); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Add(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πTemp003, πTemp004, πg.None}, nil); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µdata, πTemp002); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 427: j += num
					πF.SetLineno(427)
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IAdd(πF, µj, µnum); πE != nil {
						continue
					}
					µj = πTemp002
					goto Label15
				Label14:
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µnum, "num"); πE != nil {
						continue
					}
					πTemp001[0] = µnum
					if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
						continue
					}
					πF.PushCheckpoint(19)
					πTemp007 = false
				Label18:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp007 {
						πF.PopCheckpoint()
						goto Label20
					}
					if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp010 = !isStop
					} else {
						πTemp010 = true
						µn = πTemp003
					}
					if πE != nil || !πTemp010 {
						continue
					}
					πF.PushCheckpoint(18)            
					// line 430: result += [format['unpack'](data, j, format['size'], endianness)]
					πF.SetLineno(430)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001 = make([]*πg.Object, 1)
					πTemp011 = πF.MakeArgs(4)
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					πTemp011[0] = µdata
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					πTemp011[1] = µj
					πTemp003 = ßsize.ToObject()
					if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, µformat, πTemp003); πE != nil {
						continue
					}
					πTemp011[2] = πTemp004
					if πE = πg.CheckLocal(πF, µendianness, "endianness"); πE != nil {
						continue
					}
					πTemp011[3] = µendianness
					πTemp003 = ßunpack.ToObject()
					if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, µformat, πTemp003); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp004.Call(πF, πTemp011, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp011)
					πTemp001[0] = πTemp003
					πTemp003 = πg.NewList(πTemp001...).ToObject()
					if πTemp004, πE = πg.IAdd(πF, µresult, πTemp003); πE != nil {
						continue
					}
					µresult = πTemp004
					// line 431: j += format['size']
					πF.SetLineno(431)
					if πE = πg.CheckLocal(πF, µj, "j"); πE != nil {
						continue
					}
					πTemp003 = ßsize.ToObject()
					if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetItem(πF, µformat, πTemp003); πE != nil {
						continue
					}
					if πTemp003, πE = πg.IAdd(πF, µj, πTemp004); πE != nil {
						continue
					}
					µj = πTemp003
					continue
				Label19:
					if πE != nil || πR != nil {
						continue
					}
				Label20:
					goto Label15
				Label15:
					continue
				Label4:
					if πE != nil || πR != nil {
						continue
					}
				Label5:
					// line 433: return tuple(result)
					πF.SetLineno(433)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp001[0] = µresult
					if πTemp002, πE = πg.ResolveGlobal(πF, ßtuple); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					πR = πTemp003
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßunpack.ToObject(), πTemp023); πE != nil {
				continue
			}
			// line 436: def pack_into(fmt, buf, offset, *args):
			πF.SetLineno(436)
			πTemp006 = make([]πg.Param, 3)
			πTemp006[0] = πg.Param{Name: "fmt", Def: nil}
			πTemp006[1] = πg.Param{Name: "buf", Def: nil}
			πTemp006[2] = πg.Param{Name: "offset", Def: nil}
			πTemp024 = πg.NewFunction(πg.NewCode("pack_into", "build/src/__python__/_struct.py", πTemp006, πg.CodeFlagVarArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µfmt *πg.Object = πArgs[0]; _ = µfmt
				var µbuf *πg.Object = πArgs[1]; _ = µbuf
				var µoffset *πg.Object = πArgs[2]; _ = µoffset
				var µargs *πg.Object = πArgs[3]; _ = µargs
				var µdata *πg.Object = πg.UnboundLocal; _ = µdata
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 437: data = pack(fmt, *args)
					πF.SetLineno(437)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveGlobal(πF, ßpack); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Invoke(πF, πTemp002, πTemp001, µargs, nil, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µdata = πTemp003
					// line 438: buffer(buf)[offset:offset + len(data)] = data
					πF.SetLineno(438)
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µdata); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µbuf, "buf"); πE != nil {
						continue
					}
					πTemp001[0] = µbuf
					if πTemp003, πE = πg.ResolveGlobal(πF, ßbuffer); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					πTemp001[0] = µdata
					if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp005, πE = πg.Add(πF, µoffset, πTemp007); πE != nil {
						continue
					}
					if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πTemp005, πg.None}, nil); πE != nil {
						continue
					}
					if πE = πg.SetItem(πF, πTemp004, πTemp003, πTemp002); πE != nil {
						continue
					}
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßpack_into.ToObject(), πTemp024); πE != nil {
				continue
			}
			// line 441: def unpack_from(fmt, buf, offset=0):
			πF.SetLineno(441)
			πTemp006 = make([]πg.Param, 3)
			πTemp006[0] = πg.Param{Name: "fmt", Def: nil}
			πTemp006[1] = πg.Param{Name: "buf", Def: nil}
			πTemp006[2] = πg.Param{Name: "offset", Def: πg.NewInt(0).ToObject()}
			πTemp025 = πg.NewFunction(πg.NewCode("unpack_from", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µfmt *πg.Object = πArgs[0]; _ = µfmt
				var µbuf *πg.Object = πArgs[1]; _ = µbuf
				var µoffset *πg.Object = πArgs[2]; _ = µoffset
				var µsize *πg.Object = πg.UnboundLocal; _ = µsize
				var µdata *πg.Object = πg.UnboundLocal; _ = µdata
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 442: size = calcsize(fmt)
					πF.SetLineno(442)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πTemp002, πE = πg.ResolveGlobal(πF, ßcalcsize); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					µsize = πTemp003
					// line 443: data = buffer(buf)[offset:offset + size]
					πF.SetLineno(443)
					if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Add(πF, µoffset, µsize); πE != nil {
						continue
					}
					if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πTemp003, πg.None}, nil); πE != nil {
						continue
					}
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µbuf, "buf"); πE != nil {
						continue
					}
					πTemp001[0] = µbuf
					if πTemp004, πE = πg.ResolveGlobal(πF, ßbuffer); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
						continue
					}
					µdata = πTemp003
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					πTemp001[0] = µdata
					if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.NE(πF, πTemp004, µsize); πE != nil {
						continue
					}
					if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
						continue
					}
					if πTemp006 {
						goto Label1
					}
					goto Label2
					// line 444: if len(data) != size:
					πF.SetLineno(444)
				Label1:
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
						continue
					}
					πTemp003 = πg.NewTuple1(µsize).ToObject()
					if πTemp002, πE = πg.Mod(πF, πg.NewStr("unpack_from requires a buffer of at least %d bytes").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßerror); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					// line 445: raise error("unpack_from requires a buffer of at least %d bytes"
					πF.SetLineno(445)
					πE = πF.Raise(πTemp003, nil, nil)
					continue
					goto Label2
				Label2:
					// line 447: return unpack(fmt, data)
					πF.SetLineno(447)
					πTemp001 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µfmt, "fmt"); πE != nil {
						continue
					}
					πTemp001[0] = µfmt
					if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
						continue
					}
					πTemp001[1] = µdata
					if πTemp002, πE = πg.ResolveGlobal(πF, ßunpack); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					πR = πTemp003
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßunpack_from.ToObject(), πTemp025); πE != nil {
				continue
			}
			// line 450: def _clearcache():
			πF.SetLineno(450)
			πTemp006 = make([]πg.Param, 0)
			πTemp026 = πg.NewFunction(πg.NewCode("_clearcache", "build/src/__python__/_struct.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 451: "Clear the internal cache."
					πF.SetLineno(451)
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ß_clearcache.ToObject(), πTemp026); πE != nil {
				continue
			}
		}
		return nil, πE
	})
	πg.RegisterModule("_struct", Code)
}
