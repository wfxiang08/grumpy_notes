package argparse
import πg "grumpy"
var Code *πg.Code
func init() {
	Code = πg.NewCode("<module>", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
		var πR *πg.Object; _ = πR
		var πE *πg.BaseException; _ = πE
		ß := πg.InternStr("")
		ßA := πg.InternStr("A")
		ßAction := πg.InternStr("Action")
		ßArgumentDefaultsHelpFormatter := πg.InternStr("ArgumentDefaultsHelpFormatter")
		ßArgumentError := πg.InternStr("ArgumentError")
		ßArgumentParser := πg.InternStr("ArgumentParser")
		ßArgumentTypeError := πg.InternStr("ArgumentTypeError")
		ßAttributeError := πg.InternStr("AttributeError")
		ßCOLUMNS := πg.InternStr("COLUMNS")
		ßException := πg.InternStr("Exception")
		ßFalse := πg.InternStr("False")
		ßFileType := πg.InternStr("FileType")
		ßHelpFormatter := πg.InternStr("HelpFormatter")
		ßIOError := πg.InternStr("IOError")
		ßKeyError := πg.InternStr("KeyError")
		ßMAPPING_SUB := πg.InternStr("MAPPING_SUB")
		ßNamespace := πg.InternStr("Namespace")
		ßNone := πg.InternStr("None")
		ßNotImplemented := πg.InternStr("NotImplemented")
		ßNotImplementedError := πg.InternStr("NotImplementedError")
		ßO := πg.InternStr("O")
		ßONE_OR_MORE := πg.InternStr("ONE_OR_MORE")
		ßOPTIONAL := πg.InternStr("OPTIONAL")
		ßPARSER := πg.InternStr("PARSER")
		ßREMAINDER := πg.InternStr("REMAINDER")
		ßRawDescriptionHelpFormatter := πg.InternStr("RawDescriptionHelpFormatter")
		ßRawTextHelpFormatter := πg.InternStr("RawTextHelpFormatter")
		ßSUPPRESS := πg.InternStr("SUPPRESS")
		ßTrue := πg.InternStr("True")
		ßTypeError := πg.InternStr("TypeError")
		ßValueError := πg.InternStr("ValueError")
		ßZERO_OR_MORE := πg.InternStr("ZERO_OR_MORE")
		ß_ := πg.InternStr("_")
		ß_ActionsContainer := πg.InternStr("_ActionsContainer")
		ß_AppendAction := πg.InternStr("_AppendAction")
		ß_AppendConstAction := πg.InternStr("_AppendConstAction")
		ß_ArgumentGroup := πg.InternStr("_ArgumentGroup")
		ß_AttributeHolder := πg.InternStr("_AttributeHolder")
		ß_ChoicesPseudoAction := πg.InternStr("_ChoicesPseudoAction")
		ß_CountAction := πg.InternStr("_CountAction")
		ß_HelpAction := πg.InternStr("_HelpAction")
		ß_MutuallyExclusiveGroup := πg.InternStr("_MutuallyExclusiveGroup")
		ß_Section := πg.InternStr("_Section")
		ß_StoreAction := πg.InternStr("_StoreAction")
		ß_StoreConstAction := πg.InternStr("_StoreConstAction")
		ß_StoreFalseAction := πg.InternStr("_StoreFalseAction")
		ß_StoreTrueAction := πg.InternStr("_StoreTrueAction")
		ß_SubParsersAction := πg.InternStr("_SubParsersAction")
		ß_UNRECOGNIZED_ARGS_ATTR := πg.InternStr("_UNRECOGNIZED_ARGS_ATTR")
		ß_VersionAction := πg.InternStr("_VersionAction")
		ß__all__ := πg.InternStr("__all__")
		ß__bases__ := πg.InternStr("__bases__")
		ß__call__ := πg.InternStr("__call__")
		ß__contains__ := πg.InternStr("__contains__")
		ß__dict__ := πg.InternStr("__dict__")
		ß__eq__ := πg.InternStr("__eq__")
		ß__hash__ := πg.InternStr("__hash__")
		ß__init__ := πg.InternStr("__init__")
		ß__metaclass__ := πg.InternStr("__metaclass__")
		ß__module__ := πg.InternStr("__module__")
		ß__name__ := πg.InternStr("__name__")
		ß__ne__ := πg.InternStr("__ne__")
		ß__repr__ := πg.InternStr("__repr__")
		ß__str__ := πg.InternStr("__str__")
		ß__version__ := πg.InternStr("__version__")
		ß_action_groups := πg.InternStr("_action_groups")
		ß_action_max_length := πg.InternStr("_action_max_length")
		ß_actions := πg.InternStr("_actions")
		ß_add_action := πg.InternStr("_add_action")
		ß_add_container_actions := πg.InternStr("_add_container_actions")
		ß_add_item := πg.InternStr("_add_item")
		ß_bufsize := πg.InternStr("_bufsize")
		ß_callable := πg.InternStr("_callable")
		ß_check_conflict := πg.InternStr("_check_conflict")
		ß_check_value := πg.InternStr("_check_value")
		ß_choices_actions := πg.InternStr("_choices_actions")
		ß_collections := πg.InternStr("_collections")
		ß_container := πg.InternStr("_container")
		ß_current_indent := πg.InternStr("_current_indent")
		ß_current_section := πg.InternStr("_current_section")
		ß_dedent := πg.InternStr("_dedent")
		ß_defaults := πg.InternStr("_defaults")
		ß_ensure_value := πg.InternStr("_ensure_value")
		ß_expand_help := πg.InternStr("_expand_help")
		ß_fill_text := πg.InternStr("_fill_text")
		ß_format_action := πg.InternStr("_format_action")
		ß_format_action_invocation := πg.InternStr("_format_action_invocation")
		ß_format_actions_usage := πg.InternStr("_format_actions_usage")
		ß_format_args := πg.InternStr("_format_args")
		ß_format_text := πg.InternStr("_format_text")
		ß_format_usage := πg.InternStr("_format_usage")
		ß_get_action_name := πg.InternStr("_get_action_name")
		ß_get_args := πg.InternStr("_get_args")
		ß_get_formatter := πg.InternStr("_get_formatter")
		ß_get_handler := πg.InternStr("_get_handler")
		ß_get_help_string := πg.InternStr("_get_help_string")
		ß_get_kwargs := πg.InternStr("_get_kwargs")
		ß_get_nargs_pattern := πg.InternStr("_get_nargs_pattern")
		ß_get_option_tuples := πg.InternStr("_get_option_tuples")
		ß_get_optional_actions := πg.InternStr("_get_optional_actions")
		ß_get_optional_kwargs := πg.InternStr("_get_optional_kwargs")
		ß_get_positional_actions := πg.InternStr("_get_positional_actions")
		ß_get_positional_kwargs := πg.InternStr("_get_positional_kwargs")
		ß_get_subactions := πg.InternStr("_get_subactions")
		ß_get_value := πg.InternStr("_get_value")
		ß_get_values := πg.InternStr("_get_values")
		ß_group_actions := πg.InternStr("_group_actions")
		ß_handle_conflict_error := πg.InternStr("_handle_conflict_error")
		ß_handle_conflict_resolve := πg.InternStr("_handle_conflict_resolve")
		ß_has_negative_number_optionals := πg.InternStr("_has_negative_number_optionals")
		ß_indent := πg.InternStr("_indent")
		ß_indent_increment := πg.InternStr("_indent_increment")
		ß_iter_indented_subactions := πg.InternStr("_iter_indented_subactions")
		ß_join_parts := πg.InternStr("_join_parts")
		ß_level := πg.InternStr("_level")
		ß_long_break_matcher := πg.InternStr("_long_break_matcher")
		ß_match_argument := πg.InternStr("_match_argument")
		ß_match_arguments_partial := πg.InternStr("_match_arguments_partial")
		ß_max_help_position := πg.InternStr("_max_help_position")
		ß_metavar_formatter := πg.InternStr("_metavar_formatter")
		ß_mode := πg.InternStr("_mode")
		ß_mutually_exclusive_groups := πg.InternStr("_mutually_exclusive_groups")
		ß_name_parser_map := πg.InternStr("_name_parser_map")
		ß_negative_number_matcher := πg.InternStr("_negative_number_matcher")
		ß_option_string_actions := πg.InternStr("_option_string_actions")
		ß_optionals := πg.InternStr("_optionals")
		ß_os := πg.InternStr("_os")
		ß_parse_known_args := πg.InternStr("_parse_known_args")
		ß_parse_optional := πg.InternStr("_parse_optional")
		ß_parser_class := πg.InternStr("_parser_class")
		ß_pop_action_class := πg.InternStr("_pop_action_class")
		ß_positionals := πg.InternStr("_positionals")
		ß_print_message := πg.InternStr("_print_message")
		ß_prog := πg.InternStr("_prog")
		ß_prog_prefix := πg.InternStr("_prog_prefix")
		ß_re := πg.InternStr("_re")
		ß_read_args_from_files := πg.InternStr("_read_args_from_files")
		ß_registries := πg.InternStr("_registries")
		ß_registry_get := πg.InternStr("_registry_get")
		ß_remove_action := πg.InternStr("_remove_action")
		ß_root_section := πg.InternStr("_root_section")
		ß_split_lines := πg.InternStr("_split_lines")
		ß_subparsers := πg.InternStr("_subparsers")
		ß_sys := πg.InternStr("_sys")
		ß_textwrap := πg.InternStr("_textwrap")
		ß_unrecognized_args := πg.InternStr("_unrecognized_args")
		ß_whitespace_matcher := πg.InternStr("_whitespace_matcher")
		ß_width := πg.InternStr("_width")
		ßaction := πg.InternStr("action")
		ßadd := πg.InternStr("add")
		ßadd_argument := πg.InternStr("add_argument")
		ßadd_argument_group := πg.InternStr("add_argument_group")
		ßadd_arguments := πg.InternStr("add_arguments")
		ßadd_help := πg.InternStr("add_help")
		ßadd_mutually_exclusive_group := πg.InternStr("add_mutually_exclusive_group")
		ßadd_parser := πg.InternStr("add_parser")
		ßadd_subparsers := πg.InternStr("add_subparsers")
		ßadd_text := πg.InternStr("add_text")
		ßadd_usage := πg.InternStr("add_usage")
		ßappend := πg.InternStr("append")
		ßappend_const := πg.InternStr("append_const")
		ßargument_default := πg.InternStr("argument_default")
		ßargument_name := πg.InternStr("argument_name")
		ßargv := πg.InternStr("argv")
		ßbasename := πg.InternStr("basename")
		ßbasestring := πg.InternStr("basestring")
		ßchoices := πg.InternStr("choices")
		ßclose := πg.InternStr("close")
		ßcompile := πg.InternStr("compile")
		ßconflict_handler := πg.InternStr("conflict_handler")
		ßconst := πg.InternStr("const")
		ßcontainer := πg.InternStr("container")
		ßconvert_arg_line_to_args := πg.InternStr("convert_arg_line_to_args")
		ßcount := πg.InternStr("count")
		ßdefault := πg.InternStr("default")
		ßdescription := πg.InternStr("description")
		ßdest := πg.InternStr("dest")
		ßdict := πg.InternStr("dict")
		ßdict_pop := πg.InternStr("dict_pop")
		ßend_section := πg.InternStr("end_section")
		ßendswith := πg.InternStr("endswith")
		ßenumerate := πg.InternStr("enumerate")
		ßenviron := πg.InternStr("environ")
		ßepilog := πg.InternStr("epilog")
		ßerror := πg.InternStr("error")
		ßexc_info := πg.InternStr("exc_info")
		ßexit := πg.InternStr("exit")
		ßfill := πg.InternStr("fill")
		ßfindall := πg.InternStr("findall")
		ßformat_help := πg.InternStr("format_help")
		ßformat_usage := πg.InternStr("format_usage")
		ßformat_version := πg.InternStr("format_version")
		ßformatter := πg.InternStr("formatter")
		ßformatter_class := πg.InternStr("formatter_class")
		ßfromfile_prefix_chars := πg.InternStr("fromfile_prefix_chars")
		ßget := πg.InternStr("get")
		ßget_default := πg.InternStr("get_default")
		ßgetattr := πg.InternStr("getattr")
		ßgroup := πg.InternStr("group")
		ßgroups := πg.InternStr("groups")
		ßh := πg.InternStr("h")
		ßhasattr := πg.InternStr("hasattr")
		ßheading := πg.InternStr("heading")
		ßhelp := πg.InternStr("help")
		ßint := πg.InternStr("int")
		ßisinstance := πg.InternStr("isinstance")
		ßitems := πg.InternStr("items")
		ßiter := πg.InternStr("iter")
		ßjoin := πg.InternStr("join")
		ßlen := πg.InternStr("len")
		ßlist := πg.InternStr("list")
		ßlist_remove := πg.InternStr("list_remove")
		ßlstrip := πg.InternStr("lstrip")
		ßmap := πg.InternStr("map")
		ßmatch := πg.InternStr("match")
		ßmax := πg.InternStr("max")
		ßmessage := πg.InternStr("message")
		ßmetavar := πg.InternStr("metavar")
		ßmin := πg.InternStr("min")
		ßnargs := πg.InternStr("nargs")
		ßobject := πg.InternStr("object")
		ßopen := πg.InternStr("open")
		ßoption_strings := πg.InternStr("option_strings")
		ßparent := πg.InternStr("parent")
		ßparse_args := πg.InternStr("parse_args")
		ßparse_known_args := πg.InternStr("parse_known_args")
		ßparser_class := πg.InternStr("parser_class")
		ßparsers := πg.InternStr("parsers")
		ßpath := πg.InternStr("path")
		ßpop := πg.InternStr("pop")
		ßprefix_chars := πg.InternStr("prefix_chars")
		ßprint_help := πg.InternStr("print_help")
		ßprint_usage := πg.InternStr("print_usage")
		ßprint_version := πg.InternStr("print_version")
		ßprog := πg.InternStr("prog")
		ßr := πg.InternStr("r")
		ßrange := πg.InternStr("range")
		ßread := πg.InternStr("read")
		ßregister := πg.InternStr("register")
		ßreplace := πg.InternStr("replace")
		ßrepr := πg.InternStr("repr")
		ßrequired := πg.InternStr("required")
		ßset := πg.InternStr("set")
		ßset_defaults := πg.InternStr("set_defaults")
		ßsetattr := πg.InternStr("setattr")
		ßsetdefault := πg.InternStr("setdefault")
		ßsorted := πg.InternStr("sorted")
		ßsplit := πg.InternStr("split")
		ßsplitlines := πg.InternStr("splitlines")
		ßstart_section := πg.InternStr("start_section")
		ßstartswith := πg.InternStr("startswith")
		ßstderr := πg.InternStr("stderr")
		ßstdin := πg.InternStr("stdin")
		ßstdout := πg.InternStr("stdout")
		ßstore := πg.InternStr("store")
		ßstore_const := πg.InternStr("store_const")
		ßstore_false := πg.InternStr("store_false")
		ßstore_true := πg.InternStr("store_true")
		ßstr := πg.InternStr("str")
		ßstrip := πg.InternStr("strip")
		ßsub := πg.InternStr("sub")
		ßsubcommands := πg.InternStr("subcommands")
		ßsuper := πg.InternStr("super")
		ßtitle := πg.InternStr("title")
		ßtuple := πg.InternStr("tuple")
		ßtype := πg.InternStr("type")
		ßupdate := πg.InternStr("update")
		ßupper := πg.InternStr("upper")
		ßusage := πg.InternStr("usage")
		ßv := πg.InternStr("v")
		ßversion := πg.InternStr("version")
		ßw := πg.InternStr("w")
		ßwrap := πg.InternStr("wrap")
		ßwrite := πg.InternStr("write")
		ßzip := πg.InternStr("zip")
		var πTemp001 []*πg.Object
		_ = πTemp001
		var πTemp002 *πg.Object
		_ = πTemp002
		var πTemp003 []πg.Param
		_ = πTemp003
		var πTemp004 *πg.Object
		_ = πTemp004
		var πTemp005 *πg.Object
		_ = πTemp005
		var πTemp006 *πg.Object
		_ = πTemp006
		var πTemp007 *πg.Object
		_ = πTemp007
		var πTemp008 *πg.Dict
		_ = πTemp008
		var πTemp009 *πg.Object
		_ = πTemp009
		var πTemp010 *πg.Object
		_ = πTemp010
		var πTemp011 *πg.Object
		_ = πTemp011
		var πTemp012 *πg.Object
		_ = πTemp012
		for ; πF.State() >= 0; πF.PopCheckpoint() {
			switch πF.State() {
			case 0:
			default: panic("unexpected function state")
			}
			// line 3: """Command-line parsing library
			πF.SetLineno(3)
			// line 64: __version__ = '1.1'
			πF.SetLineno(64)
			if πE = πF.Globals().SetItem(πF, ß__version__.ToObject(), πg.NewStr("1.1").ToObject()); πE != nil {
				continue
			}
			// line 65: __all__ = [
			πF.SetLineno(65)
			πTemp001 = make([]*πg.Object, 16)
			πTemp001[0] = ßArgumentParser.ToObject()
			πTemp001[1] = ßArgumentError.ToObject()
			πTemp001[2] = ßArgumentTypeError.ToObject()
			πTemp001[3] = ßFileType.ToObject()
			πTemp001[4] = ßHelpFormatter.ToObject()
			πTemp001[5] = ßArgumentDefaultsHelpFormatter.ToObject()
			πTemp001[6] = ßRawDescriptionHelpFormatter.ToObject()
			πTemp001[7] = ßRawTextHelpFormatter.ToObject()
			πTemp001[8] = ßNamespace.ToObject()
			πTemp001[9] = ßAction.ToObject()
			πTemp001[10] = ßONE_OR_MORE.ToObject()
			πTemp001[11] = ßOPTIONAL.ToObject()
			πTemp001[12] = ßPARSER.ToObject()
			πTemp001[13] = ßREMAINDER.ToObject()
			πTemp001[14] = ßSUPPRESS.ToObject()
			πTemp001[15] = ßZERO_OR_MORE.ToObject()
			πTemp002 = πg.NewList(πTemp001...).ToObject()
			if πE = πF.Globals().SetItem(πF, ß__all__.ToObject(), πTemp002); πE != nil {
				continue
			}
			// line 85: import collections as _collections
			πF.SetLineno(85)
			if πTemp001, πE = πg.ImportModule(πF, "collections"); πE != nil {
				continue
			}
			πTemp002 = πTemp001[0]
			if πE = πF.Globals().SetItem(πF, ß_collections.ToObject(), πTemp002); πE != nil {
				continue
			}
			// line 87: import os as _os
			πF.SetLineno(87)
			if πTemp001, πE = πg.ImportModule(πF, "os"); πE != nil {
				continue
			}
			πTemp002 = πTemp001[0]
			if πE = πF.Globals().SetItem(πF, ß_os.ToObject(), πTemp002); πE != nil {
				continue
			}
			// line 88: import re as _re
			πF.SetLineno(88)
			if πTemp001, πE = πg.ImportModule(πF, "re"); πE != nil {
				continue
			}
			πTemp002 = πTemp001[0]
			if πE = πF.Globals().SetItem(πF, ß_re.ToObject(), πTemp002); πE != nil {
				continue
			}
			// line 89: import sys as _sys
			πF.SetLineno(89)
			if πTemp001, πE = πg.ImportModule(πF, "sys"); πE != nil {
				continue
			}
			πTemp002 = πTemp001[0]
			if πE = πF.Globals().SetItem(πF, ß_sys.ToObject(), πTemp002); πE != nil {
				continue
			}
			// line 90: import textwrap as _textwrap
			πF.SetLineno(90)
			if πTemp001, πE = πg.ImportModule(πF, "textwrap"); πE != nil {
				continue
			}
			πTemp002 = πTemp001[0]
			if πE = πF.Globals().SetItem(πF, ß_textwrap.ToObject(), πTemp002); πE != nil {
				continue
			}
			// line 93: _ = lambda x: x
			πF.SetLineno(93)
			πTemp003 = make([]πg.Param, 1)
			πTemp003[0] = πg.Param{Name: "x", Def: nil}
			πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µx *πg.Object = πArgs[0]; _ = µx
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 93: _ = lambda x: x
					πF.SetLineno(93)
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					πR = µx
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ß_.ToObject(), πTemp002); πE != nil {
				continue
			}
			// line 95: def setdefault(d, k, default=None):
			πF.SetLineno(95)
			πTemp003 = make([]πg.Param, 3)
			πTemp003[0] = πg.Param{Name: "d", Def: nil}
			πTemp003[1] = πg.Param{Name: "k", Def: nil}
			if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
				continue
			}
			πTemp003[2] = πg.Param{Name: "default", Def: πTemp004}
			πTemp002 = πg.NewFunction(πg.NewCode("setdefault", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µd *πg.Object = πArgs[0]; _ = µd
				var µk *πg.Object = πArgs[1]; _ = µk
				var µdefault *πg.Object = πArgs[2]; _ = µdefault
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 bool
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					if πE = πg.CheckLocal(πF, µk, "k"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µd, "d"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Contains(πF, µd, µk); πE != nil {
						continue
					}
					πTemp001 = πg.GetBool(!πTemp002).ToObject()
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label1
					}
					goto Label2
					// line 96: if k not in d:
					πF.SetLineno(96)
				Label1:
					// line 97: d[k] = default
					πF.SetLineno(97)
					if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µdefault); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µd, "d"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µk, "k"); πE != nil {
						continue
					}
					πTemp003 = µk
					if πE = πg.SetItem(πF, µd, πTemp003, πTemp001); πE != nil {
						continue
					}
					goto Label2
				Label2:
					// line 98: return d[k]
					πF.SetLineno(98)
					if πE = πg.CheckLocal(πF, µk, "k"); πE != nil {
						continue
					}
					πTemp001 = µk
					if πE = πg.CheckLocal(πF, µd, "d"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µd, πTemp001); πE != nil {
						continue
					}
					πR = πTemp003
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßsetdefault.ToObject(), πTemp002); πE != nil {
				continue
			}
			// line 100: def dict_pop(d, k, default=None):
			πF.SetLineno(100)
			πTemp003 = make([]πg.Param, 3)
			πTemp003[0] = πg.Param{Name: "d", Def: nil}
			πTemp003[1] = πg.Param{Name: "k", Def: nil}
			if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
				continue
			}
			πTemp003[2] = πg.Param{Name: "default", Def: πTemp005}
			πTemp004 = πg.NewFunction(πg.NewCode("dict_pop", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µd *πg.Object = πArgs[0]; _ = µd
				var µk *πg.Object = πArgs[1]; _ = µk
				var µdefault *πg.Object = πArgs[2]; _ = µdefault
				var µret *πg.Object = πg.UnboundLocal; _ = µret
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 bool
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					if πE = πg.CheckLocal(πF, µk, "k"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µd, "d"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Contains(πF, µd, µk); πE != nil {
						continue
					}
					πTemp001 = πg.GetBool(πTemp002).ToObject()
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label1
					}
					goto Label2
					// line 101: if k in d:
					πF.SetLineno(101)
				Label1:
					// line 102: ret = d[k]
					πF.SetLineno(102)
					if πE = πg.CheckLocal(πF, µk, "k"); πE != nil {
						continue
					}
					πTemp001 = µk
					if πE = πg.CheckLocal(πF, µd, "d"); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, µd, πTemp001); πE != nil {
						continue
					}
					µret = πTemp003
					// line 103: del d[k]
					πF.SetLineno(103)
					if πE = πg.CheckLocal(πF, µd, "d"); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µk, "k"); πE != nil {
						continue
					}
					πTemp001 = µk
					if πE = πg.DelItem(πF, µd, πTemp001); πE != nil {
						continue
					}
					// line 104: return ret
					πF.SetLineno(104)
					if πE = πg.CheckLocal(πF, µret, "ret"); πE != nil {
						continue
					}
					πR = µret
					continue
					goto Label2
				Label2:
					if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.IsTrue(πF, µdefault); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label3
					}
					goto Label4
					// line 105: if default:
					πF.SetLineno(105)
				Label3:
					// line 106: return default
					πF.SetLineno(106)
					if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
						continue
					}
					πR = µdefault
					continue
					goto Label4
				Label4:
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßdict_pop.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 108: def list_remove(l, x):
			πF.SetLineno(108)
			πTemp003 = make([]πg.Param, 2)
			πTemp003[0] = πg.Param{Name: "l", Def: nil}
			πTemp003[1] = πg.Param{Name: "x", Def: nil}
			πTemp005 = πg.NewFunction(πg.NewCode("list_remove", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µl *πg.Object = πArgs[0]; _ = µl
				var µx *πg.Object = πArgs[1]; _ = µx
				var µi *πg.Object = πg.UnboundLocal; _ = µi
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 1: goto Label1
					case 2: goto Label2
					default: panic("unexpected function state")
					}
					πTemp002 = πF.MakeArgs(1)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µl, "l"); πE != nil {
						continue
					}
					πTemp003[0] = µl
					if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					πTemp002[0] = πTemp005
					if πTemp004, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
						continue
					}
					πF.PushCheckpoint(2)
					πTemp006 = false
				Label1:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp006 {
						πF.PopCheckpoint()
						goto Label3
					}
					if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp007 = !isStop
					} else {
						πTemp007 = true
						µi = πTemp004
					}
					if πE != nil || !πTemp007 {
						continue
					}
					πF.PushCheckpoint(1)            
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp005 = µi
					if πE = πg.CheckLocal(πF, µl, "l"); πE != nil {
						continue
					}
					if πTemp008, πE = πg.GetItem(πF, µl, πTemp005); πE != nil {
						continue
					}
					if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.Eq(πF, πTemp008, µx); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label4
					}
					goto Label5
					// line 110: if l[i] == x:
					πF.SetLineno(110)
				Label4:
					// line 111: l.pop(i)
					πF.SetLineno(111)
					πTemp002 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
						continue
					}
					πTemp002[0] = µi
					if πE = πg.CheckLocal(πF, µl, "l"); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, µl, ßpop, nil); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					// line 112: break
					πF.SetLineno(112)
					πTemp006 = true
					continue
					goto Label5
				Label5:
					continue
				Label2:
					if πE != nil || πR != nil {
						continue
					}
				Label3:
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßlist_remove.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 114: MAPPING_SUB = _re.compile(r'%\(([^)]+)\)s').sub
			πF.SetLineno(114)
			πTemp001 = πF.MakeArgs(1)
			πTemp001[0] = πg.NewStr("%\\(([^)]+)\\)s").ToObject()
			if πTemp006, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
				continue
			}
			if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßcompile, nil); πE != nil {
				continue
			}
			if πTemp006, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
				continue
			}
			πF.FreeArgs(πTemp001)
			if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßsub, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMAPPING_SUB.ToObject(), πTemp007); πE != nil {
				continue
			}
			// line 116: def _callable(obj):
			πF.SetLineno(116)
			πTemp003 = make([]πg.Param, 1)
			πTemp003[0] = πg.Param{Name: "obj", Def: nil}
			πTemp006 = πg.NewFunction(πg.NewCode("_callable", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µobj *πg.Object = πArgs[0]; _ = µobj
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 bool
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 117: return hasattr(obj, '__call__') or hasattr(obj, '__bases__')
					πF.SetLineno(117)
					πTemp003 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µobj, "obj"); πE != nil {
						continue
					}
					πTemp003[0] = µobj
					πTemp003[1] = ß__call__.ToObject()
					if πTemp004, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					πTemp001 = πTemp005
					if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp002 {
						goto Label1
					}
					πTemp003 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µobj, "obj"); πE != nil {
						continue
					}
					πTemp003[0] = µobj
					πTemp003[1] = ß__bases__.ToObject()
					if πTemp004, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					πTemp001 = πTemp005
				Label1:
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ß_callable.ToObject(), πTemp006); πE != nil {
				continue
			}
			// line 120: SUPPRESS = '==SUPPRESS=='
			πF.SetLineno(120)
			if πE = πF.Globals().SetItem(πF, ßSUPPRESS.ToObject(), πg.NewStr("==SUPPRESS==").ToObject()); πE != nil {
				continue
			}
			// line 122: OPTIONAL = '?'
			πF.SetLineno(122)
			if πE = πF.Globals().SetItem(πF, ßOPTIONAL.ToObject(), πg.NewStr("?").ToObject()); πE != nil {
				continue
			}
			// line 123: ZERO_OR_MORE = '*'
			πF.SetLineno(123)
			if πE = πF.Globals().SetItem(πF, ßZERO_OR_MORE.ToObject(), πg.NewStr("*").ToObject()); πE != nil {
				continue
			}
			// line 124: ONE_OR_MORE = '+'
			πF.SetLineno(124)
			if πE = πF.Globals().SetItem(πF, ßONE_OR_MORE.ToObject(), πg.NewStr("+").ToObject()); πE != nil {
				continue
			}
			// line 125: PARSER = 'A...'
			πF.SetLineno(125)
			if πE = πF.Globals().SetItem(πF, ßPARSER.ToObject(), πg.NewStr("A...").ToObject()); πE != nil {
				continue
			}
			// line 126: REMAINDER = '...'
			πF.SetLineno(126)
			if πE = πF.Globals().SetItem(πF, ßREMAINDER.ToObject(), πg.NewStr("...").ToObject()); πE != nil {
				continue
			}
			// line 127: _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'
			πF.SetLineno(127)
			if πE = πF.Globals().SetItem(πF, ß_UNRECOGNIZED_ARGS_ATTR.ToObject(), ß_unrecognized_args.ToObject()); πE != nil {
				continue
			}
			// line 133: class _AttributeHolder(object):
			πF.SetLineno(133)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp001[0] = πTemp010
			πTemp008 = πg.NewDict()
			if πTemp007, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp007); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_AttributeHolder", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 134: """Abstract base class that provides __repr__.
					πF.SetLineno(134)
					// line 142: def __repr__(self):
					πF.SetLineno(142)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__repr__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µtype_name *πg.Object = πg.UnboundLocal; _ = µtype_name
						var µarg_strings *πg.Object = πg.UnboundLocal; _ = µarg_strings
						var µarg *πg.Object = πg.UnboundLocal; _ = µarg
						var µname *πg.Object = πg.UnboundLocal; _ = µname
						var µvalue *πg.Object = πg.UnboundLocal; _ = µvalue
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							case 4: goto Label4
							case 5: goto Label5
							default: panic("unexpected function state")
							}
							// line 143: type_name = type(self).__name__
							πF.SetLineno(143)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßtype); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ß__name__, nil); πE != nil {
								continue
							}
							µtype_name = πTemp002
							// line 144: arg_strings = []
							πF.SetLineno(144)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µarg_strings = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_get_args, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µarg = πTemp003
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)            
							// line 146: arg_strings.append(repr(arg))
							πF.SetLineno(146)
							πTemp001 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg, "arg"); πE != nil {
								continue
							}
							πTemp007[0] = µarg
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrepr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µarg_strings, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_get_kwargs, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(5)
							πTemp005 = false
						Label4:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label6
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp008}}}, πTemp003); πE != nil {
									continue
								}
								µname = πTemp004
								µvalue = πTemp008
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(4)            
							// line 148: arg_strings.append('%s=%r' % (name, value))
							πF.SetLineno(148)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple2(µname, µvalue).ToObject()
							if πTemp003, πE = πg.Mod(πF, πg.NewStr("%s=%r").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µarg_strings, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label5:
							if πE != nil || πR != nil {
								continue
							}
						Label6:
							// line 149: return '%s(%s)' % (type_name, ', '.join(arg_strings))
							πF.SetLineno(149)
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							πTemp001[0] = µarg_strings
							if πTemp004, πE = πg.GetAttr(πF, πg.NewStr(", ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp003 = πg.NewTuple2(µtype_name, πTemp008).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s(%s)").ToObject(), πTemp003); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__repr__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 151: def _get_kwargs(self):
					πF.SetLineno(151)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("_get_kwargs", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 152: return sorted(self.__dict__.items())
							πF.SetLineno(152)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß__dict__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßitems, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsorted); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_kwargs.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 154: def _get_args(self):
					πF.SetLineno(154)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("_get_args", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 155: return []
							πF.SetLineno(155)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_args.ToObject(), πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("_AttributeHolder").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_AttributeHolder.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 158: def _ensure_value(namespace, name, value):
			πF.SetLineno(158)
			πTemp003 = make([]πg.Param, 3)
			πTemp003[0] = πg.Param{Name: "namespace", Def: nil}
			πTemp003[1] = πg.Param{Name: "name", Def: nil}
			πTemp003[2] = πg.Param{Name: "value", Def: nil}
			πTemp007 = πg.NewFunction(πg.NewCode("_ensure_value", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µnamespace *πg.Object = πArgs[0]; _ = µnamespace
				var µname *πg.Object = πArgs[1]; _ = µname
				var µvalue *πg.Object = πArgs[2]; _ = µvalue
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					πTemp002 = πF.MakeArgs(3)
					if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
						continue
					}
					πTemp002[0] = µnamespace
					if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
						continue
					}
					πTemp002[1] = µname
					if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πTemp003
					if πTemp003, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					πTemp001 = πg.GetBool(πTemp004 == πTemp003).ToObject()
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label1
					}
					goto Label2
					// line 159: if getattr(namespace, name, None) is None:
					πF.SetLineno(159)
				Label1:
					// line 160: setattr(namespace, name, value)
					πF.SetLineno(160)
					πTemp002 = πF.MakeArgs(3)
					if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
						continue
					}
					πTemp002[0] = µnamespace
					if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
						continue
					}
					πTemp002[1] = µname
					if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
						continue
					}
					πTemp002[2] = µvalue
					if πTemp001, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					goto Label2
				Label2:
					// line 161: return getattr(namespace, name)
					πF.SetLineno(161)
					πTemp002 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
						continue
					}
					πTemp002[0] = µnamespace
					if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
						continue
					}
					πTemp002[1] = µname
					if πTemp001, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					πR = πTemp003
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ß_ensure_value.ToObject(), πTemp007); πE != nil {
				continue
			}
			// line 168: class HelpFormatter(object):
			πF.SetLineno(168)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp011, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp001[0] = πTemp011
			πTemp008 = πg.NewDict()
			if πTemp009, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp009); πE != nil {
				continue
			}
			_, πE = πg.NewCode("HelpFormatter", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Dict
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 []*πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 *πg.Object
				_ = πTemp019
				var πTemp020 *πg.Object
				_ = πTemp020
				var πTemp021 *πg.Object
				_ = πTemp021
				var πTemp022 *πg.Object
				_ = πTemp022
				var πTemp023 *πg.Object
				_ = πTemp023
				var πTemp024 *πg.Object
				_ = πTemp024
				var πTemp025 *πg.Object
				_ = πTemp025
				var πTemp026 *πg.Object
				_ = πTemp026
				var πTemp027 *πg.Object
				_ = πTemp027
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 169: """Formatter for generating usage messages and argument help strings.
					πF.SetLineno(169)
					// line 175: def __init__(self,
					πF.SetLineno(175)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "prog", Def: nil}
					πTemp002[2] = πg.Param{Name: "indent_increment", Def: πg.NewInt(2).ToObject()}
					πTemp002[3] = πg.Param{Name: "max_help_position", Def: πg.NewInt(24).ToObject()}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "width", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µprog *πg.Object = πArgs[1]; _ = µprog
						var µindent_increment *πg.Object = πArgs[2]; _ = µindent_increment
						var µmax_help_position *πg.Object = πArgs[3]; _ = µmax_help_position
						var µwidth *πg.Object = πArgs[4]; _ = µwidth
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.BaseException
						_ = πTemp007
						var πTemp008 *πg.Traceback
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4: goto Label4
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µwidth == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 182: if width is None:
							πF.SetLineno(182)
						Label1:
							// line 183: try:
							πF.SetLineno(183)
							πF.PushCheckpoint(4)
							// line 184: width = int(_os.environ['COLUMNS'])
							πF.SetLineno(184)
							πTemp004 = πF.MakeArgs(1)
							πTemp001 = ßCOLUMNS.ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ß_os); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßenviron, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp006, πTemp001); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µwidth = πTemp002
							πF.PopCheckpoint()
							goto Label3
						Label4:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp007, πTemp008 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßKeyError); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, πTemp005).ToObject()
							if πTemp003, πE = πg.IsInstance(πF, πTemp007.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							πE = πF.Raise(πTemp007.ToObject(), nil, πTemp008.ToObject())
							continue
							// line 185: except (KeyError, ValueError):
							πF.SetLineno(185)
						Label5:
							// line 186: width = 80
							πF.SetLineno(186)
							µwidth = πg.NewInt(80).ToObject()
							πF.RestoreExc(nil, nil)
							goto Label3
						Label3:
							// line 187: width -= 2
							πF.SetLineno(187)
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ISub(πF, µwidth, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							µwidth = πTemp001
							goto Label2
						Label2:
							// line 189: self._prog = prog
							πF.SetLineno(189)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µprog); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_prog, πTemp001); πE != nil {
								continue
							}
							// line 190: self._indent_increment = indent_increment
							πF.SetLineno(190)
							if πE = πg.CheckLocal(πF, µindent_increment, "indent_increment"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µindent_increment); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_indent_increment, πTemp001); πE != nil {
								continue
							}
							// line 191: self._max_help_position = max_help_position
							πF.SetLineno(191)
							if πE = πg.CheckLocal(πF, µmax_help_position, "max_help_position"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µmax_help_position); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_max_help_position, πTemp001); πE != nil {
								continue
							}
							// line 192: self._max_help_position = min(max_help_position,
							πF.SetLineno(192)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmax_help_position, "max_help_position"); πE != nil {
								continue
							}
							πTemp004[0] = µmax_help_position
							πTemp009 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, µwidth, πg.NewInt(20).ToObject()); πE != nil {
								continue
							}
							πTemp009[0] = πTemp001
							if πE = πg.CheckLocal(πF, µindent_increment, "indent_increment"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mul(πF, µindent_increment, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							πTemp009[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßmax); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp004[1] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßmin); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_max_help_position, πTemp001); πE != nil {
								continue
							}
							// line 194: self._width = width
							πF.SetLineno(194)
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µwidth); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_width, πTemp001); πE != nil {
								continue
							}
							// line 196: self._current_indent = 0
							πF.SetLineno(196)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_current_indent, πTemp001); πE != nil {
								continue
							}
							// line 197: self._level = 0
							πF.SetLineno(197)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_level, πTemp001); πE != nil {
								continue
							}
							// line 198: self._action_max_length = 0
							πF.SetLineno(198)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_action_max_length, πTemp001); πE != nil {
								continue
							}
							// line 200: self._root_section = self._Section(self, None)
							πF.SetLineno(200)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp004[0] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp004[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_Section, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_root_section, πTemp001); πE != nil {
								continue
							}
							// line 201: self._current_section = self._root_section
							πF.SetLineno(201)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_root_section, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_current_section, πTemp002); πE != nil {
								continue
							}
							// line 203: self._whitespace_matcher = _re.compile(r'\s+')
							πF.SetLineno(203)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("\\s+").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_whitespace_matcher, πTemp002); πE != nil {
								continue
							}
							// line 204: self._long_break_matcher = _re.compile(r'\n\n\n+')
							πF.SetLineno(204)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("\\n\\n\\n+").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_long_break_matcher, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 209: def _indent(self):
					πF.SetLineno(209)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("_indent", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 210: self._current_indent += self._indent_increment
							πF.SetLineno(210)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_indent_increment, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp001, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_current_indent, πTemp003); πE != nil {
								continue
							}
							// line 211: self._level += 1
							πF.SetLineno(211)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_level, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_level, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_indent.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 213: def _dedent(self):
					πF.SetLineno(213)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("_dedent", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 214: self._current_indent -= self._indent_increment
							πF.SetLineno(214)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_indent_increment, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ISub(πF, πTemp001, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_current_indent, πTemp003); πE != nil {
								continue
							}
							// line 215: assert self._current_indent >= 0, 'Indent decreased below 0.'
							πF.SetLineno(215)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GE(πF, πTemp002, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.Assert(πF, πTemp001, πg.NewStr("Indent decreased below 0.").ToObject()); πE != nil {
								continue
							}
							// line 216: self._level -= 1
							πF.SetLineno(216)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_level, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ISub(πF, πTemp001, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_level, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_dedent.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 218: class _Section(object):
					πF.SetLineno(218)
					πTemp007 = make([]*πg.Object, 1)
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßobject); πE != nil {
						continue
					}
					πTemp007[0] = πTemp009
					πTemp005 = πg.NewDict()
					if πTemp006, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
						continue
					}
					if πE = πTemp005.SetItem(πF, ß__module__.ToObject(), πTemp006); πE != nil {
						continue
					}
					_, πE = πg.NewCode("_Section", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
						πClass := πTemp005
						_ = πClass
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []πg.Param
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 220: def __init__(self, formatter, parent, heading=None):
							πF.SetLineno(220)
							πTemp002 = make([]πg.Param, 4)
							πTemp002[0] = πg.Param{Name: "self", Def: nil}
							πTemp002[1] = πg.Param{Name: "formatter", Def: nil}
							πTemp002[2] = πg.Param{Name: "parent", Def: nil}
							if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
								continue
							}
							πTemp002[3] = πg.Param{Name: "heading", Def: πTemp003}
							πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µself *πg.Object = πArgs[0]; _ = µself
								var µformatter *πg.Object = πArgs[1]; _ = µformatter
								var µparent *πg.Object = πArgs[2]; _ = µparent
								var µheading *πg.Object = πArgs[3]; _ = µheading
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 []*πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default: panic("unexpected function state")
									}
									// line 221: self.formatter = formatter
									πF.SetLineno(221)
									if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
										continue
									}
									if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µformatter); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πE = πg.SetAttr(πF, µself, ßformatter, πTemp001); πE != nil {
										continue
									}
									// line 222: self.parent = parent
									πF.SetLineno(222)
									if πE = πg.CheckLocal(πF, µparent, "parent"); πE != nil {
										continue
									}
									if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µparent); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πE = πg.SetAttr(πF, µself, ßparent, πTemp001); πE != nil {
										continue
									}
									// line 223: self.heading = heading
									πF.SetLineno(223)
									if πE = πg.CheckLocal(πF, µheading, "heading"); πE != nil {
										continue
									}
									if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µheading); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πE = πg.SetAttr(πF, µself, ßheading, πTemp001); πE != nil {
										continue
									}
									// line 224: self.items = []
									πF.SetLineno(224)
									πTemp002 = make([]*πg.Object, 0)
									πTemp001 = πg.NewList(πTemp002...).ToObject()
									if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πE = πg.SetAttr(πF, µself, ßitems, πTemp003); πE != nil {
										continue
									}
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
								continue
							}
							// line 226: def format_help(self):
							πF.SetLineno(226)
							πTemp002 = make([]πg.Param, 1)
							πTemp002[0] = πg.Param{Name: "self", Def: nil}
							πTemp003 = πg.NewFunction(πg.NewCode("format_help", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µself *πg.Object = πArgs[0]; _ = µself
								var µjoin *πg.Object = πg.UnboundLocal; _ = µjoin
								var µfunc *πg.Object = πg.UnboundLocal; _ = µfunc
								var µargs *πg.Object = πg.UnboundLocal; _ = µargs
								var µitem_help *πg.Object = πg.UnboundLocal; _ = µitem_help
								var µcurrent_indent *πg.Object = πg.UnboundLocal; _ = µcurrent_indent
								var µheading *πg.Object = πg.UnboundLocal; _ = µheading
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 bool
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πTemp007 []*πg.Object
								_ = πTemp007
								var πTemp008 []πg.Param
								_ = πTemp008
								var πTemp009 *πg.Object
								_ = πTemp009
								var πTemp010 []*πg.Object
								_ = πTemp010
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									case 3: goto Label3
									case 4: goto Label4
									default: panic("unexpected function state")
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(πTemp002 != πTemp003).ToObject()
									if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label1
									}
									goto Label2
									// line 228: if self.parent is not None:
									πF.SetLineno(228)
								Label1:
									// line 229: self.formatter._indent()
									πF.SetLineno(229)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ßformatter, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, πTemp001, ß_indent, nil); πE != nil {
										continue
									}
									if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
										continue
									}
									goto Label2
								Label2:
									// line 230: join = self.formatter._join_parts
									πF.SetLineno(230)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ßformatter, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, πTemp001, ß_join_parts, nil); πE != nil {
										continue
									}
									µjoin = πTemp002
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßitems, nil); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
										continue
									}
									πF.PushCheckpoint(4)
									πTemp004 = false
								Label3:
									if πE != nil || πR != nil {
										continue
									}
									if πTemp004 {
										πF.PopCheckpoint()
										goto Label5
									}
									if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
										isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
										if exc != nil {
											πE = exc
										} else if isStop {
											πE = nil
											πF.RestoreExc(nil, nil)
										}
										πTemp005 = !isStop
									} else {
										πTemp005 = true
										if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp006}}}, πTemp002); πE != nil {
											continue
										}
										µfunc = πTemp003
										µargs = πTemp006
									}
									if πE != nil || !πTemp005 {
										continue
									}
									πF.PushCheckpoint(3)            
									// line 232: func(*args)
									πF.SetLineno(232)
									if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µfunc, "func"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.Invoke(πF, µfunc, nil, µargs, nil, nil); πE != nil {
										continue
									}
									continue
								Label4:
									if πE != nil || πR != nil {
										continue
									}
								Label5:
									// line 233: item_help = join([func(*args) for func, args in self.items])
									πF.SetLineno(233)
									πTemp007 = πF.MakeArgs(1)
									πTemp008 = make([]πg.Param, 0)
									πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
										var µfunc *πg.Object = πg.UnboundLocal; _ = µfunc
										var µargs *πg.Object = πg.UnboundLocal; _ = µargs
										var πTemp001 *πg.Object
										_ = πTemp001
										var πTemp002 *πg.Object
										_ = πTemp002
										var πTemp003 bool
										_ = πTemp003
										var πTemp004 bool
										_ = πTemp004
										var πTemp005 *πg.Object
										_ = πTemp005
										var πTemp006 *πg.Object
										_ = πTemp006
										var πR *πg.Object; _ = πR
										var πE *πg.BaseException; _ = πE
										return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
											for ; πF.State() >= 0; πF.PopCheckpoint() {
												switch πF.State() {
												case 0:
												case 1: goto Label1
												case 2: goto Label2
												case 4: goto Label4
												default: panic("unexpected function state")
												}
												if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
													continue
												}
												if πTemp002, πE = πg.GetAttr(πF, µself, ßitems, nil); πE != nil {
													continue
												}
												if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
													continue
												}
												πF.PushCheckpoint(2)
												πTemp003 = false
											Label1:
												if πE != nil || πR != nil {
													continue
												}
												if πTemp003 {
													πF.PopCheckpoint()
													goto Label3
												}
												if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
													isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
													if exc != nil {
														πE = exc
													} else if isStop {
														πE = nil
														πF.RestoreExc(nil, nil)
													}
													πTemp004 = !isStop
												} else {
													πTemp004 = true
													if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp002); πE != nil {
														continue
													}
													µfunc = πTemp005
													µargs = πTemp006
												}
												if πE != nil || !πTemp004 {
													continue
												}
												πF.PushCheckpoint(1)            
												// line 233: item_help = join([func(*args) for func, args in self.items])
												πF.SetLineno(233)
												if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
													continue
												}
												if πE = πg.CheckLocal(πF, µfunc, "func"); πE != nil {
													continue
												}
												if πTemp002, πE = πg.Invoke(πF, µfunc, nil, µargs, nil, nil); πE != nil {
													continue
												}
												πF.PushCheckpoint(4)
												return πTemp002, nil
											Label4:
												πTemp005 = πSent
												continue
											Label2:
												if πE != nil || πR != nil {
													continue
												}
											Label3:
											}
											return nil, πE
										}).ToObject(), nil
									}), πF.Globals()).ToObject()
									if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
										continue
									}
									if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp003}, nil); πE != nil {
										continue
									}
									πTemp007[0] = πTemp001
									if πE = πg.CheckLocal(πF, µjoin, "join"); πE != nil {
										continue
									}
									if πTemp001, πE = µjoin.Call(πF, πTemp007, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp007)
									µitem_help = πTemp001
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
										continue
									}
									if πTemp006, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(πTemp003 != πTemp006).ToObject()
									if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label6
									}
									goto Label7
									// line 234: if self.parent is not None:
									πF.SetLineno(234)
								Label6:
									// line 235: self.formatter._dedent()
									πF.SetLineno(235)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ßformatter, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, πTemp001, ß_dedent, nil); πE != nil {
										continue
									}
									if πTemp001, πE = πTemp003.Call(πF, nil, nil); πE != nil {
										continue
									}
									goto Label7
								Label7:
									if πE = πg.CheckLocal(πF, µitem_help, "item_help"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.IsTrue(πF, µitem_help); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(!πTemp004).ToObject()
									if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label8
									}
									goto Label9
									// line 238: if not item_help:
									πF.SetLineno(238)
								Label8:
									// line 239: return ''
									πF.SetLineno(239)
									πR = ß.ToObject()
									continue
									goto Label9
								Label9:
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp006, πE = πg.GetAttr(πF, µself, ßheading, nil); πE != nil {
										continue
									}
									if πTemp009, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
										continue
									}
									πTemp003 = πg.GetBool(πTemp006 != πTemp009).ToObject()
									πTemp001 = πTemp003
									if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if !πTemp004 {
										goto Label10
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp006, πE = πg.GetAttr(πF, µself, ßheading, nil); πE != nil {
										continue
									}
									if πTemp009, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
										continue
									}
									πTemp003 = πg.GetBool(πTemp006 != πTemp009).ToObject()
									πTemp001 = πTemp003
								Label10:
									if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label11
									}
									goto Label12
									// line 242: if self.heading is not SUPPRESS and self.heading is not None:
									πF.SetLineno(242)
								Label11:
									// line 243: current_indent = self.formatter._current_indent
									πF.SetLineno(243)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ßformatter, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, πTemp001, ß_current_indent, nil); πE != nil {
										continue
									}
									µcurrent_indent = πTemp003
									// line 245: heading = ' ' * current_indent + self.heading + ':\n'
									πF.SetLineno(245)
									if πE = πg.CheckLocal(πF, µcurrent_indent, "current_indent"); πE != nil {
										continue
									}
									if πTemp006, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), µcurrent_indent); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp009, πE = πg.GetAttr(πF, µself, ßheading, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πg.Add(πF, πTemp006, πTemp009); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr(":\n").ToObject()); πE != nil {
										continue
									}
									µheading = πTemp001
									goto Label13
								Label12:
									// line 247: heading = ''
									πF.SetLineno(247)
									µheading = ß.ToObject()
									goto Label13
								Label13:
									// line 250: return join(['\n', heading, item_help, '\n'])
									πF.SetLineno(250)
									πTemp007 = πF.MakeArgs(1)
									πTemp010 = make([]*πg.Object, 4)
									πTemp010[0] = πg.NewStr("\n").ToObject()
									if πE = πg.CheckLocal(πF, µheading, "heading"); πE != nil {
										continue
									}
									πTemp010[1] = µheading
									if πE = πg.CheckLocal(πF, µitem_help, "item_help"); πE != nil {
										continue
									}
									πTemp010[2] = µitem_help
									πTemp010[3] = πg.NewStr("\n").ToObject()
									πTemp001 = πg.NewList(πTemp010...).ToObject()
									πTemp007[0] = πTemp001
									if πE = πg.CheckLocal(πF, µjoin, "join"); πE != nil {
										continue
									}
									if πTemp001, πE = µjoin.Call(πF, πTemp007, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp007)
									πR = πTemp001
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							if πE = πClass.SetItem(πF, ßformat_help.ToObject(), πTemp003); πE != nil {
								continue
							}
						}
						return nil, nil
					}).Eval(πF, πF.Globals(), nil, nil)
					if πE != nil {
						continue
					}
					if πTemp008, πE = πTemp005.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
						continue
					}
					if πTemp008 == nil {
						πTemp008 = πg.TypeType.ToObject()
					}
					if πTemp009, πE = πTemp008.Call(πF, []*πg.Object{πg.NewStr("_Section").ToObject(), πg.NewTuple(πTemp007...).ToObject(), πTemp005.ToObject()}, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß_Section.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 252: def _add_item(self, func, args):
					πF.SetLineno(252)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "func", Def: nil}
					πTemp002[2] = πg.Param{Name: "args", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("_add_item", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µfunc *πg.Object = πArgs[1]; _ = µfunc
						var µargs *πg.Object = πArgs[2]; _ = µargs
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 253: self._current_section.items.append((func, args))
							πF.SetLineno(253)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfunc, "func"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(µfunc, µargs).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_current_section, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßitems, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_add_item.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 258: def start_section(self, heading):
					πF.SetLineno(258)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "heading", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("start_section", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µheading *πg.Object = πArgs[1]; _ = µheading
						var µsection *πg.Object = πg.UnboundLocal; _ = µsection
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 259: self._indent()
							πF.SetLineno(259)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_indent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 260: section = self._Section(self, self._current_section, heading)
							πF.SetLineno(260)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[0] = µself
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_current_section, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µheading, "heading"); πE != nil {
								continue
							}
							πTemp003[2] = µheading
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_Section, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µsection = πTemp002
							// line 261: self._add_item(section.format_help, [])
							πF.SetLineno(261)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsection, "section"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µsection, ßformat_help, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_add_item, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 262: self._current_section = section
							πF.SetLineno(262)
							if πE = πg.CheckLocal(πF, µsection, "section"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsection); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_current_section, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßstart_section.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 264: def end_section(self):
					πF.SetLineno(264)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("end_section", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 265: self._current_section = self._current_section.parent
							πF.SetLineno(265)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_current_section, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_current_section, πTemp001); πE != nil {
								continue
							}
							// line 266: self._dedent()
							πF.SetLineno(266)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_dedent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßend_section.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 268: def add_text(self, text):
					πF.SetLineno(268)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("add_text", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µtext *πg.Object = πArgs[1]; _ = µtext
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(µtext != πTemp004).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(µtext != πTemp004).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 269: if text is not SUPPRESS and text is not None:
							πF.SetLineno(269)
						Label2:
							// line 270: self._add_item(self._format_text, [text])
							πF.SetLineno(270)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_format_text, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							πTemp006 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp006[0] = µtext
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_add_item, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_text.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 272: def add_usage(self, usage, actions, groups, prefix=None):
					πF.SetLineno(272)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "usage", Def: nil}
					πTemp002[2] = πg.Param{Name: "actions", Def: nil}
					πTemp002[3] = πg.Param{Name: "groups", Def: nil}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "prefix", Def: πTemp012}
					πTemp011 = πg.NewFunction(πg.NewCode("add_usage", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µusage *πg.Object = πArgs[1]; _ = µusage
						var µactions *πg.Object = πArgs[2]; _ = µactions
						var µgroups *πg.Object = πArgs[3]; _ = µgroups
						var µprefix *πg.Object = πArgs[4]; _ = µprefix
						var µargs *πg.Object = πg.UnboundLocal; _ = µargs
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µusage != πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 273: if usage is not SUPPRESS:
							πF.SetLineno(273)
						Label1:
							// line 274: args = usage, actions, groups, prefix
							πF.SetLineno(274)
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple4(µusage, µactions, µgroups, µprefix).ToObject()
							µargs = πTemp001
							// line 275: self._add_item(self._format_usage, args)
							πF.SetLineno(275)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_format_usage, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp004[1] = µargs
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_add_item, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_usage.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 277: def add_argument(self, action):
					πF.SetLineno(277)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("add_argument", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µget_invocation *πg.Object = πg.UnboundLocal; _ = µget_invocation
						var µinvocations *πg.Object = πg.UnboundLocal; _ = µinvocations
						var µsubaction *πg.Object = πg.UnboundLocal; _ = µsubaction
						var µinvocation_length *πg.Object = πg.UnboundLocal; _ = µinvocation_length
						var µaction_length *πg.Object = πg.UnboundLocal; _ = µaction_length
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []πg.Param
						_ = πTemp008
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3: goto Label3
							case 4: goto Label4
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßhelp, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 != πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 278: if action.help is not SUPPRESS:
							πF.SetLineno(278)
						Label1:
							// line 281: get_invocation = self._format_action_invocation
							πF.SetLineno(281)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_format_action_invocation, nil); πE != nil {
								continue
							}
							µget_invocation = πTemp001
							// line 282: invocations = [get_invocation(action)]
							πF.SetLineno(282)
							πTemp005 = make([]*πg.Object, 1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp006[0] = µaction
							if πE = πg.CheckLocal(πF, µget_invocation, "get_invocation"); πE != nil {
								continue
							}
							if πTemp001, πE = µget_invocation.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[0] = πTemp001
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							µinvocations = πTemp001
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp005[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_iter_indented_subactions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp004 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µsubaction = πTemp002
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(3)            
							// line 284: invocations.append(get_invocation(subaction))
							πF.SetLineno(284)
							πTemp005 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsubaction, "subaction"); πE != nil {
								continue
							}
							πTemp006[0] = µsubaction
							if πE = πg.CheckLocal(πF, µget_invocation, "get_invocation"); πE != nil {
								continue
							}
							if πTemp002, πE = µget_invocation.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[0] = πTemp002
							if πE = πg.CheckLocal(πF, µinvocations, "invocations"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µinvocations, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 287: invocation_length = max([len(s) for s in invocations])
							πF.SetLineno(287)
							πTemp005 = πF.MakeArgs(1)
							πTemp008 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µs *πg.Object = πg.UnboundLocal; _ = µs
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µinvocations, "invocations"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µinvocations); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µs = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 287: invocation_length = max([len(s) for s in invocations])
										πF.SetLineno(287)
										πTemp005 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µs, "s"); πE != nil {
											continue
										}
										πTemp005[0] = µs
										if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp003}, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßmax); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µinvocation_length = πTemp003
							// line 288: action_length = invocation_length + self._current_indent
							πF.SetLineno(288)
							if πE = πg.CheckLocal(πF, µinvocation_length, "invocation_length"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µinvocation_length, πTemp003); πE != nil {
								continue
							}
							µaction_length = πTemp001
							// line 289: self._action_max_length = max(self._action_max_length,
							πF.SetLineno(289)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_action_max_length, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πE = πg.CheckLocal(πF, µaction_length, "action_length"); πE != nil {
								continue
							}
							πTemp005[1] = µaction_length
							if πTemp001, πE = πg.ResolveGlobal(πF, ßmax); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_action_max_length, πTemp001); πE != nil {
								continue
							}
							// line 293: self._add_item(self._format_action, [action])
							πF.SetLineno(293)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_format_action, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							πTemp006 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp006[0] = µaction
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_add_item, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_argument.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 295: def add_arguments(self, actions):
					πF.SetLineno(295)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "actions", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("add_arguments", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µactions *πg.Object = πArgs[1]; _ = µactions
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µactions); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp002 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp003 = !isStop
							} else {
								πTemp003 = true
								µaction = πTemp004
							}
							if πE != nil || !πTemp003 {
								continue
							}
							πF.PushCheckpoint(1)            
							// line 297: self.add_argument(action)
							πF.SetLineno(297)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp005[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßadd_argument, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_arguments.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 302: def format_help(self):
					πF.SetLineno(302)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("format_help", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µhelp *πg.Object = πg.UnboundLocal; _ = µhelp
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 303: help = self._root_section.format_help()
							πF.SetLineno(303)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_root_section, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßformat_help, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µhelp = πTemp001
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µhelp); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 304: if help:
							πF.SetLineno(304)
						Label1:
							// line 305: help = self._long_break_matcher.sub('\n\n', help)
							πF.SetLineno(305)
							πTemp004 = πF.MakeArgs(2)
							πTemp004[0] = πg.NewStr("\n\n").ToObject()
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πTemp004[1] = µhelp
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_long_break_matcher, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsub, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µhelp = πTemp001
							// line 306: help = help.strip('\n') + '\n'
							πF.SetLineno(306)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("\n").ToObject()
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µhelp, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Add(πF, πTemp005, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							µhelp = πTemp001
							goto Label2
						Label2:
							// line 307: return help
							πF.SetLineno(307)
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πR = µhelp
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßformat_help.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 309: def _join_parts(self, part_strings):
					πF.SetLineno(309)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "part_strings", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("_join_parts", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µpart_strings *πg.Object = πArgs[1]; _ = µpart_strings
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 310: return ''.join([part
							πF.SetLineno(310)
							πTemp001 = πF.MakeArgs(1)
							πTemp004 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µpart *πg.Object = πg.UnboundLocal; _ = µpart
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 7: goto Label7
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µpart_strings, "part_strings"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µpart_strings); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µpart = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
											continue
										}
										πTemp004 = µpart
										if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
											continue
										}
										if !πTemp003 {
											goto Label4
										}
										if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
											continue
										}
										if πTemp006, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
											continue
										}
										πTemp005 = πg.GetBool(µpart != πTemp006).ToObject()
										πTemp004 = πTemp005
									Label4:
										if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
											continue
										}
										if πTemp003 {
											goto Label5
										}
										goto Label6
										// line 310: return ''.join([part
										πF.SetLineno(310)
									Label5:
										// line 310: return ''.join([part
										πF.SetLineno(310)
										if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
											continue
										}
										πF.PushCheckpoint(7)
										return µpart, nil
									Label7:
										πTemp004 = πSent
										goto Label6
									Label6:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp005
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_join_parts.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 314: def _format_usage(self, usage, actions, groups, prefix):
					πF.SetLineno(314)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "usage", Def: nil}
					πTemp002[2] = πg.Param{Name: "actions", Def: nil}
					πTemp002[3] = πg.Param{Name: "groups", Def: nil}
					πTemp002[4] = πg.Param{Name: "prefix", Def: nil}
					πTemp016 = πg.NewFunction(πg.NewCode("_format_usage", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µusage *πg.Object = πArgs[1]; _ = µusage
						var µactions *πg.Object = πArgs[2]; _ = µactions
						var µgroups *πg.Object = πArgs[3]; _ = µgroups
						var µprefix *πg.Object = πArgs[4]; _ = µprefix
						var µprog *πg.Object = πg.UnboundLocal; _ = µprog
						var µoptionals *πg.Object = πg.UnboundLocal; _ = µoptionals
						var µpositionals *πg.Object = πg.UnboundLocal; _ = µpositionals
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var µformat *πg.Object = πg.UnboundLocal; _ = µformat
						var µaction_usage *πg.Object = πg.UnboundLocal; _ = µaction_usage
						var µtext_width *πg.Object = πg.UnboundLocal; _ = µtext_width
						var µpart_regexp *πg.Object = πg.UnboundLocal; _ = µpart_regexp
						var µopt_usage *πg.Object = πg.UnboundLocal; _ = µopt_usage
						var µpos_usage *πg.Object = πg.UnboundLocal; _ = µpos_usage
						var µopt_parts *πg.Object = πg.UnboundLocal; _ = µopt_parts
						var µpos_parts *πg.Object = πg.UnboundLocal; _ = µpos_parts
						var µget_lines *πg.Object = πg.UnboundLocal; _ = µget_lines
						var µindent *πg.Object = πg.UnboundLocal; _ = µindent
						var µlines *πg.Object = πg.UnboundLocal; _ = µlines
						var µparts *πg.Object = πg.UnboundLocal; _ = µparts
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 []πg.Param
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 *πg.Object
						_ = πTemp011
						var πTemp012 *πg.Object
						_ = πTemp012
						var πTemp013 *πg.Object
						_ = πTemp013
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8: goto Label8
							case 9: goto Label9
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µprefix == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 315: if prefix is None:
							πF.SetLineno(315)
						Label1:
							// line 316: prefix = _('usage: ')
							πF.SetLineno(316)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("usage: ").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µprefix = πTemp002
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µusage != πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µusage == πTemp005).ToObject()
							πTemp001 = πTemp002
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µactions); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp002
						Label4:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µusage == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label6
							}
							goto Label7
							// line 319: if usage is not None:
							πF.SetLineno(319)
						Label3:
							// line 321: usage = usage.replace('%(prog)s', str(self._prog))
							πF.SetLineno(321)
							πTemp004 = πF.MakeArgs(2)
							πTemp004[0] = πg.NewStr("%(prog)s").ToObject()
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_prog, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp004[1] = πTemp002
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µusage, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µusage = πTemp002
							goto Label7
							// line 324: elif usage is None and not actions:
							πF.SetLineno(324)
						Label5:
							// line 326: usage = self._prog
							πF.SetLineno(326)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_prog, nil); πE != nil {
								continue
							}
							µusage = πTemp001
							goto Label7
							// line 329: elif usage is None:
							πF.SetLineno(329)
						Label6:
							// line 331: prog = self._prog
							πF.SetLineno(331)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_prog, nil); πE != nil {
								continue
							}
							µprog = πTemp001
							// line 334: optionals = []
							πF.SetLineno(334)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							µoptionals = πTemp001
							// line 335: positionals = []
							πF.SetLineno(335)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							µpositionals = πTemp001
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µactions); πE != nil {
								continue
							}
							πF.PushCheckpoint(9)
							πTemp003 = false
						Label8:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label10
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µaction = πTemp002
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(8)            
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label11
							}
							goto Label12
							// line 337: if action.option_strings:
							πF.SetLineno(337)
						Label11:
							// line 338: optionals.append(action)
							πF.SetLineno(338)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp004[0] = µaction
							if πE = πg.CheckLocal(πF, µoptionals, "optionals"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoptionals, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label13
						Label12:
							// line 340: positionals.append(action)
							πF.SetLineno(340)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp004[0] = µaction
							if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpositionals, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label13
						Label13:
							continue
						Label9:
							if πE != nil || πR != nil {
								continue
							}
						Label10:
							// line 343: format = self._format_actions_usage
							πF.SetLineno(343)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_format_actions_usage, nil); πE != nil {
								continue
							}
							µformat = πTemp001
							// line 344: action_usage = format(optionals + positionals, groups)
							πF.SetLineno(344)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µoptionals, "optionals"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µoptionals, µpositionals); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							πTemp004[1] = µgroups
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							if πTemp001, πE = µformat.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µaction_usage = πTemp001
							// line 345: usage = ' '.join([s for s in [prog, action_usage] if s])
							πF.SetLineno(345)
							πTemp004 = πF.MakeArgs(1)
							πTemp008 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µs *πg.Object = πg.UnboundLocal; _ = µs
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 []*πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 bool
								_ = πTemp005
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										πTemp002 = make([]*πg.Object, 2)
										if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
											continue
										}
										πTemp002[0] = µprog
										if πE = πg.CheckLocal(πF, µaction_usage, "action_usage"); πE != nil {
											continue
										}
										πTemp002[1] = µaction_usage
										πTemp003 = πg.NewList(πTemp002...).ToObject()
										if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp004 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp004 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp005 = !isStop
										} else {
											πTemp005 = true
											µs = πTemp003
										}
										if πE != nil || !πTemp005 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µs, "s"); πE != nil {
											continue
										}
										if πTemp005, πE = πg.IsTrue(πF, µs); πE != nil {
											continue
										}
										if πTemp005 {
											goto Label4
										}
										goto Label5
										// line 345: usage = ' '.join([s for s in [prog, action_usage] if s])
										πF.SetLineno(345)
									Label4:
										// line 345: usage = ' '.join([s for s in [prog, action_usage] if s])
										πF.SetLineno(345)
										if πE = πg.CheckLocal(πF, µs, "s"); πE != nil {
											continue
										}
										πF.PushCheckpoint(6)
										return µs, nil
									Label6:
										πTemp003 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µusage = πTemp005
							// line 348: text_width = self._width - self._current_indent
							πF.SetLineno(348)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ß_width, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp005, πTemp009); πE != nil {
								continue
							}
							µtext_width = πTemp001
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							πTemp004[0] = µprefix
							if πTemp009, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp009.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							πTemp004[0] = µusage
							if πTemp009, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp011, πE = πTemp009.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp005, πE = πg.Add(πF, πTemp010, πTemp011); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtext_width, "text_width"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GT(πF, πTemp005, µtext_width); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label14
							}
							goto Label15
							// line 349: if len(prefix) + len(usage) > text_width:
							πF.SetLineno(349)
						Label14:
							// line 352: part_regexp = r'\(.*?\)+|\[.*?\]+|\S+'
							πF.SetLineno(352)
							µpart_regexp = πg.NewStr("\\(.*?\\)+|\\[.*?\\]+|\\S+").ToObject()
							// line 353: opt_usage = format(optionals, groups)
							πF.SetLineno(353)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µoptionals, "optionals"); πE != nil {
								continue
							}
							πTemp004[0] = µoptionals
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							πTemp004[1] = µgroups
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							if πTemp001, πE = µformat.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µopt_usage = πTemp001
							// line 354: pos_usage = format(positionals, groups)
							πF.SetLineno(354)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
								continue
							}
							πTemp004[0] = µpositionals
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							πTemp004[1] = µgroups
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							if πTemp001, πE = µformat.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µpos_usage = πTemp001
							// line 355: opt_parts = _re.findall(part_regexp, opt_usage)
							πF.SetLineno(355)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpart_regexp, "part_regexp"); πE != nil {
								continue
							}
							πTemp004[0] = µpart_regexp
							if πE = πg.CheckLocal(πF, µopt_usage, "opt_usage"); πE != nil {
								continue
							}
							πTemp004[1] = µopt_usage
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp001, ßfindall, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µopt_parts = πTemp001
							// line 356: pos_parts = _re.findall(part_regexp, pos_usage)
							πF.SetLineno(356)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpart_regexp, "part_regexp"); πE != nil {
								continue
							}
							πTemp004[0] = µpart_regexp
							if πE = πg.CheckLocal(πF, µpos_usage, "pos_usage"); πE != nil {
								continue
							}
							πTemp004[1] = µpos_usage
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp001, ßfindall, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µpos_parts = πTemp001
							// line 357: assert ' '.join(opt_parts) == opt_usage
							πF.SetLineno(357)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µopt_parts, "opt_parts"); πE != nil {
								continue
							}
							πTemp004[0] = µopt_parts
							if πTemp005, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µopt_usage, "opt_usage"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp009, µopt_usage); πE != nil {
								continue
							}
							if πE = πg.Assert(πF, πTemp001, nil); πE != nil {
								continue
							}
							// line 358: assert ' '.join(pos_parts) == pos_usage
							πF.SetLineno(358)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos_parts, "pos_parts"); πE != nil {
								continue
							}
							πTemp004[0] = µpos_parts
							if πTemp005, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µpos_usage, "pos_usage"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp009, µpos_usage); πE != nil {
								continue
							}
							if πE = πg.Assert(πF, πTemp001, nil); πE != nil {
								continue
							}
							// line 361: def get_lines(parts, indent, prefix=None):
							πF.SetLineno(361)
							πTemp008 = make([]πg.Param, 3)
							πTemp008[0] = πg.Param{Name: "parts", Def: nil}
							πTemp008[1] = πg.Param{Name: "indent", Def: nil}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp008[2] = πg.Param{Name: "prefix", Def: πTemp005}
							πTemp001 = πg.NewFunction(πg.NewCode("get_lines", "build/src/__python__/argparse.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µparts *πg.Object = πArgs[0]; _ = µparts
								var µindent *πg.Object = πArgs[1]; _ = µindent
								var µprefix *πg.Object = πArgs[2]; _ = µprefix
								var µlines *πg.Object = πg.UnboundLocal; _ = µlines
								var µline *πg.Object = πg.UnboundLocal; _ = µline
								var µline_len *πg.Object = πg.UnboundLocal; _ = µline_len
								var µpart *πg.Object = πg.UnboundLocal; _ = µpart
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πTemp006 bool
								_ = πTemp006
								var πTemp007 *πg.Object
								_ = πTemp007
								var πTemp008 *πg.Object
								_ = πTemp008
								var πTemp009 *πg.Object
								_ = πTemp009
								var πTemp010 *πg.Object
								_ = πTemp010
								var πTemp011 []*πg.Object
								_ = πTemp011
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									case 4: goto Label4
									case 5: goto Label5
									default: panic("unexpected function state")
									}
									// line 362: lines = []
									πF.SetLineno(362)
									πTemp001 = make([]*πg.Object, 0)
									πTemp002 = πg.NewList(πTemp001...).ToObject()
									µlines = πTemp002
									// line 363: line = []
									πF.SetLineno(363)
									πTemp001 = make([]*πg.Object, 0)
									πTemp002 = πg.NewList(πTemp001...).ToObject()
									µline = πTemp002
									if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
										continue
									}
									πTemp002 = πg.GetBool(µprefix != πTemp003).ToObject()
									if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label1
									}
									goto Label2
									// line 364: if prefix is not None:
									πF.SetLineno(364)
								Label1:
									// line 365: line_len = len(prefix) - 1
									πF.SetLineno(365)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
										continue
									}
									πTemp001[0] = µprefix
									if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									if πTemp002, πE = πg.Sub(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									µline_len = πTemp002
									goto Label3
								Label2:
									// line 367: line_len = len(indent) - 1
									πF.SetLineno(367)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
										continue
									}
									πTemp001[0] = µindent
									if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									if πTemp002, πE = πg.Sub(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									µline_len = πTemp002
									goto Label3
								Label3:
									if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.Iter(πF, µparts); πE != nil {
										continue
									}
									πF.PushCheckpoint(5)
									πTemp004 = false
								Label4:
									if πE != nil || πR != nil {
										continue
									}
									if πTemp004 {
										πF.PopCheckpoint()
										goto Label6
									}
									if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
										isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
										if exc != nil {
											πE = exc
										} else if isStop {
											πE = nil
											πF.RestoreExc(nil, nil)
										}
										πTemp006 = !isStop
									} else {
										πTemp006 = true
										µpart = πTemp003
									}
									if πE != nil || !πTemp006 {
										continue
									}
									πF.PushCheckpoint(4)            
									if πE = πg.CheckLocal(πF, µline_len, "line_len"); πE != nil {
										continue
									}
									if πTemp008, πE = πg.Add(πF, µline_len, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
										continue
									}
									πTemp001[0] = µpart
									if πTemp009, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
										continue
									}
									if πTemp010, πE = πTemp009.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									if πTemp007, πE = πg.Add(πF, πTemp008, πTemp010); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µtext_width, "text_width"); πE != nil {
										continue
									}
									if πTemp005, πE = πg.GT(πF, πTemp007, µtext_width); πE != nil {
										continue
									}
									πTemp003 = πTemp005
									if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
										continue
									}
									if !πTemp006 {
										goto Label7
									}
									if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
										continue
									}
									πTemp003 = µline
								Label7:
									if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
										continue
									}
									if πTemp006 {
										goto Label8
									}
									goto Label9
									// line 369: if line_len + 1 + len(part) > text_width and line:
									πF.SetLineno(369)
								Label8:
									// line 370: lines.append(indent + ' '.join(line))
									πF.SetLineno(370)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
										continue
									}
									πTemp011 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
										continue
									}
									πTemp011[0] = µline
									if πTemp005, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
										continue
									}
									if πTemp007, πE = πTemp005.Call(πF, πTemp011, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp011)
									if πTemp003, πE = πg.Add(πF, µindent, πTemp007); πE != nil {
										continue
									}
									πTemp001[0] = πTemp003
									if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, µlines, ßappend, nil); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									// line 371: line = []
									πF.SetLineno(371)
									πTemp001 = make([]*πg.Object, 0)
									πTemp003 = πg.NewList(πTemp001...).ToObject()
									µline = πTemp003
									// line 372: line_len = len(indent) - 1
									πF.SetLineno(372)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
										continue
									}
									πTemp001[0] = µindent
									if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
										continue
									}
									if πTemp007, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									if πTemp003, πE = πg.Sub(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									µline_len = πTemp003
									goto Label9
								Label9:
									// line 373: line.append(part)
									πF.SetLineno(373)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
										continue
									}
									πTemp001[0] = µpart
									if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, µline, ßappend, nil); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									// line 374: line_len += len(part) + 1
									πF.SetLineno(374)
									if πE = πg.CheckLocal(πF, µline_len, "line_len"); πE != nil {
										continue
									}
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
										continue
									}
									πTemp001[0] = µpart
									if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
										continue
									}
									if πTemp007, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									if πTemp003, πE = πg.Add(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									if πTemp005, πE = πg.IAdd(πF, µline_len, πTemp003); πE != nil {
										continue
									}
									µline_len = πTemp005
									continue
								Label5:
									if πE != nil || πR != nil {
										continue
									}
								Label6:
									if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.IsTrue(πF, µline); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label10
									}
									goto Label11
									// line 375: if line:
									πF.SetLineno(375)
								Label10:
									// line 376: lines.append(indent + ' '.join(line))
									πF.SetLineno(376)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
										continue
									}
									πTemp011 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
										continue
									}
									πTemp011[0] = µline
									if πTemp003, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp003.Call(πF, πTemp011, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp011)
									if πTemp002, πE = πg.Add(πF, µindent, πTemp005); πE != nil {
										continue
									}
									πTemp001[0] = πTemp002
									if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µlines, ßappend, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									goto Label11
								Label11:
									if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
										continue
									}
									πTemp002 = πg.GetBool(µprefix != πTemp003).ToObject()
									if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label12
									}
									goto Label13
									// line 377: if prefix is not None:
									πF.SetLineno(377)
								Label12:
									// line 378: lines[0] = lines[0][len(indent):]
									πF.SetLineno(378)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
										continue
									}
									πTemp001[0] = µindent
									if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πTemp005, πg.None, πg.None}, nil); πE != nil {
										continue
									}
									πTemp005 = πg.NewInt(0).ToObject()
									if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
										continue
									}
									if πTemp007, πE = πg.GetItem(πF, µlines, πTemp005); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetItem(πF, πTemp007, πTemp002); πE != nil {
										continue
									}
									if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
										continue
									}
									πTemp005 = πg.NewInt(0).ToObject()
									if πE = πg.SetItem(πF, µlines, πTemp005, πTemp002); πE != nil {
										continue
									}
									goto Label13
								Label13:
									// line 379: return lines
									πF.SetLineno(379)
									if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
										continue
									}
									πR = µlines
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µget_lines = πTemp001
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							πTemp004[0] = µprefix
							if πTemp010, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp011, πE = πTemp010.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							πTemp004[0] = µprog
							if πTemp010, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp012, πE = πTemp010.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp009, πE = πg.Add(πF, πTemp011, πTemp012); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtext_width, "text_width"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.Mul(πF, πg.NewFloat(0.75).ToObject(), µtext_width); πE != nil {
								continue
							}
							if πTemp005, πE = πg.LE(πF, πTemp009, πTemp010); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label16
							}
							goto Label17
							// line 382: if len(prefix) + len(prog) <= 0.75 * text_width:
							πF.SetLineno(382)
						Label16:
							// line 383: indent = ' ' * (len(prefix) + len(prog) + 1)
							πF.SetLineno(383)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							πTemp004[0] = µprefix
							if πTemp011, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp012, πE = πTemp011.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							πTemp004[0] = µprog
							if πTemp011, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp013, πE = πTemp011.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp010, πE = πg.Add(πF, πTemp012, πTemp013); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Add(πF, πTemp010, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), πTemp009); πE != nil {
								continue
							}
							µindent = πTemp005
							if πE = πg.CheckLocal(πF, µopt_parts, "opt_parts"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µopt_parts); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label19
							}
							if πE = πg.CheckLocal(πF, µpos_parts, "pos_parts"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µpos_parts); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label20
							}
							goto Label21
							// line 384: if opt_parts:
							πF.SetLineno(384)
						Label19:
							// line 385: lines = get_lines([prog] + opt_parts, indent, prefix)
							πF.SetLineno(385)
							πTemp004 = πF.MakeArgs(3)
							πTemp007 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							πTemp007[0] = µprog
							πTemp009 = πg.NewList(πTemp007...).ToObject()
							if πE = πg.CheckLocal(πF, µopt_parts, "opt_parts"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πTemp009, µopt_parts); πE != nil {
								continue
							}
							πTemp004[0] = πTemp005
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp004[1] = µindent
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							πTemp004[2] = µprefix
							if πE = πg.CheckLocal(πF, µget_lines, "get_lines"); πE != nil {
								continue
							}
							if πTemp005, πE = µget_lines.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µlines = πTemp005
							// line 387: lines += (get_lines(pos_parts, indent))
							πF.SetLineno(387)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos_parts, "pos_parts"); πE != nil {
								continue
							}
							πTemp004[0] = µpos_parts
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp004[1] = µindent
							if πE = πg.CheckLocal(πF, µget_lines, "get_lines"); πE != nil {
								continue
							}
							if πTemp005, πE = µget_lines.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp009, πE = πg.IAdd(πF, µlines, πTemp005); πE != nil {
								continue
							}
							µlines = πTemp009
							goto Label22
							// line 388: elif pos_parts:
							πF.SetLineno(388)
						Label20:
							// line 389: lines = get_lines([prog] + pos_parts, indent, prefix)
							πF.SetLineno(389)
							πTemp004 = πF.MakeArgs(3)
							πTemp007 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							πTemp007[0] = µprog
							πTemp009 = πg.NewList(πTemp007...).ToObject()
							if πE = πg.CheckLocal(πF, µpos_parts, "pos_parts"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πTemp009, µpos_parts); πE != nil {
								continue
							}
							πTemp004[0] = πTemp005
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp004[1] = µindent
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							πTemp004[2] = µprefix
							if πE = πg.CheckLocal(πF, µget_lines, "get_lines"); πE != nil {
								continue
							}
							if πTemp005, πE = µget_lines.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µlines = πTemp005
							goto Label22
						Label21:
							// line 391: lines = [prog]
							πF.SetLineno(391)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							πTemp004[0] = µprog
							πTemp005 = πg.NewList(πTemp004...).ToObject()
							µlines = πTemp005
							goto Label22
						Label22:
							goto Label18
						Label17:
							// line 395: indent = ' ' * len(prefix)
							πF.SetLineno(395)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							πTemp004[0] = µprefix
							if πTemp009, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp009.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp005, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), πTemp010); πE != nil {
								continue
							}
							µindent = πTemp005
							// line 396: parts = opt_parts + pos_parts
							πF.SetLineno(396)
							if πE = πg.CheckLocal(πF, µopt_parts, "opt_parts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos_parts, "pos_parts"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, µopt_parts, µpos_parts); πE != nil {
								continue
							}
							µparts = πTemp005
							// line 397: lines = get_lines(parts, indent)
							πF.SetLineno(397)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							πTemp004[0] = µparts
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp004[1] = µindent
							if πE = πg.CheckLocal(πF, µget_lines, "get_lines"); πE != nil {
								continue
							}
							if πTemp005, πE = µget_lines.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µlines = πTemp005
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp004[0] = µlines
							if πTemp009, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp009.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp005, πE = πg.GT(πF, πTemp010, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label23
							}
							goto Label24
							// line 398: if len(lines) > 1:
							πF.SetLineno(398)
						Label23:
							// line 399: lines = []
							πF.SetLineno(399)
							πTemp004 = make([]*πg.Object, 0)
							πTemp005 = πg.NewList(πTemp004...).ToObject()
							µlines = πTemp005
							// line 401: lines += (get_lines(opt_parts, indent))
							πF.SetLineno(401)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µopt_parts, "opt_parts"); πE != nil {
								continue
							}
							πTemp004[0] = µopt_parts
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp004[1] = µindent
							if πE = πg.CheckLocal(πF, µget_lines, "get_lines"); πE != nil {
								continue
							}
							if πTemp005, πE = µget_lines.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp009, πE = πg.IAdd(πF, µlines, πTemp005); πE != nil {
								continue
							}
							µlines = πTemp009
							// line 403: lines += (get_lines(pos_parts, indent))
							πF.SetLineno(403)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos_parts, "pos_parts"); πE != nil {
								continue
							}
							πTemp004[0] = µpos_parts
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp004[1] = µindent
							if πE = πg.CheckLocal(πF, µget_lines, "get_lines"); πE != nil {
								continue
							}
							if πTemp005, πE = µget_lines.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp009, πE = πg.IAdd(πF, µlines, πTemp005); πE != nil {
								continue
							}
							µlines = πTemp009
							goto Label24
						Label24:
							// line 404: lines = [prog] + lines
							πF.SetLineno(404)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							πTemp004[0] = µprog
							πTemp009 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πTemp009, µlines); πE != nil {
								continue
							}
							µlines = πTemp005
							goto Label18
						Label18:
							// line 407: usage = '\n'.join(lines)
							πF.SetLineno(407)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp004[0] = µlines
							if πTemp005, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µusage = πTemp009
							goto Label15
						Label15:
							goto Label7
						Label7:
							// line 410: return '%s%s\n\n' % (prefix, usage)
							πF.SetLineno(410)
							if πE = πg.CheckLocal(πF, µprefix, "prefix"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							πTemp009 = πg.NewTuple2(µprefix, µusage).ToObject()
							if πTemp005, πE = πg.Mod(πF, πg.NewStr("%s%s\n\n").ToObject(), πTemp009); πE != nil {
								continue
							}
							πR = πTemp005
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_format_usage.ToObject(), πTemp016); πE != nil {
						continue
					}
					// line 412: def _format_actions_usage(self, actions, groups):
					πF.SetLineno(412)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "actions", Def: nil}
					πTemp002[2] = πg.Param{Name: "groups", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("_format_actions_usage", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µactions *πg.Object = πArgs[1]; _ = µactions
						var µgroups *πg.Object = πArgs[2]; _ = µgroups
						var µgroup_actions *πg.Object = πg.UnboundLocal; _ = µgroup_actions
						var µinserts *πg.Object = πg.UnboundLocal; _ = µinserts
						var µgroup *πg.Object = πg.UnboundLocal; _ = µgroup
						var µstart *πg.Object = πg.UnboundLocal; _ = µstart
						var µi *πg.Object = πg.UnboundLocal; _ = µi
						var µend *πg.Object = πg.UnboundLocal; _ = µend
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var µparts *πg.Object = πg.UnboundLocal; _ = µparts
						var µpart *πg.Object = πg.UnboundLocal; _ = µpart
						var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
						var µdefault *πg.Object = πg.UnboundLocal; _ = µdefault
						var µargs_string *πg.Object = πg.UnboundLocal; _ = µargs_string
						var µtext *πg.Object = πg.UnboundLocal; _ = µtext
						var µopen_bracket *πg.Object = πg.UnboundLocal; _ = µopen_bracket
						var µclose *πg.Object = πg.UnboundLocal; _ = µclose
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Dict
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πTemp011 *πg.Object
						_ = πTemp011
						var πTemp012 *πg.Object
						_ = πTemp012
						var πTemp013 *πg.Object
						_ = πTemp013
						var πTemp014 *πg.BaseException
						_ = πTemp014
						var πTemp015 *πg.Traceback
						_ = πTemp015
						var πTemp016 πg.KWArgs
						_ = πTemp016
						var πTemp017 []πg.Param
						_ = πTemp017
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 32: goto Label32
							case 1: goto Label1
							case 2: goto Label2
							case 5: goto Label5
							case 6: goto Label6
							case 7: goto Label7
							case 15: goto Label15
							case 16: goto Label16
							case 56: goto Label56
							case 57: goto Label57
							case 27: goto Label27
							case 28: goto Label28
							case 31: goto Label31
							default: panic("unexpected function state")
							}
							// line 414: group_actions = set()
							πF.SetLineno(414)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßset); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µgroup_actions = πTemp002
							// line 415: inserts = {}
							πF.SetLineno(415)
							πTemp003 = πg.NewDict()
							πTemp001 = πTemp003.ToObject()
							µinserts = πTemp001
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µgroups); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µgroup = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)            
							// line 417: try:
							πF.SetLineno(417)
							πF.PushCheckpoint(5)
							// line 419: start = None
							πF.SetLineno(419)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µstart = πTemp002
							πTemp006 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							πTemp007[0] = µactions
							if πTemp008, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[0] = πTemp009
							if πTemp008, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Iter(πF, πTemp009); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp005 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp008, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp010 = !isStop
							} else {
								πTemp010 = true
								µi = πTemp008
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(6)            
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp009 = µi
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetItem(πF, µactions, πTemp009); πE != nil {
								continue
							}
							πTemp009 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µgroup, ß_group_actions, nil); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetItem(πF, πTemp013, πTemp009); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Eq(πF, πTemp011, πTemp012); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							if πTemp010 {
								goto Label9
							}
							goto Label10
							// line 421: if actions[i] == group._group_actions[0]:
							πF.SetLineno(421)
						Label9:
							// line 422: start = i
							πF.SetLineno(422)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							µstart = µi
							// line 423: break
							πF.SetLineno(423)
							πTemp005 = true
							continue
							goto Label10
						Label10:
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µstart == πTemp008).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label11
							}
							goto Label12
							// line 424: if start is None:
							πF.SetLineno(424)
						Label11:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							// line 425: raise ValueError
							πF.SetLineno(425)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							goto Label12
						Label12:
							πF.PopCheckpoint()
							// line 429: end = start + len(group._group_actions)
							πF.SetLineno(429)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µgroup, ß_group_actions, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp008
							if πTemp008, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Add(πF, µstart, πTemp009); πE != nil {
								continue
							}
							µend = πTemp002
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend, "end"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.SliceType.Call(πF, πg.Args{µstart, µend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetItem(πF, µactions, πTemp008); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µgroup, ß_group_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp009, πTemp008); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label13
							}
							goto Label14
							// line 430: if actions[start:end] == group._group_actions:
							πF.SetLineno(430)
						Label13:
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µgroup, ß_group_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(16)
							πTemp005 = false
						Label15:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label17
							}
							if πTemp008, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp010 = !isStop
							} else {
								πTemp010 = true
								µaction = πTemp008
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(15)            
							// line 432: group_actions.add(action)
							πF.SetLineno(432)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp006[0] = µaction
							if πE = πg.CheckLocal(πF, µgroup_actions, "group_actions"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µgroup_actions, ßadd, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							continue
						Label16:
							if πE != nil || πR != nil {
								continue
							}
						Label17:
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µgroup, ßrequired, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label18
							}
							goto Label19
							// line 433: if not group.required:
							πF.SetLineno(433)
						Label18:
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µinserts, µstart); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label21
							}
							goto Label22
							// line 434: if start in inserts:
							πF.SetLineno(434)
						Label21:
							// line 435: inserts[start] += ' ['
							πF.SetLineno(435)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp002 = µstart
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µinserts, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp008, πg.NewStr(" [").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp009 = µstart
							if πE = πg.SetItem(πF, µinserts, πTemp009, πTemp002); πE != nil {
								continue
							}
							goto Label23
						Label22:
							// line 437: inserts[start] = '['
							πF.SetLineno(437)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("[").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp008 = µstart
							if πE = πg.SetItem(πF, µinserts, πTemp008, πTemp002); πE != nil {
								continue
							}
							goto Label23
						Label23:
							// line 438: inserts[end] = ']'
							πF.SetLineno(438)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("]").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend, "end"); πE != nil {
								continue
							}
							πTemp008 = µend
							if πE = πg.SetItem(πF, µinserts, πTemp008, πTemp002); πE != nil {
								continue
							}
							goto Label20
						Label19:
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µinserts, µstart); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label24
							}
							goto Label25
							// line 440: if start in inserts:
							πF.SetLineno(440)
						Label24:
							// line 441: inserts[start] += ' ('
							πF.SetLineno(441)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp002 = µstart
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µinserts, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp008, πg.NewStr(" (").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp009 = µstart
							if πE = πg.SetItem(πF, µinserts, πTemp009, πTemp002); πE != nil {
								continue
							}
							goto Label26
						Label25:
							// line 443: inserts[start] = '('
							πF.SetLineno(443)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("(").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp008 = µstart
							if πE = πg.SetItem(πF, µinserts, πTemp008, πTemp002); πE != nil {
								continue
							}
							goto Label26
						Label26:
							// line 444: inserts[end] = ')'
							πF.SetLineno(444)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr(")").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend, "end"); πE != nil {
								continue
							}
							πTemp008 = µend
							if πE = πg.SetItem(πF, µinserts, πTemp008, πTemp002); πE != nil {
								continue
							}
							goto Label20
						Label20:
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, µstart, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp006[0] = πTemp008
							if πE = πg.CheckLocal(πF, µend, "end"); πE != nil {
								continue
							}
							πTemp006[1] = µend
							if πTemp008, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Iter(πF, πTemp009); πE != nil {
								continue
							}
							πF.PushCheckpoint(28)
							πTemp005 = false
						Label27:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label29
							}
							if πTemp008, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp010 = !isStop
							} else {
								πTemp010 = true
								µi = πTemp008
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(27)            
							// line 446: inserts[i] = '|'
							πF.SetLineno(446)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("|").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp009 = µi
							if πE = πg.SetItem(πF, µinserts, πTemp009, πTemp008); πE != nil {
								continue
							}
							continue
						Label28:
							if πE != nil || πR != nil {
								continue
							}
						Label29:
							goto Label14
						Label14:
							goto Label4
						Label5:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp014, πTemp015 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsInstance(πF, πTemp014.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label30
							}
							πE = πF.Raise(πTemp014.ToObject(), nil, πTemp015.ToObject())
							continue
							// line 426: except ValueError:
							πF.SetLineno(426)
						Label30:
							// line 427: continue
							πF.SetLineno(427)
							continue
							πF.RestoreExc(nil, nil)
							goto Label4
						Label4:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 449: parts = []
							πF.SetLineno(449)
							πTemp006 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							µparts = πTemp001
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							πTemp006[0] = µactions
							if πTemp002, πE = πg.ResolveGlobal(πF, ßenumerate); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(32)
							πTemp004 = false
						Label31:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label33
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp008}, πg.TieTarget{Target: &πTemp009}}}, πTemp002); πE != nil {
									continue
								}
								µi = πTemp008
								µaction = πTemp009
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(31)            
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µaction, ßhelp, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp008 == πTemp009).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label34
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label35
							}
							goto Label36
							// line 454: if action.help is SUPPRESS:
							πF.SetLineno(454)
						Label34:
							// line 455: parts.append(None)
							πF.SetLineno(455)
							πTemp006 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp006[0] = µi
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µinserts, ßget, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Eq(πF, πTemp009, πg.NewStr("|").ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label38
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp006[0] = πTemp008
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µinserts, ßget, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Eq(πF, πTemp009, πg.NewStr("|").ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label39
							}
							goto Label40
							// line 456: if inserts.get(i) == '|':
							πF.SetLineno(456)
						Label38:
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µinserts, µi); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label41
							}
							goto Label42
							// line 458: if i in inserts:
							πF.SetLineno(458)
						Label41:
							// line 459: del inserts[i]
							πF.SetLineno(459)
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp002 = µi
							if πE = πg.DelItem(πF, µinserts, πTemp002); πE != nil {
								continue
							}
							goto Label42
						Label42:
							goto Label40
							// line 460: elif inserts.get(i + 1) == '|':
							πF.SetLineno(460)
						Label39:
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µinserts, πTemp008); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label43
							}
							goto Label44
							// line 462: if i + 1 in inserts:
							πF.SetLineno(462)
						Label43:
							// line 463: del inserts[i + 1]
							πF.SetLineno(463)
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp008
							if πE = πg.DelItem(πF, µinserts, πTemp002); πE != nil {
								continue
							}
							goto Label44
						Label44:
							goto Label40
						Label40:
							goto Label37
							// line 466: elif not action.option_strings:
							πF.SetLineno(466)
						Label35:
							// line 467: part = self._format_args(action, action.dest)
							πF.SetLineno(467)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp006[0] = µaction
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							πTemp006[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_format_args, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µpart = πTemp008
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup_actions, "group_actions"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µgroup_actions, µaction); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label45
							}
							goto Label46
							// line 470: if action in group_actions:
							πF.SetLineno(470)
						Label45:
							πTemp009 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetItem(πF, µpart, πTemp009); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Eq(πF, πTemp011, πg.NewStr("[").ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp008
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label47
							}
							if πTemp011, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp009 = πTemp011
							if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetItem(πF, µpart, πTemp009); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Eq(πF, πTemp011, πg.NewStr("]").ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp008
						Label47:
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label48
							}
							goto Label49
							// line 471: if part[0] == '[' and part[-1] == ']':
							πF.SetLineno(471)
						Label48:
							// line 472: part = part[1:-1]
							πF.SetLineno(472)
							if πTemp008, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πTemp008, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µpart, πTemp002); πE != nil {
								continue
							}
							µpart = πTemp008
							goto Label49
						Label49:
							goto Label46
						Label46:
							// line 475: parts.append(part)
							πF.SetLineno(475)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
								continue
							}
							πTemp006[0] = µpart
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							goto Label37
						Label36:
							// line 479: option_string = action.option_strings[0]
							πF.SetLineno(479)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, πTemp009, πTemp002); πE != nil {
								continue
							}
							µoption_string = πTemp008
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp008, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label50
							}
							goto Label51
							// line 483: if action.nargs == 0:
							πF.SetLineno(483)
						Label50:
							// line 484: part = '%s' % option_string
							πF.SetLineno(484)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s").ToObject(), µoption_string); πE != nil {
								continue
							}
							µpart = πTemp002
							goto Label52
						Label51:
							// line 489: default = action.dest.upper()
							πF.SetLineno(489)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp002, ßupper, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp008.Call(πF, nil, nil); πE != nil {
								continue
							}
							µdefault = πTemp002
							// line 490: args_string = self._format_args(action, default)
							πF.SetLineno(490)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp006[0] = µaction
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							πTemp006[1] = µdefault
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_format_args, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µargs_string = πTemp008
							// line 491: part = '%s %s' % (option_string, args_string)
							πF.SetLineno(491)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargs_string, "args_string"); πE != nil {
								continue
							}
							πTemp008 = πg.NewTuple2(µoption_string, µargs_string).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s %s").ToObject(), πTemp008); πE != nil {
								continue
							}
							µpart = πTemp002
							goto Label52
						Label52:
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, µaction, ßrequired, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IsTrue(πF, πTemp009); πE != nil {
								continue
							}
							πTemp008 = πg.GetBool(!πTemp010).ToObject()
							πTemp002 = πTemp008
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label53
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup_actions, "group_actions"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.Contains(πF, µgroup_actions, µaction); πE != nil {
								continue
							}
							πTemp008 = πg.GetBool(!πTemp010).ToObject()
							πTemp002 = πTemp008
						Label53:
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label54
							}
							goto Label55
							// line 494: if not action.required and action not in group_actions:
							πF.SetLineno(494)
						Label54:
							// line 495: part = '[%s]' % part
							πF.SetLineno(495)
							if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("[%s]").ToObject(), µpart); πE != nil {
								continue
							}
							µpart = πTemp002
							goto Label55
						Label55:
							// line 498: parts.append(part)
							πF.SetLineno(498)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
								continue
							}
							πTemp006[0] = µpart
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							goto Label37
						Label37:
							continue
						Label32:
							if πE != nil || πR != nil {
								continue
							}
						Label33:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							πTemp006[0] = µinserts
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp016 = πg.KWArgs{
								{"reverse", πTemp002},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsorted); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp002.Call(πF, πTemp006, πTemp016); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(57)
							πTemp004 = false
						Label56:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label58
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µi = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(56)            
							// line 502: parts[i:i] = [inserts[i]]
							πF.SetLineno(502)
							πTemp006 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp002 = µi
							if πE = πg.CheckLocal(πF, µinserts, "inserts"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µinserts, πTemp002); πE != nil {
								continue
							}
							πTemp006[0] = πTemp008
							πTemp002 = πg.NewList(πTemp006...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.SliceType.Call(πF, πg.Args{µi, µi, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.SetItem(πF, µparts, πTemp009, πTemp008); πE != nil {
								continue
							}
							continue
						Label57:
							if πE != nil || πR != nil {
								continue
							}
						Label58:
							// line 505: text = ' '.join([item for item in parts if item is not None])
							πF.SetLineno(505)
							πTemp006 = πF.MakeArgs(1)
							πTemp017 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp017, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µitem *πg.Object = πg.UnboundLocal; _ = µitem
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µparts); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µitem = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µitem, "item"); πE != nil {
											continue
										}
										if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
											continue
										}
										πTemp004 = πg.GetBool(µitem != πTemp005).ToObject()
										if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
											continue
										}
										if πTemp003 {
											goto Label4
										}
										goto Label5
										// line 505: text = ' '.join([item for item in parts if item is not None])
										πF.SetLineno(505)
									Label4:
										// line 505: text = ' '.join([item for item in parts if item is not None])
										πF.SetLineno(505)
										if πE = πg.CheckLocal(πF, µitem, "item"); πE != nil {
											continue
										}
										πF.PushCheckpoint(6)
										return µitem, nil
									Label6:
										πTemp004 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp008, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp008}, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µtext = πTemp008
							// line 508: open_bracket = r'[\[(]'
							πF.SetLineno(508)
							µopen_bracket = πg.NewStr("[\\[(]").ToObject()
							// line 509: close = r'[\])]'
							πF.SetLineno(509)
							µclose = πg.NewStr("[\\])]").ToObject()
							// line 511: text = text.replace('[ ', '[').replace('( ', '(')
							πF.SetLineno(511)
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr("( ").ToObject()
							πTemp006[1] = πg.NewStr("(").ToObject()
							πTemp007 = πF.MakeArgs(2)
							πTemp007[0] = πg.NewStr("[ ").ToObject()
							πTemp007[1] = πg.NewStr("[").ToObject()
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtext, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.GetAttr(πF, πTemp008, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µtext = πTemp008
							// line 513: text = text.replace(' ]', ']').replace(' )', ')')
							πF.SetLineno(513)
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr(" )").ToObject()
							πTemp006[1] = πg.NewStr(")").ToObject()
							πTemp007 = πF.MakeArgs(2)
							πTemp007[0] = πg.NewStr(" ]").ToObject()
							πTemp007[1] = πg.NewStr("]").ToObject()
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtext, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.GetAttr(πF, πTemp008, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µtext = πTemp008
							// line 514: text = _re.sub(r'%s *%s' % (open_bracket, close), r'', text)
							πF.SetLineno(514)
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µopen_bracket, "open_bracket"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µclose, "close"); πE != nil {
								continue
							}
							πTemp008 = πg.NewTuple2(µopen_bracket, µclose).ToObject()
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("%s *%s").ToObject(), πTemp008); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							πTemp006[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp006[2] = µtext
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp001, ßsub, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp008.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µtext = πTemp001
							// line 516: text = _re.sub(r'\(([^|]*)\)', lambda x: x.group(1), text)
							πF.SetLineno(516)
							πTemp006 = πF.MakeArgs(3)
							πTemp006[0] = πg.NewStr("\\(([^|]*)\\)").ToObject()
							πTemp017 = make([]πg.Param, 1)
							πTemp017[0] = πg.Param{Name: "x", Def: nil}
							πTemp001 = πg.NewFunction(πg.NewCode("<lambda>", "build/src/__python__/argparse.py", πTemp017, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µx *πg.Object = πArgs[0]; _ = µx
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default: panic("unexpected function state")
									}
									// line 516: text = _re.sub(r'\(([^|]*)\)', lambda x: x.group(1), text)
									πF.SetLineno(516)
									πTemp001 = πF.MakeArgs(1)
									πTemp001[0] = πg.NewInt(1).ToObject()
									if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µx, ßgroup, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πR = πTemp003
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp006[1] = πTemp001
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp006[2] = µtext
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp001, ßsub, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp008.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µtext = πTemp001
							// line 517: text = text.strip()
							πF.SetLineno(517)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtext, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtext = πTemp008
							// line 520: return text
							πF.SetLineno(520)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πR = µtext
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_format_actions_usage.ToObject(), πTemp017); πE != nil {
						continue
					}
					// line 522: def _format_text(self, text):
					πF.SetLineno(522)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp018 = πg.NewFunction(πg.NewCode("_format_text", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µtext *πg.Object = πArgs[1]; _ = µtext
						var µtext_width *πg.Object = πg.UnboundLocal; _ = µtext_width
						var µindent *πg.Object = πg.UnboundLocal; _ = µindent
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, µtext, πg.NewStr("%(prog)s").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 523: if '%(prog)s' in text:
							πF.SetLineno(523)
						Label1:
							// line 525: text = text.replace('%(prog)s', self._prog)
							πF.SetLineno(525)
							πTemp003 = πF.MakeArgs(2)
							πTemp003[0] = πg.NewStr("%(prog)s").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_prog, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtext, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtext = πTemp004
							goto Label2
						Label2:
							// line 526: text_width = max(self._width - self._current_indent, 11)
							πF.SetLineno(526)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_width, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							πTemp003[1] = πg.NewInt(11).ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßmax); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtext_width = πTemp004
							// line 527: indent = ' ' * self._current_indent
							πF.SetLineno(527)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), πTemp004); πE != nil {
								continue
							}
							µindent = πTemp001
							// line 528: return self._fill_text(text, text_width, indent) + '\n\n'
							πF.SetLineno(528)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[0] = µtext
							if πE = πg.CheckLocal(πF, µtext_width, "text_width"); πE != nil {
								continue
							}
							πTemp003[1] = µtext_width
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp003[2] = µindent
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_fill_text, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Add(πF, πTemp005, πg.NewStr("\n\n").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_format_text.ToObject(), πTemp018); πE != nil {
						continue
					}
					// line 530: def _format_action(self, action):
					πF.SetLineno(530)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp019 = πg.NewFunction(πg.NewCode("_format_action", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µhelp_position *πg.Object = πg.UnboundLocal; _ = µhelp_position
						var µhelp_width *πg.Object = πg.UnboundLocal; _ = µhelp_width
						var µaction_width *πg.Object = πg.UnboundLocal; _ = µaction_width
						var µaction_header *πg.Object = πg.UnboundLocal; _ = µaction_header
						var µtup *πg.Object = πg.UnboundLocal; _ = µtup
						var µindent_first *πg.Object = πg.UnboundLocal; _ = µindent_first
						var µparts *πg.Object = πg.UnboundLocal; _ = µparts
						var µhelp_text *πg.Object = πg.UnboundLocal; _ = µhelp_text
						var µhelp_lines *πg.Object = πg.UnboundLocal; _ = µhelp_lines
						var µline *πg.Object = πg.UnboundLocal; _ = µline
						var µsubaction *πg.Object = πg.UnboundLocal; _ = µsubaction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πTemp011 []*πg.Object
						_ = πTemp011
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8: goto Label8
							case 9: goto Label9
							case 11: goto Label11
							case 12: goto Label12
							default: panic("unexpected function state")
							}
							// line 532: help_position = min(self._action_max_length + 2,
							πF.SetLineno(532)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_action_max_length, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_max_help_position, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßmin); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µhelp_position = πTemp003
							// line 534: help_width = max(self._width - help_position, 11)
							πF.SetLineno(534)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_width, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp_position, "help_position"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Sub(πF, πTemp003, µhelp_position); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							πTemp001[1] = πg.NewInt(11).ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßmax); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µhelp_width = πTemp003
							// line 535: action_width = help_position - self._current_indent - 2
							πF.SetLineno(535)
							if πE = πg.CheckLocal(πF, µhelp_position, "help_position"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Sub(πF, µhelp_position, πTemp004); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Sub(πF, πTemp003, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							µaction_width = πTemp002
							// line 536: action_header = self._format_action_invocation(action)
							πF.SetLineno(536)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_format_action_invocation, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µaction_header = πTemp003
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßhelp, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							πTemp001[0] = µaction_header
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µaction_width, "action_width"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.LE(πF, πTemp004, µaction_width); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label2
							}
							goto Label3
							// line 539: if not action.help:
							πF.SetLineno(539)
						Label1:
							// line 540: tup = self._current_indent, '', action_header
							πF.SetLineno(540)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple3(πTemp003, ß.ToObject(), µaction_header).ToObject()
							µtup = πTemp002
							// line 542: action_header = ' ' * self._current_indent + action_header + '\n'
							πF.SetLineno(542)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, µaction_header); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							µaction_header = πTemp002
							goto Label4
							// line 545: elif len(action_header) <= action_width:
							πF.SetLineno(545)
						Label2:
							// line 546: tup = self._current_indent, '', action_width, action_header
							πF.SetLineno(546)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_width, "action_width"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple4(πTemp003, ß.ToObject(), µaction_width, µaction_header).ToObject()
							µtup = πTemp002
							// line 548: action_header = ' ' * self._current_indent + (action_header + ' ' * action_width)[:action_width] + '  '
							πF.SetLineno(548)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_width, "action_width"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µaction_width, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_width, "action_width"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), µaction_width); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, µaction_header, πTemp009); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, πTemp008, πTemp006); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, πTemp007); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("  ").ToObject()); πE != nil {
								continue
							}
							µaction_header = πTemp002
							// line 549: indent_first = 0
							πF.SetLineno(549)
							µindent_first = πg.NewInt(0).ToObject()
							goto Label4
						Label3:
							// line 553: tup = self._current_indent, '', action_header
							πF.SetLineno(553)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple3(πTemp003, ß.ToObject(), µaction_header).ToObject()
							µtup = πTemp002
							// line 555: action_header = ' ' * self._current_indent + action_header + '\n'
							πF.SetLineno(555)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_current_indent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, µaction_header); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							µaction_header = πTemp002
							// line 556: indent_first = help_position
							πF.SetLineno(556)
							if πE = πg.CheckLocal(πF, µhelp_position, "help_position"); πE != nil {
								continue
							}
							µindent_first = µhelp_position
							goto Label4
						Label4:
							// line 559: parts = [action_header]
							πF.SetLineno(559)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							πTemp001[0] = µaction_header
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µparts = πTemp002
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßhelp, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\n").ToObject()
							if πE = πg.CheckLocal(πF, µaction_header, "action_header"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction_header, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							goto Label7
							// line 562: if action.help:
							πF.SetLineno(562)
						Label5:
							// line 563: help_text = self._expand_help(action)
							πF.SetLineno(563)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_expand_help, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µhelp_text = πTemp003
							// line 564: help_lines = self._split_lines(help_text, help_width)
							πF.SetLineno(564)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µhelp_text, "help_text"); πE != nil {
								continue
							}
							πTemp001[0] = µhelp_text
							if πE = πg.CheckLocal(πF, µhelp_width, "help_width"); πE != nil {
								continue
							}
							πTemp001[1] = µhelp_width
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_split_lines, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µhelp_lines = πTemp003
							// line 566: parts.append(' ' * indent_first + help_lines[0] + '\n')
							πF.SetLineno(566)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindent_first, "indent_first"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), µindent_first); πE != nil {
								continue
							}
							πTemp006 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µhelp_lines, "help_lines"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µhelp_lines, πTemp006); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, πTemp007); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp_lines, "help_lines"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µhelp_lines, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(9)
							πTemp005 = false
						Label8:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label10
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp010 = !isStop
							} else {
								πTemp010 = true
								µline = πTemp003
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(8)            
							// line 569: parts.append(' ' * help_position + line + '\n')
							πF.SetLineno(569)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µhelp_position, "help_position"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Mul(πF, πg.NewStr(" ").ToObject(), µhelp_position); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp006, µline); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µparts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label9:
							if πE != nil || πR != nil {
								continue
							}
						Label10:
							goto Label7
							// line 572: elif not action_header.endswith('\n'):
							πF.SetLineno(572)
						Label6:
							// line 573: parts.append('\n')
							πF.SetLineno(573)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\n").ToObject()
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label7
						Label7:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_iter_indented_subactions, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(12)
							πTemp005 = false
						Label11:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label13
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp010 = !isStop
							} else {
								πTemp010 = true
								µsubaction = πTemp003
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(11)            
							// line 577: parts.append(self._format_action(subaction))
							πF.SetLineno(577)
							πTemp001 = πF.MakeArgs(1)
							πTemp011 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsubaction, "subaction"); πE != nil {
								continue
							}
							πTemp011[0] = µsubaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_format_action, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µparts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label12:
							if πE != nil || πR != nil {
								continue
							}
						Label13:
							// line 580: return self._join_parts(parts)
							πF.SetLineno(580)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							πTemp001[0] = µparts
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_join_parts, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_format_action.ToObject(), πTemp019); πE != nil {
						continue
					}
					// line 582: def _format_action_invocation(self, action):
					πF.SetLineno(582)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp020 = πg.NewFunction(πg.NewCode("_format_action_invocation", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µmetavar *πg.Object = πg.UnboundLocal; _ = µmetavar
						var µparts *πg.Object = πg.UnboundLocal; _ = µparts
						var µdefault *πg.Object = πg.UnboundLocal; _ = µdefault
						var µargs_string *πg.Object = πg.UnboundLocal; _ = µargs_string
						var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8: goto Label8
							case 7: goto Label7
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 583: if not action.option_strings:
							πF.SetLineno(583)
						Label1:
							// line 584: metavar, = self._metavar_formatter(action, action.dest)(1)
							πF.SetLineno(584)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewInt(1).ToObject()
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp005[0] = µaction
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_metavar_formatter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µmetavar = πTemp001
							// line 585: return metavar
							πF.SetLineno(585)
							if πE = πg.CheckLocal(πF, µmetavar, "metavar"); πE != nil {
								continue
							}
							πR = µmetavar
							continue
							goto Label3
						Label2:
							// line 588: parts = []
							πF.SetLineno(588)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							µparts = πTemp001
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp002, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 592: if action.nargs == 0:
							πF.SetLineno(592)
						Label4:
							// line 594: parts += (action.option_strings)
							πF.SetLineno(594)
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µparts, πTemp001); πE != nil {
								continue
							}
							µparts = πTemp002
							goto Label6
						Label5:
							// line 599: default = action.dest.upper()
							πF.SetLineno(599)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßupper, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µdefault = πTemp001
							// line 600: args_string = self._format_args(action, default)
							πF.SetLineno(600)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp004[0] = µaction
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							πTemp004[1] = µdefault
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_format_args, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µargs_string = πTemp002
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(8)
							πTemp003 = false
						Label7:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label9
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µoption_string = πTemp002
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(7)            
							// line 602: parts.append('%s %s' % (option_string, args_string))
							πF.SetLineno(602)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargs_string, "args_string"); πE != nil {
								continue
							}
							πTemp007 = πg.NewTuple2(µoption_string, µargs_string).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s %s").ToObject(), πTemp007); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							continue
						Label8:
							if πE != nil || πR != nil {
								continue
							}
						Label9:
							goto Label6
						Label6:
							// line 604: return ', '.join(parts)
							πF.SetLineno(604)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							πTemp004[0] = µparts
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr(", ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πR = πTemp002
							continue
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_format_action_invocation.ToObject(), πTemp020); πE != nil {
						continue
					}
					// line 606: def _metavar_formatter(self, action, default_metavar):
					πF.SetLineno(606)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp002[2] = πg.Param{Name: "default_metavar", Def: nil}
					πTemp021 = πg.NewFunction(πg.NewCode("_metavar_formatter", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µdefault_metavar *πg.Object = πArgs[2]; _ = µdefault_metavar
						var µresult *πg.Object = πg.UnboundLocal; _ = µresult
						var µchoice_strs *πg.Object = πg.UnboundLocal; _ = µchoice_strs
						var µformat *πg.Object = πg.UnboundLocal; _ = µformat
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []πg.Param
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßmetavar, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 != πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßchoices, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 != πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 607: if action.metavar is not None:
							πF.SetLineno(607)
						Label1:
							// line 608: result = action.metavar
							πF.SetLineno(608)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßmetavar, nil); πE != nil {
								continue
							}
							µresult = πTemp001
							goto Label4
							// line 609: elif action.choices is not None:
							πF.SetLineno(609)
						Label2:
							// line 610: choice_strs = [str(choice) for choice in action.choices]
							πF.SetLineno(610)
							πTemp005 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µchoice *πg.Object = πg.UnboundLocal; _ = µchoice
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µaction, ßchoices, nil); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp003 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp003 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp004 = !isStop
										} else {
											πTemp004 = true
											µchoice = πTemp002
										}
										if πE != nil || !πTemp004 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 610: choice_strs = [str(choice) for choice in action.choices]
										πF.SetLineno(610)
										πTemp005 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µchoice, "choice"); πE != nil {
											continue
										}
										πTemp005[0] = µchoice
										if πTemp002, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp002 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp003}, nil); πE != nil {
								continue
							}
							µchoice_strs = πTemp001
							// line 612: result = '{%s}' % ','.join(sorted(choice_strs))
							πF.SetLineno(612)
							πTemp006 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µchoice_strs, "choice_strs"); πE != nil {
								continue
							}
							πTemp007[0] = µchoice_strs
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsorted); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[0] = πTemp008
							if πTemp003, πE = πg.GetAttr(πF, πg.NewStr(",").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("{%s}").ToObject(), πTemp008); πE != nil {
								continue
							}
							µresult = πTemp001
							goto Label4
						Label3:
							// line 614: result = default_metavar
							πF.SetLineno(614)
							if πE = πg.CheckLocal(πF, µdefault_metavar, "default_metavar"); πE != nil {
								continue
							}
							µresult = µdefault_metavar
							goto Label4
						Label4:
							// line 616: def format(tuple_size):
							πF.SetLineno(616)
							πTemp005 = make([]πg.Param, 1)
							πTemp005[0] = πg.Param{Name: "tuple_size", Def: nil}
							πTemp001 = πg.NewFunction(πg.NewCode("format", "build/src/__python__/argparse.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µtuple_size *πg.Object = πArgs[0]; _ = µtuple_size
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default: panic("unexpected function state")
									}
									πTemp001 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
										continue
									}
									πTemp001[0] = µresult
									if πTemp002, πE = πg.ResolveGlobal(πF, ßtuple); πE != nil {
										continue
									}
									πTemp001[1] = πTemp002
									if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label1
									}
									goto Label2
									// line 617: if isinstance(result, tuple):
									πF.SetLineno(617)
								Label1:
									// line 618: return result
									πF.SetLineno(618)
									if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
										continue
									}
									πR = µresult
									continue
									goto Label3
								Label2:
									// line 620: return (result, ) * tuple_size
									πF.SetLineno(620)
									if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
										continue
									}
									πTemp003 = πg.NewTuple1(µresult).ToObject()
									if πE = πg.CheckLocal(πF, µtuple_size, "tuple_size"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.Mul(πF, πTemp003, µtuple_size); πE != nil {
										continue
									}
									πR = πTemp002
									continue
									goto Label3
								Label3:
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µformat = πTemp001
							// line 621: return format
							πF.SetLineno(621)
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πR = µformat
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_metavar_formatter.ToObject(), πTemp021); πE != nil {
						continue
					}
					// line 623: def _format_args(self, action, default_metavar):
					πF.SetLineno(623)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp002[2] = πg.Param{Name: "default_metavar", Def: nil}
					πTemp022 = πg.NewFunction(πg.NewCode("_format_args", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µdefault_metavar *πg.Object = πArgs[2]; _ = µdefault_metavar
						var µget_metavar *πg.Object = πg.UnboundLocal; _ = µget_metavar
						var µresult *πg.Object = πg.UnboundLocal; _ = µresult
						var µformats *πg.Object = πg.UnboundLocal; _ = µformats
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []πg.Param
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 624: get_metavar = self._metavar_formatter(action, default_metavar)
							πF.SetLineno(624)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µdefault_metavar, "default_metavar"); πE != nil {
								continue
							}
							πTemp001[1] = µdefault_metavar
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_metavar_formatter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µget_metavar = πTemp003
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp003 == πTemp004).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label2
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßZERO_OR_MORE); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßONE_OR_MORE); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßREMAINDER); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßPARSER); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							goto Label7
							// line 625: if action.nargs is None:
							πF.SetLineno(625)
						Label1:
							// line 626: result = '%s' % get_metavar(1)
							πF.SetLineno(626)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µget_metavar, "get_metavar"); πE != nil {
								continue
							}
							if πTemp003, πE = µget_metavar.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s").ToObject(), πTemp003); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label8
							// line 627: elif action.nargs == OPTIONAL:
							πF.SetLineno(627)
						Label2:
							// line 628: result = '[%s]' % get_metavar(1)
							πF.SetLineno(628)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µget_metavar, "get_metavar"); πE != nil {
								continue
							}
							if πTemp003, πE = µget_metavar.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("[%s]").ToObject(), πTemp003); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label8
							// line 629: elif action.nargs == ZERO_OR_MORE:
							πF.SetLineno(629)
						Label3:
							// line 630: result = '[%s [%s ...]]' % get_metavar(2)
							πF.SetLineno(630)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µget_metavar, "get_metavar"); πE != nil {
								continue
							}
							if πTemp003, πE = µget_metavar.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("[%s [%s ...]]").ToObject(), πTemp003); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label8
							// line 631: elif action.nargs == ONE_OR_MORE:
							πF.SetLineno(631)
						Label4:
							// line 632: result = '%s [%s ...]' % get_metavar(2)
							πF.SetLineno(632)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µget_metavar, "get_metavar"); πE != nil {
								continue
							}
							if πTemp003, πE = µget_metavar.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s [%s ...]").ToObject(), πTemp003); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label8
							// line 633: elif action.nargs == REMAINDER:
							πF.SetLineno(633)
						Label5:
							// line 634: result = '...'
							πF.SetLineno(634)
							µresult = πg.NewStr("...").ToObject()
							goto Label8
							// line 635: elif action.nargs == PARSER:
							πF.SetLineno(635)
						Label6:
							// line 636: result = '%s ...' % get_metavar(1)
							πF.SetLineno(636)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µget_metavar, "get_metavar"); πE != nil {
								continue
							}
							if πTemp003, πE = µget_metavar.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s ...").ToObject(), πTemp003); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label8
						Label7:
							// line 638: formats = ['%s' for _ in range(action.nargs)]
							πF.SetLineno(638)
							πTemp006 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µ_ *πg.Object = πg.UnboundLocal; _ = µ_
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 []*πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 bool
								_ = πTemp005
								var πTemp006 bool
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										πTemp002 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										if πTemp003, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
											continue
										}
										πTemp002[0] = πTemp003
										if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
											continue
										}
										if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp002)
										if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp005 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp005 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp006 = !isStop
										} else {
											πTemp006 = true
											µ_ = πTemp003
										}
										if πE != nil || !πTemp006 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 638: formats = ['%s' for _ in range(action.nargs)]
										πF.SetLineno(638)
										πF.PushCheckpoint(4)
										return πg.NewStr("%s").ToObject(), nil
									Label4:
										πTemp003 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							µformats = πTemp002
							// line 639: result = ' '.join(formats) % get_metavar(action.nargs)
							πF.SetLineno(639)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µformats, "formats"); πE != nil {
								continue
							}
							πTemp001[0] = µformats
							if πTemp004, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µget_metavar, "get_metavar"); πE != nil {
								continue
							}
							if πTemp004, πE = µget_metavar.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Mod(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label8
						Label8:
							// line 640: return result
							πF.SetLineno(640)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_format_args.ToObject(), πTemp022); πE != nil {
						continue
					}
					// line 642: def _expand_help(self, action):
					πF.SetLineno(642)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp023 = πg.NewFunction(πg.NewCode("_expand_help", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µparams *πg.Object = πg.UnboundLocal; _ = µparams
						var µname *πg.Object = πg.UnboundLocal; _ = µname
						var µchoices_str *πg.Object = πg.UnboundLocal; _ = µchoices_str
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 πg.KWArgs
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 []πg.Param
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πTemp011 []*πg.Object
						_ = πTemp011
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							case 6: goto Label6
							case 7: goto Label7
							default: panic("unexpected function state")
							}
							// line 644: params = dict(action.__dict__, prog=self._prog)
							πF.SetLineno(644)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ß__dict__, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_prog, nil); πE != nil {
								continue
							}
							πTemp003 = πg.KWArgs{
								{"prog", πTemp002},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µparams = πTemp004
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							πTemp001[0] = µparams
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µname = πTemp004
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)            
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp005 = µname
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µparams, πTemp005); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp008 == πTemp005).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 646: if params[name] is SUPPRESS:
							πF.SetLineno(646)
						Label4:
							// line 647: del params[name]
							πF.SetLineno(647)
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp004 = µname
							if πE = πg.DelItem(πF, µparams, πTemp004); πE != nil {
								continue
							}
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							πTemp001[0] = µparams
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp006 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µname = πTemp004
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(6)            
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp004 = µname
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µparams, πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp005
							πTemp001[1] = ß__name__.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp007, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label9
							}
							goto Label10
							// line 649: if hasattr(params[name], '__name__'):
							πF.SetLineno(649)
						Label9:
							// line 650: params[name] = params[name].__name__
							πF.SetLineno(650)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp004 = µname
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µparams, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ß__name__, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp008 = µname
							if πE = πg.SetItem(πF, µparams, πTemp008, πTemp005); πE != nil {
								continue
							}
							goto Label10
						Label10:
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßchoices.ToObject()
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µparams, ßget, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005 != πTemp004).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label11
							}
							goto Label12
							// line 651: if params.get('choices') is not None:
							πF.SetLineno(651)
						Label11:
							// line 652: choices_str = ', '.join([str(c) for c in params['choices']])
							πF.SetLineno(652)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = make([]πg.Param, 0)
							πTemp004 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp009, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µc *πg.Object = πg.UnboundLocal; _ = µc
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 bool
								_ = πTemp005
								var πTemp006 []*πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										πTemp002 = ßchoices.ToObject()
										if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
											continue
										}
										if πTemp003, πE = πg.GetItem(πF, µparams, πTemp002); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp004 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp004 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp005 = !isStop
										} else {
											πTemp005 = true
											µc = πTemp002
										}
										if πE != nil || !πTemp005 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 652: choices_str = ', '.join([str(c) for c in params['choices']])
										πF.SetLineno(652)
										πTemp006 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µc, "c"); πE != nil {
											continue
										}
										πTemp006[0] = µc
										if πTemp002, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
											continue
										}
										if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp006)
										πF.PushCheckpoint(4)
										return πTemp003, nil
									Label4:
										πTemp002 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr(", ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µchoices_str = πTemp005
							// line 653: params['choices'] = choices_str
							πF.SetLineno(653)
							if πE = πg.CheckLocal(πF, µchoices_str, "choices_str"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µchoices_str); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
								continue
							}
							πTemp005 = ßchoices.ToObject()
							if πE = πg.SetItem(πF, µparams, πTemp005, πTemp002); πE != nil {
								continue
							}
							goto Label12
						Label12:
							// line 655: return MAPPING_SUB(lambda x: str(params.get(
							πF.SetLineno(655)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("%%").ToObject()
							πTemp001[1] = πg.NewStr("%").ToObject()
							πTemp010 = πF.MakeArgs(2)
							πTemp009 = make([]πg.Param, 1)
							πTemp009[0] = πg.Param{Name: "x", Def: nil}
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "build/src/__python__/argparse.py", πTemp009, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µx *πg.Object = πArgs[0]; _ = µx
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 []*πg.Object
								_ = πTemp002
								var πTemp003 []*πg.Object
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default: panic("unexpected function state")
									}
									// line 655: return MAPPING_SUB(lambda x: str(params.get(
									πF.SetLineno(655)
									πTemp001 = πF.MakeArgs(1)
									πTemp002 = πF.MakeArgs(2)
									πTemp003 = πF.MakeArgs(1)
									πTemp003[0] = πg.NewInt(1).ToObject()
									if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.GetAttr(πF, µx, ßgroup, nil); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp003)
									πTemp002[0] = πTemp005
									πTemp003 = πF.MakeArgs(1)
									πTemp003[0] = πg.NewInt(0).ToObject()
									if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.GetAttr(πF, µx, ßgroup, nil); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp003)
									πTemp002[1] = πTemp005
									if πE = πg.CheckLocal(πF, µparams, "params"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.GetAttr(πF, µparams, ßget, nil); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp002)
									πTemp001[0] = πTemp005
									if πTemp004, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
										continue
									}
									if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πR = πTemp005
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp010[0] = πTemp002
							πTemp011 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp011[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_get_help_string, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp010[1] = πTemp005
							if πTemp002, πE = πg.ResolveGlobal(πF, ßMAPPING_SUB); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							if πTemp002, πE = πg.GetAttr(πF, πTemp005, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp005
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_expand_help.ToObject(), πTemp023); πE != nil {
						continue
					}
					// line 659: def _iter_indented_subactions(self, action):
					πF.SetLineno(659)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp024 = πg.NewFunction(πg.NewCode("_iter_indented_subactions", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µget_subactions *πg.Object = πg.UnboundLocal; _ = µget_subactions
						var µsubaction *πg.Object = πg.UnboundLocal; _ = µsubaction
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 2: goto Label2
								case 3: goto Label3
								case 4: goto Label4
								case 6: goto Label6
								default: panic("unexpected function state")
								}
								// line 660: try:
								πF.SetLineno(660)
								πF.PushCheckpoint(2)
								// line 661: get_subactions = action._get_subactions
								πF.SetLineno(661)
								if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µaction, ß_get_subactions, nil); πE != nil {
									continue
								}
								µget_subactions = πTemp001
								πF.PopCheckpoint()
								// line 665: self._indent()
								πF.SetLineno(665)
								if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µself, ß_indent, nil); πE != nil {
									continue
								}
								if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
									continue
								}
								if πE = πg.CheckLocal(πF, µget_subactions, "get_subactions"); πE != nil {
									continue
								}
								if πTemp002, πE = µget_subactions.Call(πF, nil, nil); πE != nil {
									continue
								}
								if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
									continue
								}
								πF.PushCheckpoint(4)
								πTemp003 = false
							Label3:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp003 {
									πF.PopCheckpoint()
									goto Label5
								}
								if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp004 = !isStop
								} else {
									πTemp004 = true
									µsubaction = πTemp002
								}
								if πE != nil || !πTemp004 {
									continue
								}
								πF.PushCheckpoint(3)            
								// line 667: yield subaction
								πF.SetLineno(667)
								if πE = πg.CheckLocal(πF, µsubaction, "subaction"); πE != nil {
									continue
								}
								πF.PushCheckpoint(6)
								return µsubaction, nil
							Label6:
								πTemp002 = πSent
								continue
							Label4:
								if πE != nil || πR != nil {
									continue
								}
							Label5:
								// line 668: self._dedent()
								πF.SetLineno(668)
								if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µself, ß_dedent, nil); πE != nil {
									continue
								}
								if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
									continue
								}
								goto Label1
							Label2:
								if πE == nil {
								  continue
								}
								πE = nil
								πTemp005, πTemp006 = πF.ExcInfo()
								if πTemp001, πE = πg.ResolveGlobal(πF, ßAttributeError); πE != nil {
									continue
								}
								if πTemp003, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp001); πE != nil {
									continue
								}
								if πTemp003 {
									goto Label7
								}
								πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
								continue
								// line 662: except AttributeError:
								πF.SetLineno(662)
							Label7:
								// line 663: pass
								πF.SetLineno(663)
								πF.RestoreExc(nil, nil)
								goto Label1
							Label1:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_iter_indented_subactions.ToObject(), πTemp024); πE != nil {
						continue
					}
					// line 670: def _split_lines(self, text, width):
					πF.SetLineno(670)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp002[2] = πg.Param{Name: "width", Def: nil}
					πTemp025 = πg.NewFunction(πg.NewCode("_split_lines", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µtext *πg.Object = πArgs[1]; _ = µtext
						var µwidth *πg.Object = πArgs[2]; _ = µwidth
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 671: text = self._whitespace_matcher.sub(' ', text).strip()
							πF.SetLineno(671)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr(" ").ToObject()
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[1] = µtext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_whitespace_matcher, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsub, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtext = πTemp002
							// line 672: return _textwrap.wrap(text, width)
							πF.SetLineno(672)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							πTemp001[1] = µwidth
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_textwrap); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßwrap, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_split_lines.ToObject(), πTemp025); πE != nil {
						continue
					}
					// line 674: def _fill_text(self, text, width, indent):
					πF.SetLineno(674)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp002[2] = πg.Param{Name: "width", Def: nil}
					πTemp002[3] = πg.Param{Name: "indent", Def: nil}
					πTemp026 = πg.NewFunction(πg.NewCode("_fill_text", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µtext *πg.Object = πArgs[1]; _ = µtext
						var µwidth *πg.Object = πArgs[2]; _ = µwidth
						var µindent *πg.Object = πArgs[3]; _ = µindent
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 675: text = self._whitespace_matcher.sub(' ', text).strip()
							πF.SetLineno(675)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr(" ").ToObject()
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[1] = µtext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_whitespace_matcher, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsub, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtext = πTemp002
							// line 676: return _textwrap.fill(text, width, initial_indent=indent,
							πF.SetLineno(676)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							πTemp001[1] = µwidth
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"initial_indent", µindent},
								{"subsequent_indent", µindent},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_textwrap); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfill, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_fill_text.ToObject(), πTemp026); πE != nil {
						continue
					}
					// line 679: def _get_help_string(self, action):
					πF.SetLineno(679)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp027 = πg.NewFunction(πg.NewCode("_get_help_string", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 680: return action.help
							πF.SetLineno(680)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßhelp, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_help_string.ToObject(), πTemp027); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp010, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp010 == nil {
				πTemp010 = πg.TypeType.ToObject()
			}
			if πTemp011, πE = πTemp010.Call(πF, []*πg.Object{πg.NewStr("HelpFormatter").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßHelpFormatter.ToObject(), πTemp011); πE != nil {
				continue
			}
			// line 683: class RawDescriptionHelpFormatter(HelpFormatter):
			πF.SetLineno(683)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp011, πE = πg.ResolveGlobal(πF, ßHelpFormatter); πE != nil {
				continue
			}
			πTemp001[0] = πTemp011
			πTemp008 = πg.NewDict()
			if πTemp009, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp009); πE != nil {
				continue
			}
			_, πE = πg.NewCode("RawDescriptionHelpFormatter", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 684: """Help message formatter which retains any formatting in descriptions.
					πF.SetLineno(684)
					// line 690: def _fill_text(self, text, width, indent):
					πF.SetLineno(690)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp002[2] = πg.Param{Name: "width", Def: nil}
					πTemp002[3] = πg.Param{Name: "indent", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("_fill_text", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µtext *πg.Object = πArgs[1]; _ = µtext
						var µwidth *πg.Object = πArgs[2]; _ = µwidth
						var µindent *πg.Object = πArgs[3]; _ = µindent
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 691: return ''.join([indent + line for line in text.splitlines(True)])
							πF.SetLineno(691)
							πTemp001 = πF.MakeArgs(1)
							πTemp004 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µline *πg.Object = πg.UnboundLocal; _ = µline
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 []*πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 bool
								_ = πTemp005
								var πTemp006 bool
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										πTemp002 = πF.MakeArgs(1)
										if πTemp003, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
											continue
										}
										πTemp002[0] = πTemp003
										if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
											continue
										}
										if πTemp003, πE = πg.GetAttr(πF, µtext, ßsplitlines, nil); πE != nil {
											continue
										}
										if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp002)
										if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp005 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp005 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp006 = !isStop
										} else {
											πTemp006 = true
											µline = πTemp003
										}
										if πE != nil || !πTemp006 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 691: return ''.join([indent + line for line in text.splitlines(True)])
										πF.SetLineno(691)
										if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
											continue
										}
										if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
											continue
										}
										if πTemp003, πE = πg.Add(πF, µindent, µline); πE != nil {
											continue
										}
										πF.PushCheckpoint(4)
										return πTemp003, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp005
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_fill_text.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp010, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp010 == nil {
				πTemp010 = πg.TypeType.ToObject()
			}
			if πTemp011, πE = πTemp010.Call(πF, []*πg.Object{πg.NewStr("RawDescriptionHelpFormatter").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßRawDescriptionHelpFormatter.ToObject(), πTemp011); πE != nil {
				continue
			}
			// line 694: class RawTextHelpFormatter(RawDescriptionHelpFormatter):
			πF.SetLineno(694)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp011, πE = πg.ResolveGlobal(πF, ßRawDescriptionHelpFormatter); πE != nil {
				continue
			}
			πTemp001[0] = πTemp011
			πTemp008 = πg.NewDict()
			if πTemp009, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp009); πE != nil {
				continue
			}
			_, πE = πg.NewCode("RawTextHelpFormatter", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 695: """Help message formatter which retains formatting of all help text.
					πF.SetLineno(695)
					// line 701: def _split_lines(self, text, width):
					πF.SetLineno(701)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp002[2] = πg.Param{Name: "width", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("_split_lines", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µtext *πg.Object = πArgs[1]; _ = µtext
						var µwidth *πg.Object = πArgs[2]; _ = µwidth
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 702: return text.splitlines()
							πF.SetLineno(702)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtext, ßsplitlines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_split_lines.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp010, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp010 == nil {
				πTemp010 = πg.TypeType.ToObject()
			}
			if πTemp011, πE = πTemp010.Call(πF, []*πg.Object{πg.NewStr("RawTextHelpFormatter").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßRawTextHelpFormatter.ToObject(), πTemp011); πE != nil {
				continue
			}
			// line 705: class ArgumentDefaultsHelpFormatter(HelpFormatter):
			πF.SetLineno(705)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp011, πE = πg.ResolveGlobal(πF, ßHelpFormatter); πE != nil {
				continue
			}
			πTemp001[0] = πTemp011
			πTemp008 = πg.NewDict()
			if πTemp009, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp009); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ArgumentDefaultsHelpFormatter", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 706: """Help message formatter which adds default values to argument help.
					πF.SetLineno(706)
					// line 712: def _get_help_string(self, action):
					πF.SetLineno(712)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("_get_help_string", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µhelp *πg.Object = πg.UnboundLocal; _ = µhelp
						var µdefaulting_nargs *πg.Object = πg.UnboundLocal; _ = µdefaulting_nargs
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 713: help = action.help
							πF.SetLineno(713)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßhelp, nil); πE != nil {
								continue
							}
							µhelp = πTemp001
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßhelp, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, πTemp002, πg.NewStr("%(default)").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 714: if '%(default)' not in action.help:
							πF.SetLineno(714)
						Label1:
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 != πTemp004).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 715: if action.default is not SUPPRESS:
							πF.SetLineno(715)
						Label3:
							// line 716: defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]
							πF.SetLineno(716)
							πTemp005 = make([]*πg.Object, 2)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßZERO_OR_MORE); πE != nil {
								continue
							}
							πTemp005[1] = πTemp001
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							µdefaulting_nargs = πTemp001
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefaulting_nargs, "defaulting_nargs"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, µdefaulting_nargs, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp006).ToObject()
							πTemp001 = πTemp002
						Label5:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label6
							}
							goto Label7
							// line 717: if action.option_strings or action.nargs in defaulting_nargs:
							πF.SetLineno(717)
						Label6:
							// line 718: help += ' (default: %(default)s)'
							πF.SetLineno(718)
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µhelp, πg.NewStr(" (default: %(default)s)").ToObject()); πE != nil {
								continue
							}
							µhelp = πTemp001
							goto Label7
						Label7:
							goto Label4
						Label4:
							goto Label2
						Label2:
							// line 719: return help
							πF.SetLineno(719)
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πR = µhelp
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_help_string.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp010, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp010 == nil {
				πTemp010 = πg.TypeType.ToObject()
			}
			if πTemp011, πE = πTemp010.Call(πF, []*πg.Object{πg.NewStr("ArgumentDefaultsHelpFormatter").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßArgumentDefaultsHelpFormatter.ToObject(), πTemp011); πE != nil {
				continue
			}
			// line 726: def _get_action_name(argument):
			πF.SetLineno(726)
			πTemp003 = make([]πg.Param, 1)
			πTemp003[0] = πg.Param{Name: "argument", Def: nil}
			πTemp009 = πg.NewFunction(πg.NewCode("_get_action_name", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µargument *πg.Object = πArgs[0]; _ = µargument
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 bool
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 []*πg.Object
				_ = πTemp007
				var πR *πg.Object; _ = πR
				var πE *πg.BaseException; _ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					if πE = πg.CheckLocal(πF, µargument, "argument"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					πTemp001 = πg.GetBool(µargument == πTemp002).ToObject()
					if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp003 {
						goto Label1
					}
					if πE = πg.CheckLocal(πF, µargument, "argument"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µargument, ßoption_strings, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp003 {
						goto Label2
					}
					if πE = πg.CheckLocal(πF, µargument, "argument"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µargument, ßmetavar, nil); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
						continue
					}
					πTemp004 = πg.NewTuple2(πTemp005, πTemp006).ToObject()
					if πTemp003, πE = πg.Contains(πF, πTemp004, πTemp002); πE != nil {
						continue
					}
					πTemp001 = πg.GetBool(!πTemp003).ToObject()
					if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp003 {
						goto Label3
					}
					if πE = πg.CheckLocal(πF, µargument, "argument"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µargument, ßdest, nil); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
						continue
					}
					πTemp004 = πg.NewTuple2(πTemp005, πTemp006).ToObject()
					if πTemp003, πE = πg.Contains(πF, πTemp004, πTemp002); πE != nil {
						continue
					}
					πTemp001 = πg.GetBool(!πTemp003).ToObject()
					if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp003 {
						goto Label4
					}
					goto Label5
					// line 727: if argument is None:
					πF.SetLineno(727)
				Label1:
					// line 728: return None
					πF.SetLineno(728)
					if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					πR = πTemp001
					continue
					goto Label6
					// line 729: elif argument.option_strings:
					πF.SetLineno(729)
				Label2:
					// line 730: return  '/'.join(argument.option_strings)
					πF.SetLineno(730)
					πTemp007 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µargument, "argument"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µargument, ßoption_strings, nil); πE != nil {
						continue
					}
					πTemp007[0] = πTemp001
					if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("/").ToObject(), ßjoin, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp007)
					πR = πTemp002
					continue
					goto Label6
					// line 731: elif argument.metavar not in (None, SUPPRESS):
					πF.SetLineno(731)
				Label3:
					// line 732: return argument.metavar
					πF.SetLineno(732)
					if πE = πg.CheckLocal(πF, µargument, "argument"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µargument, ßmetavar, nil); πE != nil {
						continue
					}
					πR = πTemp001
					continue
					goto Label6
					// line 733: elif argument.dest not in (None, SUPPRESS):
					πF.SetLineno(733)
				Label4:
					// line 734: return argument.dest
					πF.SetLineno(734)
					if πE = πg.CheckLocal(πF, µargument, "argument"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µargument, ßdest, nil); πE != nil {
						continue
					}
					πR = πTemp001
					continue
					goto Label6
				Label5:
					// line 736: return None
					πF.SetLineno(736)
					if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					πR = πTemp001
					continue
					goto Label6
				Label6:
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ß_get_action_name.ToObject(), πTemp009); πE != nil {
				continue
			}
			// line 739: class ArgumentError(Exception):
			πF.SetLineno(739)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßException); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ArgumentError", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 740: """An error from creating or using an argument (optional or positional).
					πF.SetLineno(740)
					// line 746: def __init__(self, argument, message):
					πF.SetLineno(746)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "argument", Def: nil}
					πTemp002[2] = πg.Param{Name: "message", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µargument *πg.Object = πArgs[1]; _ = µargument
						var µmessage *πg.Object = πArgs[2]; _ = µmessage
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 747: self.argument_name = _get_action_name(argument)
							πF.SetLineno(747)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargument, "argument"); πE != nil {
								continue
							}
							πTemp001[0] = µargument
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_get_action_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßargument_name, πTemp002); πE != nil {
								continue
							}
							// line 748: self.message = message
							πF.SetLineno(748)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µmessage); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmessage, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 750: def __str__(self):
					πF.SetLineno(750)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("__str__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µformat *πg.Object = πg.UnboundLocal; _ = µformat
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßargument_name, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 == πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 751: if self.argument_name is None:
							πF.SetLineno(751)
						Label1:
							// line 752: format = '%(message)s'
							πF.SetLineno(752)
							µformat = πg.NewStr("%(message)s").ToObject()
							goto Label3
						Label2:
							// line 754: format = 'argument %(argument_name)s: %(message)s'
							πF.SetLineno(754)
							µformat = πg.NewStr("argument %(argument_name)s: %(message)s").ToObject()
							goto Label3
						Label3:
							// line 757: return format.replace('%(message)s', str(self.message)).replace('%(argument_name)s', str(self.argument_name))
							πF.SetLineno(757)
							πTemp005 = πF.MakeArgs(2)
							πTemp005[0] = πg.NewStr("%(argument_name)s").ToObject()
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßargument_name, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[1] = πTemp002
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr("%(message)s").ToObject()
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmessage, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[1] = πTemp002
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformat, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("ArgumentError").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßArgumentError.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 760: class ArgumentTypeError(Exception):
			πF.SetLineno(760)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßException); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ArgumentTypeError", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 761: """An error from trying to convert a command line string to a type."""
					πF.SetLineno(761)
					// line 762: pass
					πF.SetLineno(762)
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("ArgumentTypeError").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßArgumentTypeError.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 769: class Action(_AttributeHolder):
			πF.SetLineno(769)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ß_AttributeHolder); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Action", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 770: """Information about how to convert command line strings to Python objects.
					πF.SetLineno(770)
					// line 820: def __init__(self,
					πF.SetLineno(820)
					πTemp002 = make([]πg.Param, 11)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "dest", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "nargs", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "const", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[6] = πg.Param{Name: "type", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[7] = πg.Param{Name: "choices", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[8] = πg.Param{Name: "required", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[9] = πg.Param{Name: "help", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[10] = πg.Param{Name: "metavar", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µnargs *πg.Object = πArgs[3]; _ = µnargs
						var µconst *πg.Object = πArgs[4]; _ = µconst
						var µdefault *πg.Object = πArgs[5]; _ = µdefault
						var µtype *πg.Object = πArgs[6]; _ = µtype
						var µchoices *πg.Object = πArgs[7]; _ = µchoices
						var µrequired *πg.Object = πArgs[8]; _ = µrequired
						var µhelp *πg.Object = πArgs[9]; _ = µhelp
						var µmetavar *πg.Object = πArgs[10]; _ = µmetavar
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 831: self.option_strings = option_strings
							πF.SetLineno(831)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µoption_strings); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoption_strings, πTemp001); πE != nil {
								continue
							}
							// line 832: self.dest = dest
							πF.SetLineno(832)
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µdest); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdest, πTemp001); πE != nil {
								continue
							}
							// line 833: self.nargs = nargs
							πF.SetLineno(833)
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µnargs); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßnargs, πTemp001); πE != nil {
								continue
							}
							// line 834: self.const = const
							πF.SetLineno(834)
							if πE = πg.CheckLocal(πF, µconst, "const"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µconst); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßconst, πTemp001); πE != nil {
								continue
							}
							// line 835: self.default = default
							πF.SetLineno(835)
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µdefault); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdefault, πTemp001); πE != nil {
								continue
							}
							// line 836: self.type = type
							πF.SetLineno(836)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µtype); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							// line 837: self.choices = choices
							πF.SetLineno(837)
							if πE = πg.CheckLocal(πF, µchoices, "choices"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µchoices); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßchoices, πTemp001); πE != nil {
								continue
							}
							// line 838: self.required = required
							πF.SetLineno(838)
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µrequired); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßrequired, πTemp001); πE != nil {
								continue
							}
							// line 839: self.help = help
							πF.SetLineno(839)
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µhelp); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhelp, πTemp001); πE != nil {
								continue
							}
							// line 840: self.metavar = metavar
							πF.SetLineno(840)
							if πE = πg.CheckLocal(πF, µmetavar, "metavar"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µmetavar); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmetavar, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 842: def _get_kwargs(self):
					πF.SetLineno(842)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("_get_kwargs", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µnames *πg.Object = πg.UnboundLocal; _ = µnames
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 843: names = [
							πF.SetLineno(843)
							πTemp001 = make([]*πg.Object, 9)
							πTemp001[0] = ßoption_strings.ToObject()
							πTemp001[1] = ßdest.ToObject()
							πTemp001[2] = ßnargs.ToObject()
							πTemp001[3] = ßconst.ToObject()
							πTemp001[4] = ßdefault.ToObject()
							πTemp001[5] = ßtype.ToObject()
							πTemp001[6] = ßchoices.ToObject()
							πTemp001[7] = ßhelp.ToObject()
							πTemp001[8] = ßmetavar.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µnames = πTemp002
							// line 854: return [(name, getattr(self, name)) for name in names]
							πF.SetLineno(854)
							πTemp004 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µname *πg.Object = πg.UnboundLocal; _ = µname
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πTemp007 *πg.Object
								_ = πTemp007
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µnames, "names"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µnames); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µname = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 854: return [(name, getattr(self, name)) for name in names]
										πF.SetLineno(854)
										if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
											continue
										}
										πTemp005 = πF.MakeArgs(2)
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										πTemp005[0] = µself
										if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
											continue
										}
										πTemp005[1] = µname
										if πTemp006, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
											continue
										}
										if πTemp007, πE = πTemp006.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πTemp004 = πg.NewTuple2(µname, πTemp007).ToObject()
										πF.PushCheckpoint(4)
										return πTemp004, nil
									Label4:
										πTemp006 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_kwargs.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 856: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(856)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "parser", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp002[3] = πg.Param{Name: "values", Def: nil}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "option_string", Def: πTemp005}
					πTemp004 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr(".__call__() not defined").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNotImplementedError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 857: raise NotImplementedError(_('.__call__() not defined'))
							πF.SetLineno(857)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("Action").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 860: class _StoreAction(Action):
			πF.SetLineno(860)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_StoreAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 862: def __init__(self,
					πF.SetLineno(862)
					πTemp002 = make([]πg.Param, 11)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "dest", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "nargs", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "const", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[6] = πg.Param{Name: "type", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[7] = πg.Param{Name: "choices", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[8] = πg.Param{Name: "required", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[9] = πg.Param{Name: "help", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[10] = πg.Param{Name: "metavar", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µnargs *πg.Object = πArgs[3]; _ = µnargs
						var µconst *πg.Object = πArgs[4]; _ = µconst
						var µdefault *πg.Object = πArgs[5]; _ = µdefault
						var µtype *πg.Object = πArgs[6]; _ = µtype
						var µchoices *πg.Object = πArgs[7]; _ = µchoices
						var µrequired *πg.Object = πArgs[8]; _ = µrequired
						var µhelp *πg.Object = πArgs[9]; _ = µhelp
						var µmetavar *πg.Object = πArgs[10]; _ = µmetavar
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µnargs, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 873: if nargs == 0:
							πF.SetLineno(873)
						Label1:
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("nargs for store actions must be > 0; if you have nothing to store, actions such as store true or store const may be more appropriate").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 874: raise ValueError('nargs for store actions must be > 0; if you '
							πF.SetLineno(874)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µconst, "const"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(µconst != πTemp005).ToObject()
							πTemp001 = πTemp004
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							if πTemp004, πE = πg.NE(πF, µnargs, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πTemp004
						Label3:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 877: if const is not None and nargs != OPTIONAL:
							πF.SetLineno(877)
						Label4:
							πTemp003 = πF.MakeArgs(1)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("nargs must be %r to supply const").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 878: raise ValueError('nargs must be %r to supply const' % OPTIONAL)
							πF.SetLineno(878)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
							goto Label5
						Label5:
							// line 879: super(_StoreAction, self).__init__(
							πF.SetLineno(879)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µconst, "const"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchoices, "choices"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmetavar, "metavar"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"nargs", µnargs},
								{"const", µconst},
								{"default", µdefault},
								{"type", µtype},
								{"choices", µchoices},
								{"required", µrequired},
								{"help", µhelp},
								{"metavar", µmetavar},
							}
							πTemp003 = πF.MakeArgs(2)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_StoreAction); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[1] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, nil, πTemp006); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 891: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(891)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "parser", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp002[3] = πg.Param{Name: "values", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "option_string", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 892: setattr(namespace, self.dest, values)
							πF.SetLineno(892)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp001[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µvalues, "values"); πE != nil {
								continue
							}
							πTemp001[2] = µvalues
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_StoreAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_StoreAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 895: class _StoreConstAction(Action):
			πF.SetLineno(895)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_StoreConstAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 897: def __init__(self,
					πF.SetLineno(897)
					πTemp002 = make([]πg.Param, 8)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "dest", Def: nil}
					πTemp002[3] = πg.Param{Name: "const", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "required", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[6] = πg.Param{Name: "help", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[7] = πg.Param{Name: "metavar", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µconst *πg.Object = πArgs[3]; _ = µconst
						var µdefault *πg.Object = πArgs[4]; _ = µdefault
						var µrequired *πg.Object = πArgs[5]; _ = µrequired
						var µhelp *πg.Object = πArgs[6]; _ = µhelp
						var µmetavar *πg.Object = πArgs[7]; _ = µmetavar
						var πTemp001 πg.KWArgs
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 905: super(_StoreConstAction, self).__init__(
							πF.SetLineno(905)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µconst, "const"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πTemp001 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"nargs", πg.NewInt(0).ToObject()},
								{"const", µconst},
								{"default", µdefault},
								{"required", µrequired},
								{"help", µhelp},
							}
							πTemp002 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_StoreConstAction); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[1] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 914: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(914)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "parser", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp002[3] = πg.Param{Name: "values", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "option_string", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 915: setattr(namespace, self.dest, self.const)
							πF.SetLineno(915)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp001[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßconst, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_StoreConstAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_StoreConstAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 918: class _StoreTrueAction(_StoreConstAction):
			πF.SetLineno(918)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ß_StoreConstAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_StoreTrueAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 920: def __init__(self,
					πF.SetLineno(920)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "dest", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "required", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "help", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µdefault *πg.Object = πArgs[3]; _ = µdefault
						var µrequired *πg.Object = πArgs[4]; _ = µrequired
						var µhelp *πg.Object = πArgs[5]; _ = µhelp
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 πg.KWArgs
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 926: super(_StoreTrueAction, self).__init__(
							πF.SetLineno(926)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πTemp002 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"const", πTemp001},
								{"default", µdefault},
								{"required", µrequired},
								{"help", µhelp},
							}
							πTemp003 = πF.MakeArgs(2)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_StoreTrueAction); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[1] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, nil, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_StoreTrueAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_StoreTrueAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 935: class _StoreFalseAction(_StoreConstAction):
			πF.SetLineno(935)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ß_StoreConstAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_StoreFalseAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 937: def __init__(self,
					πF.SetLineno(937)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "dest", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "required", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "help", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µdefault *πg.Object = πArgs[3]; _ = µdefault
						var µrequired *πg.Object = πArgs[4]; _ = µrequired
						var µhelp *πg.Object = πArgs[5]; _ = µhelp
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 πg.KWArgs
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 943: super(_StoreFalseAction, self).__init__(
							πF.SetLineno(943)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πTemp002 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"const", πTemp001},
								{"default", µdefault},
								{"required", µrequired},
								{"help", µhelp},
							}
							πTemp003 = πF.MakeArgs(2)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_StoreFalseAction); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[1] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, nil, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_StoreFalseAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_StoreFalseAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 952: class _AppendAction(Action):
			πF.SetLineno(952)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_AppendAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 954: def __init__(self,
					πF.SetLineno(954)
					πTemp002 = make([]πg.Param, 11)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "dest", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "nargs", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "const", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[6] = πg.Param{Name: "type", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[7] = πg.Param{Name: "choices", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[8] = πg.Param{Name: "required", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[9] = πg.Param{Name: "help", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[10] = πg.Param{Name: "metavar", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µnargs *πg.Object = πArgs[3]; _ = µnargs
						var µconst *πg.Object = πArgs[4]; _ = µconst
						var µdefault *πg.Object = πArgs[5]; _ = µdefault
						var µtype *πg.Object = πArgs[6]; _ = µtype
						var µchoices *πg.Object = πArgs[7]; _ = µchoices
						var µrequired *πg.Object = πArgs[8]; _ = µrequired
						var µhelp *πg.Object = πArgs[9]; _ = µhelp
						var µmetavar *πg.Object = πArgs[10]; _ = µmetavar
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µnargs, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 965: if nargs == 0:
							πF.SetLineno(965)
						Label1:
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("nargs for append actions must be > 0; if arg strings are not supplying the value to append, the append const action may be more appropriate").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 966: raise ValueError('nargs for append actions must be > 0; if arg '
							πF.SetLineno(966)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µconst, "const"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(µconst != πTemp005).ToObject()
							πTemp001 = πTemp004
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							if πTemp004, πE = πg.NE(πF, µnargs, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πTemp004
						Label3:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 969: if const is not None and nargs != OPTIONAL:
							πF.SetLineno(969)
						Label4:
							πTemp003 = πF.MakeArgs(1)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("nargs must be %r to supply const").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 970: raise ValueError('nargs must be %r to supply const' % OPTIONAL)
							πF.SetLineno(970)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
							goto Label5
						Label5:
							// line 971: super(_AppendAction, self).__init__(
							πF.SetLineno(971)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µconst, "const"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchoices, "choices"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmetavar, "metavar"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"nargs", µnargs},
								{"const", µconst},
								{"default", µdefault},
								{"type", µtype},
								{"choices", µchoices},
								{"required", µrequired},
								{"help", µhelp},
								{"metavar", µmetavar},
							}
							πTemp003 = πF.MakeArgs(2)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_AppendAction); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[1] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, nil, πTemp006); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 983: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(983)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "parser", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp002[3] = πg.Param{Name: "values", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "option_string", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var µitems *πg.Object = πg.UnboundLocal; _ = µitems
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 985: items = (_ensure_value(namespace, self.dest, []))[:]
							πF.SetLineno(985)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp003[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp004
							πTemp005 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp005...).ToObject()
							πTemp003[2] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_ensure_value); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.GetItem(πF, πTemp006, πTemp001); πE != nil {
								continue
							}
							µitems = πTemp002
							// line 986: items.append(values)
							πF.SetLineno(986)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µvalues, "values"); πE != nil {
								continue
							}
							πTemp003[0] = µvalues
							if πE = πg.CheckLocal(πF, µitems, "items"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µitems, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 987: setattr(namespace, self.dest, items)
							πF.SetLineno(987)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp003[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µitems, "items"); πE != nil {
								continue
							}
							πTemp003[2] = µitems
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_AppendAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_AppendAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 990: class _AppendConstAction(Action):
			πF.SetLineno(990)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_AppendConstAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 992: def __init__(self,
					πF.SetLineno(992)
					πTemp002 = make([]πg.Param, 8)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "dest", Def: nil}
					πTemp002[3] = πg.Param{Name: "const", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "required", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[6] = πg.Param{Name: "help", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[7] = πg.Param{Name: "metavar", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µconst *πg.Object = πArgs[3]; _ = µconst
						var µdefault *πg.Object = πArgs[4]; _ = µdefault
						var µrequired *πg.Object = πArgs[5]; _ = µrequired
						var µhelp *πg.Object = πArgs[6]; _ = µhelp
						var µmetavar *πg.Object = πArgs[7]; _ = µmetavar
						var πTemp001 πg.KWArgs
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1000: super(_AppendConstAction, self).__init__(
							πF.SetLineno(1000)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µconst, "const"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmetavar, "metavar"); πE != nil {
								continue
							}
							πTemp001 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"nargs", πg.NewInt(0).ToObject()},
								{"const", µconst},
								{"default", µdefault},
								{"required", µrequired},
								{"help", µhelp},
								{"metavar", µmetavar},
							}
							πTemp002 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_AppendConstAction); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[1] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1010: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(1010)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "parser", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp002[3] = πg.Param{Name: "values", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "option_string", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var µitems *πg.Object = πg.UnboundLocal; _ = µitems
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1012: items = (_ensure_value(namespace, self.dest, []))[:]
							πF.SetLineno(1012)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp003[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp004
							πTemp005 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp005...).ToObject()
							πTemp003[2] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_ensure_value); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.GetItem(πF, πTemp006, πTemp001); πE != nil {
								continue
							}
							µitems = πTemp002
							// line 1013: items.append(self.const)
							πF.SetLineno(1013)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßconst, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µitems, "items"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µitems, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1014: setattr(namespace, self.dest, items)
							πF.SetLineno(1014)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp003[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µitems, "items"); πE != nil {
								continue
							}
							πTemp003[2] = µitems
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_AppendConstAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_AppendConstAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1017: class _CountAction(Action):
			πF.SetLineno(1017)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_CountAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1019: def __init__(self,
					πF.SetLineno(1019)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "dest", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "required", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "help", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µdefault *πg.Object = πArgs[3]; _ = µdefault
						var µrequired *πg.Object = πArgs[4]; _ = µrequired
						var µhelp *πg.Object = πArgs[5]; _ = µhelp
						var πTemp001 πg.KWArgs
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1025: super(_CountAction, self).__init__(
							πF.SetLineno(1025)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πTemp001 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"nargs", πg.NewInt(0).ToObject()},
								{"default", µdefault},
								{"required", µrequired},
								{"help", µhelp},
							}
							πTemp002 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_CountAction); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[1] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1033: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(1033)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "parser", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp002[3] = πg.Param{Name: "values", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "option_string", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var µnew_count *πg.Object = πg.UnboundLocal; _ = µnew_count
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1034: new_count = _ensure_value(namespace, self.dest, 0) + 1
							πF.SetLineno(1034)
							πTemp002 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp002[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp002[1] = πTemp003
							πTemp002[2] = πg.NewInt(0).ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_ensure_value); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µnew_count = πTemp001
							// line 1035: setattr(namespace, self.dest, new_count)
							πF.SetLineno(1035)
							πTemp002 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp002[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							if πE = πg.CheckLocal(πF, µnew_count, "new_count"); πE != nil {
								continue
							}
							πTemp002[2] = µnew_count
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_CountAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_CountAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1038: class _HelpAction(Action):
			πF.SetLineno(1038)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_HelpAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1040: def __init__(self,
					πF.SetLineno(1040)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßSUPPRESS); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "dest", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßSUPPRESS); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "default", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "help", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µdest *πg.Object = πArgs[2]; _ = µdest
						var µdefault *πg.Object = πArgs[3]; _ = µdefault
						var µhelp *πg.Object = πArgs[4]; _ = µhelp
						var πTemp001 πg.KWArgs
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1045: super(_HelpAction, self).__init__(
							πF.SetLineno(1045)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πTemp001 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"default", µdefault},
								{"nargs", πg.NewInt(0).ToObject()},
								{"help", µhelp},
							}
							πTemp002 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_HelpAction); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[1] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1052: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(1052)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "parser", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp002[3] = πg.Param{Name: "values", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "option_string", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1053: parser.print_help()
							πF.SetLineno(1053)
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparser, ßprint_help, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1054: parser.exit()
							πF.SetLineno(1054)
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparser, ßexit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_HelpAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_HelpAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1057: class _VersionAction(Action):
			πF.SetLineno(1057)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_VersionAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1059: def __init__(self,
					πF.SetLineno(1059)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_strings", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "version", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßSUPPRESS); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "dest", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßSUPPRESS); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "default", Def: πTemp003}
					πTemp002[5] = πg.Param{Name: "help", Def: πg.NewStr("show program's version number and exit").ToObject()}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µversion *πg.Object = πArgs[2]; _ = µversion
						var µdest *πg.Object = πArgs[3]; _ = µdest
						var µdefault *πg.Object = πArgs[4]; _ = µdefault
						var µhelp *πg.Object = πArgs[5]; _ = µhelp
						var πTemp001 πg.KWArgs
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1065: super(_VersionAction, self).__init__(
							πF.SetLineno(1065)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πTemp001 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"default", µdefault},
								{"nargs", πg.NewInt(0).ToObject()},
								{"help", µhelp},
							}
							πTemp002 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_VersionAction); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[1] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, πTemp001); πE != nil {
								continue
							}
							// line 1071: self.version = version
							πF.SetLineno(1071)
							if πE = πg.CheckLocal(πF, µversion, "version"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µversion); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßversion, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1073: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(1073)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "parser", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp002[3] = πg.Param{Name: "values", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "option_string", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var µversion *πg.Object = πg.UnboundLocal; _ = µversion
						var µformatter *πg.Object = πg.UnboundLocal; _ = µformatter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 πg.KWArgs
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1074: version = self.version
							πF.SetLineno(1074)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßversion, nil); πE != nil {
								continue
							}
							µversion = πTemp001
							if πE = πg.CheckLocal(πF, µversion, "version"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µversion == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1075: if version is None:
							πF.SetLineno(1075)
						Label1:
							// line 1076: version = parser.version
							πF.SetLineno(1076)
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparser, ßversion, nil); πE != nil {
								continue
							}
							µversion = πTemp001
							goto Label2
						Label2:
							// line 1077: formatter = parser._get_formatter()
							πF.SetLineno(1077)
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparser, ß_get_formatter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µformatter = πTemp002
							// line 1078: formatter.add_text(version)
							πF.SetLineno(1078)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µversion, "version"); πE != nil {
								continue
							}
							πTemp004[0] = µversion
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßadd_text, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1079: parser.exit(message=formatter.format_help())
							πF.SetLineno(1079)
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßformat_help, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"message", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparser, ßexit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, πTemp005); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_VersionAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_VersionAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1082: class _SubParsersAction(Action):
			πF.SetLineno(1082)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßAction); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_SubParsersAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 []πg.Param
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1084: class _ChoicesPseudoAction(Action):
					πF.SetLineno(1084)
					πTemp003 = make([]*πg.Object, 1)
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßAction); πE != nil {
						continue
					}
					πTemp003[0] = πTemp005
					πTemp001 = πg.NewDict()
					if πTemp002, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, ß__module__.ToObject(), πTemp002); πE != nil {
						continue
					}
					_, πE = πg.NewCode("_ChoicesPseudoAction", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
						πClass := πTemp001
						_ = πClass
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []πg.Param
						_ = πTemp002
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1086: def __init__(self, name, help):
							πF.SetLineno(1086)
							πTemp002 = make([]πg.Param, 3)
							πTemp002[0] = πg.Param{Name: "self", Def: nil}
							πTemp002[1] = πg.Param{Name: "name", Def: nil}
							πTemp002[2] = πg.Param{Name: "help", Def: nil}
							πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µself *πg.Object = πArgs[0]; _ = µself
								var µname *πg.Object = πArgs[1]; _ = µname
								var µhelp *πg.Object = πArgs[2]; _ = µhelp
								var µsup *πg.Object = πg.UnboundLocal; _ = µsup
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 πg.KWArgs
								_ = πTemp004
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default: panic("unexpected function state")
									}
									// line 1087: sup = super(_SubParsersAction._ChoicesPseudoAction, self)
									πF.SetLineno(1087)
									πTemp001 = πF.MakeArgs(2)
									if πTemp002, πE = πg.ResolveGlobal(πF, ß_SubParsersAction); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß_ChoicesPseudoAction, nil); πE != nil {
										continue
									}
									πTemp001[0] = πTemp003
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									πTemp001[1] = µself
									if πTemp002, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									µsup = πTemp003
									// line 1088: sup.__init__(option_strings=[], dest=name, help=help)
									πF.SetLineno(1088)
									πTemp001 = make([]*πg.Object, 0)
									πTemp002 = πg.NewList(πTemp001...).ToObject()
									if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
										continue
									}
									πTemp004 = πg.KWArgs{
										{"option_strings", πTemp002},
										{"dest", µname},
										{"help", µhelp},
									}
									if πE = πg.CheckLocal(πF, µsup, "sup"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µsup, ß__init__, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, nil, πTemp004); πE != nil {
										continue
									}
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
								continue
							}
						}
						return nil, nil
					}).Eval(πF, πF.Globals(), nil, nil)
					if πE != nil {
						continue
					}
					if πTemp004, πE = πTemp001.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
						continue
					}
					if πTemp004 == nil {
						πTemp004 = πg.TypeType.ToObject()
					}
					if πTemp005, πE = πTemp004.Call(πF, []*πg.Object{πg.NewStr("_ChoicesPseudoAction").ToObject(), πg.NewTuple(πTemp003...).ToObject(), πTemp001.ToObject()}, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß_ChoicesPseudoAction.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1090: def __init__(self,
					πF.SetLineno(1090)
					πTemp006 = make([]πg.Param, 7)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "option_strings", Def: nil}
					πTemp006[2] = πg.Param{Name: "prog", Def: nil}
					πTemp006[3] = πg.Param{Name: "parser_class", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßSUPPRESS); πE != nil {
						continue
					}
					πTemp006[4] = πg.Param{Name: "dest", Def: πTemp004}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp006[5] = πg.Param{Name: "help", Def: πTemp004}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp006[6] = πg.Param{Name: "metavar", Def: πTemp004}
					πTemp002 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_strings *πg.Object = πArgs[1]; _ = µoption_strings
						var µprog *πg.Object = πArgs[2]; _ = µprog
						var µparser_class *πg.Object = πArgs[3]; _ = µparser_class
						var µdest *πg.Object = πArgs[4]; _ = µdest
						var µhelp *πg.Object = πArgs[5]; _ = µhelp
						var µmetavar *πg.Object = πArgs[6]; _ = µmetavar
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Dict
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 πg.KWArgs
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1098: self._prog_prefix = prog
							πF.SetLineno(1098)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µprog); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_prog_prefix, πTemp001); πE != nil {
								continue
							}
							// line 1099: self._parser_class = parser_class
							πF.SetLineno(1099)
							if πE = πg.CheckLocal(πF, µparser_class, "parser_class"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µparser_class); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_parser_class, πTemp001); πE != nil {
								continue
							}
							// line 1100: self._name_parser_map = {} # _collections.OrderedDict()
							πF.SetLineno(1100)
							πTemp002 = πg.NewDict()
							πTemp001 = πTemp002.ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_name_parser_map, πTemp003); πE != nil {
								continue
							}
							// line 1101: self._choices_actions = []
							πF.SetLineno(1101)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_choices_actions, πTemp003); πE != nil {
								continue
							}
							// line 1103: super(_SubParsersAction, self).__init__(
							πF.SetLineno(1103)
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßPARSER); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_name_parser_map, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmetavar, "metavar"); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"option_strings", µoption_strings},
								{"dest", µdest},
								{"nargs", πTemp001},
								{"choices", πTemp003},
								{"help", µhelp},
								{"metavar", µmetavar},
							}
							πTemp004 = πF.MakeArgs(2)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_SubParsersAction); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp004[1] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, πTemp005); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 1111: def add_parser(self, name, **kwargs):
					πF.SetLineno(1111)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "name", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("add_parser", "build/src/__python__/argparse.py", πTemp006, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µname *πg.Object = πArgs[1]; _ = µname
						var µkwargs *πg.Object = πArgs[2]; _ = µkwargs
						var µhelp *πg.Object = πg.UnboundLocal; _ = µhelp
						var µchoice_action *πg.Object = πg.UnboundLocal; _ = µchoice_action
						var µparser *πg.Object = πg.UnboundLocal; _ = µparser
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßprog.ToObject()
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µkwargs, ßget, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp004 == πTemp003).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1113: if kwargs.get('prog') is None:
							πF.SetLineno(1113)
						Label1:
							// line 1114: kwargs['prog'] = '%s %s' % (self._prog_prefix, name)
							πF.SetLineno(1114)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_prog_prefix, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(πTemp004, µname).ToObject()
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("%s %s").ToObject(), πTemp003); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp004 = ßprog.ToObject()
							if πE = πg.SetItem(πF, µkwargs, πTemp004, πTemp003); πE != nil {
								continue
							}
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µkwargs, ßhelp.ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 1117: if 'help' in kwargs:
							πF.SetLineno(1117)
						Label3:
							// line 1119: help = kwargs['help']
							πF.SetLineno(1119)
							πTemp001 = ßhelp.ToObject()
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µkwargs, πTemp001); πE != nil {
								continue
							}
							µhelp = πTemp003
							// line 1120: del kwargs['help']
							πF.SetLineno(1120)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp001 = ßhelp.ToObject()
							if πE = πg.DelItem(πF, µkwargs, πTemp001); πE != nil {
								continue
							}
							// line 1121: choice_action = self._ChoicesPseudoAction(name, help)
							πF.SetLineno(1121)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp002[0] = µname
							if πE = πg.CheckLocal(πF, µhelp, "help"); πE != nil {
								continue
							}
							πTemp002[1] = µhelp
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_ChoicesPseudoAction, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µchoice_action = πTemp003
							// line 1122: self._choices_actions.append(choice_action)
							πF.SetLineno(1122)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µchoice_action, "choice_action"); πE != nil {
								continue
							}
							πTemp002[0] = µchoice_action
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_choices_actions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßappend, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label4
						Label4:
							// line 1125: parser = self._parser_class(**kwargs)
							πF.SetLineno(1125)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_parser_class, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Invoke(πF, πTemp001, nil, nil, nil, µkwargs); πE != nil {
								continue
							}
							µparser = πTemp003
							// line 1126: self._name_parser_map[name] = parser
							πF.SetLineno(1126)
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µparser); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_name_parser_map, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp004 = µname
							if πE = πg.SetItem(πF, πTemp003, πTemp004, πTemp001); πE != nil {
								continue
							}
							// line 1127: return parser
							πF.SetLineno(1127)
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							πR = µparser
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_parser.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1129: def _get_subactions(self):
					πF.SetLineno(1129)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("_get_subactions", "build/src/__python__/argparse.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1130: return self._choices_actions
							πF.SetLineno(1130)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_choices_actions, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_subactions.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1132: def __call__(self, parser, namespace, values, option_string=None):
					πF.SetLineno(1132)
					πTemp006 = make([]πg.Param, 5)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "parser", Def: nil}
					πTemp006[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp006[3] = πg.Param{Name: "values", Def: nil}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp006[4] = πg.Param{Name: "option_string", Def: πTemp008}
					πTemp007 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µparser *πg.Object = πArgs[1]; _ = µparser
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µvalues *πg.Object = πArgs[3]; _ = µvalues
						var µoption_string *πg.Object = πArgs[4]; _ = µoption_string
						var µparser_name *πg.Object = πg.UnboundLocal; _ = µparser_name
						var µarg_strings *πg.Object = πg.UnboundLocal; _ = µarg_strings
						var µtup *πg.Object = πg.UnboundLocal; _ = µtup
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var µsubnamespace *πg.Object = πg.UnboundLocal; _ = µsubnamespace
						var µkey *πg.Object = πg.UnboundLocal; _ = µkey
						var µvalue *πg.Object = πg.UnboundLocal; _ = µvalue
						var µargs_attr *πg.Object = πg.UnboundLocal; _ = µargs_attr
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.BaseException
						_ = πTemp006
						var πTemp007 *πg.Traceback
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4: goto Label4
							case 6: goto Label6
							case 7: goto Label7
							default: panic("unexpected function state")
							}
							// line 1133: parser_name = values[0]
							πF.SetLineno(1133)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µvalues, "values"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µvalues, πTemp001); πE != nil {
								continue
							}
							µparser_name = πTemp002
							// line 1134: arg_strings = values[1:]
							πF.SetLineno(1134)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalues, "values"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µvalues, πTemp001); πE != nil {
								continue
							}
							µarg_strings = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 != πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1137: if self.dest is not SUPPRESS:
							πF.SetLineno(1137)
						Label1:
							// line 1138: setattr(namespace, self.dest, parser_name)
							πF.SetLineno(1138)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp005[0] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdest, nil); πE != nil {
								continue
							}
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µparser_name, "parser_name"); πE != nil {
								continue
							}
							πTemp005[2] = µparser_name
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label2
						Label2:
							// line 1141: try:
							πF.SetLineno(1141)
							πF.PushCheckpoint(4)
							// line 1142: parser = self._name_parser_map[parser_name]
							πF.SetLineno(1142)
							if πE = πg.CheckLocal(πF, µparser_name, "parser_name"); πE != nil {
								continue
							}
							πTemp001 = µparser_name
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_name_parser_map, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µparser = πTemp002
							πF.PopCheckpoint()
							goto Label3
						Label4:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp006, πTemp007 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßKeyError); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsInstance(πF, πTemp006.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							πE = πF.Raise(πTemp006.ToObject(), nil, πTemp007.ToObject())
							continue
							// line 1143: except KeyError:
							πF.SetLineno(1143)
						Label5:
							// line 1144: tup = parser_name, ', '.join(self._name_parser_map)
							πF.SetLineno(1144)
							if πE = πg.CheckLocal(πF, µparser_name, "parser_name"); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_name_parser_map, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr(", ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001 = πg.NewTuple2(µparser_name, πTemp003).ToObject()
							µtup = πTemp001
							// line 1145: msg = _('unknown parser %r (choices: %s)') % tup
							πF.SetLineno(1145)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr("unknown parser %r (choices: %s)").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.CheckLocal(πF, µtup, "tup"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πTemp003, µtup); πE != nil {
								continue
							}
							µmsg = πTemp001
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp005[0] = µself
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp005[1] = µmsg
							if πTemp001, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 1146: raise ArgumentError(self, msg)
							πF.SetLineno(1146)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
						Label3:
							// line 1155: subnamespace, arg_strings = parser.parse_known_args(arg_strings, None)
							πF.SetLineno(1155)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							πTemp005[0] = µarg_strings
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparser, ßparse_known_args, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µsubnamespace = πTemp001
							µarg_strings = πTemp003
							if πE = πg.CheckLocal(πF, µsubnamespace, "subnamespace"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µsubnamespace, ß__dict__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßitems, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp004 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp009}}}, πTemp002); πE != nil {
									continue
								}
								µkey = πTemp003
								µvalue = πTemp009
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(6)            
							// line 1158: setattr(namespace, key, value)
							πF.SetLineno(1158)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp005[0] = µnamespace
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp005[1] = µkey
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp005[2] = µvalue
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µarg_strings); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label9
							}
							goto Label10
							// line 1160: if arg_strings:
							πF.SetLineno(1160)
						Label9:
							// line 1162: args_attr = setdefault(namespace.__dict__, _UNRECOGNIZED_ARGS_ATTR, [])
							πF.SetLineno(1162)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µnamespace, ß__dict__, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_UNRECOGNIZED_ARGS_ATTR); πE != nil {
								continue
							}
							πTemp005[1] = πTemp001
							πTemp010 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp010...).ToObject()
							πTemp005[2] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsetdefault); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µargs_attr = πTemp002
							// line 1164: args_attr += (arg_strings)
							πF.SetLineno(1164)
							if πE = πg.CheckLocal(πF, µargs_attr, "args_attr"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µargs_attr, µarg_strings); πE != nil {
								continue
							}
							µargs_attr = πTemp001
							goto Label10
						Label10:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp007); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_SubParsersAction").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_SubParsersAction.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1171: class FileType(object):
			πF.SetLineno(1171)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FileType", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1172: """Factory for creating file object types
					πF.SetLineno(1172)
					// line 1184: def __init__(self, mode='r', bufsize=-1):
					πF.SetLineno(1184)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "mode", Def: ßr.ToObject()}
					if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "bufsize", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µmode *πg.Object = πArgs[1]; _ = µmode
						var µbufsize *πg.Object = πArgs[2]; _ = µbufsize
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1185: self._mode = mode
							πF.SetLineno(1185)
							if πE = πg.CheckLocal(πF, µmode, "mode"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µmode); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_mode, πTemp001); πE != nil {
								continue
							}
							// line 1186: self._bufsize = bufsize
							πF.SetLineno(1186)
							if πE = πg.CheckLocal(πF, µbufsize, "bufsize"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µbufsize); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_bufsize, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1188: def __call__(self, string):
					πF.SetLineno(1188)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("__call__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µstring *πg.Object = πArgs[1]; _ = µstring
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var µe *πg.Object = πg.UnboundLocal; _ = µe
						var µmessage *πg.Object = πg.UnboundLocal; _ = µmessage
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.BaseException
						_ = πTemp006
						var πTemp007 *πg.Traceback
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8: goto Label8
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µstring, πg.NewStr("-").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1190: if string == '-':
							πF.SetLineno(1190)
						Label1:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_mode, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, πTemp003, ßr.ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_mode, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, πTemp003, ßw.ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 1191: if 'r' in self._mode:
							πF.SetLineno(1191)
						Label3:
							// line 1192: return _sys.stdin
							πF.SetLineno(1192)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßstdin, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label6
							// line 1193: elif 'w' in self._mode:
							πF.SetLineno(1193)
						Label4:
							// line 1194: return _sys.stdout
							πF.SetLineno(1194)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßstdout, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label6
						Label5:
							// line 1196: msg = _('argument "-" with mode %r') % self._mode
							πF.SetLineno(1196)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("argument \"-\" with mode %r").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_mode, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							µmsg = πTemp001
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp004[0] = µmsg
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1197: raise ValueError(msg)
							πF.SetLineno(1197)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label6
						Label6:
							goto Label2
						Label2:
							// line 1200: try:
							πF.SetLineno(1200)
							πF.PushCheckpoint(8)
							// line 1201: return open(string, self._mode, self._bufsize)
							πF.SetLineno(1201)
							πTemp004 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp004[0] = µstring
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_mode, nil); πE != nil {
								continue
							}
							πTemp004[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_bufsize, nil); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßopen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πR = πTemp003
							continue
							πF.PopCheckpoint()
							goto Label7
						Label8:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp006, πTemp007 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßIOError); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsInstance(πF, πTemp006.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label9
							}
							πE = πF.Raise(πTemp006.ToObject(), nil, πTemp007.ToObject())
							continue
							// line 1202: except IOError as e:
							πF.SetLineno(1202)
						Label9:
							µe = πTemp006.ToObject()
							// line 1203: message = _("can't open '%s': %s")
							πF.SetLineno(1203)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("can't open '%s': %s").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µmessage = πTemp003
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µe, "e"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(µstring, µe).ToObject()
							if πTemp001, πE = πg.Mod(πF, µmessage, πTemp003); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßArgumentTypeError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1204: raise ArgumentTypeError(message % (string, e))
							πF.SetLineno(1204)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label7
						Label7:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__call__.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1206: def __repr__(self):
					πF.SetLineno(1206)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("__repr__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µargs *πg.Object = πg.UnboundLocal; _ = µargs
						var µargs_str *πg.Object = πg.UnboundLocal; _ = µargs_str
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 []πg.Param
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1207: args = self._mode, self._bufsize
							πF.SetLineno(1207)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_mode, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_bufsize, nil); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, πTemp003).ToObject()
							µargs = πTemp001
							// line 1208: args_str = ', '.join(repr(arg) for arg in args if arg != -1)
							πF.SetLineno(1208)
							πTemp004 = πF.MakeArgs(1)
							πTemp005 = make([]πg.Param, 0)
							πTemp001 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µarg *πg.Object = πg.UnboundLocal; _ = µarg
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πTemp006 []*πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µargs); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µarg = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µarg, "arg"); πE != nil {
											continue
										}
										if πTemp005, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
											continue
										}
										if πTemp004, πE = πg.NE(πF, µarg, πTemp005); πE != nil {
											continue
										}
										if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
											continue
										}
										if πTemp003 {
											goto Label4
										}
										goto Label5
										// line 1208: args_str = ', '.join(repr(arg) for arg in args if arg != -1)
										πF.SetLineno(1208)
									Label4:
										// line 1208: args_str = ', '.join(repr(arg) for arg in args if arg != -1)
										πF.SetLineno(1208)
										πTemp006 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µarg, "arg"); πE != nil {
											continue
										}
										πTemp006[0] = µarg
										if πTemp004, πE = πg.ResolveGlobal(πF, ßrepr); πE != nil {
											continue
										}
										if πTemp005, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp006)
										πF.PushCheckpoint(6)
										return πTemp005, nil
									Label6:
										πTemp004 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr(", ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µargs_str = πTemp003
							// line 1209: return '%s(%s)' % (type(self).__name__, args_str)
							πF.SetLineno(1209)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp004[0] = µself
							if πTemp006, πE = πg.ResolveGlobal(πF, ßtype); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp006, πE = πg.GetAttr(πF, πTemp007, ß__name__, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargs_str, "args_str"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(πTemp006, µargs_str).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("%s(%s)").ToObject(), πTemp003); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__repr__.ToObject(), πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("FileType").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFileType.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1215: class Namespace(_AttributeHolder):
			πF.SetLineno(1215)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ß_AttributeHolder); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Namespace", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1216: """Simple object for storing attributes.
					πF.SetLineno(1216)
					// line 1222: def __init__(self, **kwargs):
					πF.SetLineno(1222)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µkwargs *πg.Object = πArgs[1]; _ = µkwargs
						var µname *πg.Object = πg.UnboundLocal; _ = µname
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µkwargs); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp002 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp003 = !isStop
							} else {
								πTemp003 = true
								µname = πTemp004
							}
							if πE != nil || !πTemp003 {
								continue
							}
							πF.PushCheckpoint(1)            
							// line 1224: setattr(self, name, kwargs[name])
							πF.SetLineno(1224)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp005[0] = µself
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp005[1] = µname
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp004 = µname
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µkwargs, πTemp004); πE != nil {
								continue
							}
							πTemp005[2] = πTemp006
							if πTemp004, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1226: __hash__ = None
					πF.SetLineno(1226)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__hash__.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1228: def __eq__(self, other):
					πF.SetLineno(1228)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "other", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("__eq__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µother *πg.Object = πArgs[1]; _ = µother
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µother, "other"); πE != nil {
								continue
							}
							πTemp002[0] = µother
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNamespace); πE != nil {
								continue
							}
							πTemp002[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1229: if not isinstance(other, Namespace):
							πF.SetLineno(1229)
						Label1:
							// line 1230: return NotImplemented
							πF.SetLineno(1230)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNotImplemented); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 1232: return self.__dict__ == other.__dict__
							πF.SetLineno(1232)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß__dict__, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µother, "other"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µother, ß__dict__, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__eq__.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1234: def __ne__(self, other):
					πF.SetLineno(1234)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "other", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("__ne__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µother *πg.Object = πArgs[1]; _ = µother
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µother, "other"); πE != nil {
								continue
							}
							πTemp002[0] = µother
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNamespace); πE != nil {
								continue
							}
							πTemp002[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1235: if not isinstance(other, Namespace):
							πF.SetLineno(1235)
						Label1:
							// line 1236: return NotImplemented
							πF.SetLineno(1236)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNotImplemented); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 1237: return not (self == other)
							πF.SetLineno(1237)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µother, "other"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, µself, µother); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__ne__.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1239: def __contains__(self, key):
					πF.SetLineno(1239)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "key", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("__contains__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µkey *πg.Object = πArgs[1]; _ = µkey
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1240: return key in self.__dict__
							πF.SetLineno(1240)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß__dict__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, πTemp002, µkey); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__contains__.ToObject(), πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("Namespace").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNamespace.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1243: class _ActionsContainer(object):
			πF.SetLineno(1243)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_ActionsContainer", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 *πg.Object
				_ = πTemp019
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1245: def __init__(self,
					πF.SetLineno(1245)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "description", Def: nil}
					πTemp002[2] = πg.Param{Name: "prefix_chars", Def: nil}
					πTemp002[3] = πg.Param{Name: "argument_default", Def: nil}
					πTemp002[4] = πg.Param{Name: "conflict_handler", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µdescription *πg.Object = πArgs[1]; _ = µdescription
						var µprefix_chars *πg.Object = πArgs[2]; _ = µprefix_chars
						var µargument_default *πg.Object = πArgs[3]; _ = µargument_default
						var µconflict_handler *πg.Object = πArgs[4]; _ = µconflict_handler
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Dict
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1252: self.description = description
							πF.SetLineno(1252)
							if πE = πg.CheckLocal(πF, µdescription, "description"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µdescription); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdescription, πTemp001); πE != nil {
								continue
							}
							// line 1253: self.argument_default = argument_default
							πF.SetLineno(1253)
							if πE = πg.CheckLocal(πF, µargument_default, "argument_default"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µargument_default); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßargument_default, πTemp001); πE != nil {
								continue
							}
							// line 1254: self.prefix_chars = prefix_chars
							πF.SetLineno(1254)
							if πE = πg.CheckLocal(πF, µprefix_chars, "prefix_chars"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µprefix_chars); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßprefix_chars, πTemp001); πE != nil {
								continue
							}
							// line 1255: self.conflict_handler = conflict_handler
							πF.SetLineno(1255)
							if πE = πg.CheckLocal(πF, µconflict_handler, "conflict_handler"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µconflict_handler); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßconflict_handler, πTemp001); πE != nil {
								continue
							}
							// line 1258: self._registries = {}
							πF.SetLineno(1258)
							πTemp002 = πg.NewDict()
							πTemp001 = πTemp002.ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_registries, πTemp003); πE != nil {
								continue
							}
							// line 1261: self.register('action', None, _StoreAction)
							πF.SetLineno(1261)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp004[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_StoreAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1262: self.register('action', 'store', _StoreAction)
							πF.SetLineno(1262)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßstore.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_StoreAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1263: self.register('action', 'store_const', _StoreConstAction)
							πF.SetLineno(1263)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßstore_const.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_StoreConstAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1264: self.register('action', 'store_true', _StoreTrueAction)
							πF.SetLineno(1264)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßstore_true.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_StoreTrueAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1265: self.register('action', 'store_false', _StoreFalseAction)
							πF.SetLineno(1265)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßstore_false.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_StoreFalseAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1266: self.register('action', 'append', _AppendAction)
							πF.SetLineno(1266)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßappend.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_AppendAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1267: self.register('action', 'append_const', _AppendConstAction)
							πF.SetLineno(1267)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßappend_const.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_AppendConstAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1268: self.register('action', 'count', _CountAction)
							πF.SetLineno(1268)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßcount.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_CountAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1269: self.register('action', 'help', _HelpAction)
							πF.SetLineno(1269)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßhelp.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_HelpAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1270: self.register('action', 'version', _VersionAction)
							πF.SetLineno(1270)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßversion.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_VersionAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1271: self.register('action', 'parsers', _SubParsersAction)
							πF.SetLineno(1271)
							πTemp004 = πF.MakeArgs(3)
							πTemp004[0] = ßaction.ToObject()
							πTemp004[1] = ßparsers.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_SubParsersAction); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1274: self._get_handler()
							πF.SetLineno(1274)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_handler, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1277: self._actions = []
							πF.SetLineno(1277)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_actions, πTemp003); πE != nil {
								continue
							}
							// line 1278: self._option_string_actions = {}
							πF.SetLineno(1278)
							πTemp002 = πg.NewDict()
							πTemp001 = πTemp002.ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_option_string_actions, πTemp003); πE != nil {
								continue
							}
							// line 1281: self._action_groups = []
							πF.SetLineno(1281)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_action_groups, πTemp003); πE != nil {
								continue
							}
							// line 1282: self._mutually_exclusive_groups = []
							πF.SetLineno(1282)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_mutually_exclusive_groups, πTemp003); πE != nil {
								continue
							}
							// line 1285: self._defaults = {}
							πF.SetLineno(1285)
							πTemp002 = πg.NewDict()
							πTemp001 = πTemp002.ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_defaults, πTemp003); πE != nil {
								continue
							}
							// line 1288: self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')
							πF.SetLineno(1288)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("^-\\d+$|^-\\d*\\.\\d+$").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_negative_number_matcher, πTemp003); πE != nil {
								continue
							}
							// line 1292: self._has_negative_number_optionals = []
							πF.SetLineno(1292)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_has_negative_number_optionals, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1297: def register(self, registry_name, value, object):
					πF.SetLineno(1297)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "registry_name", Def: nil}
					πTemp002[2] = πg.Param{Name: "value", Def: nil}
					πTemp002[3] = πg.Param{Name: "object", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("register", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µregistry_name *πg.Object = πArgs[1]; _ = µregistry_name
						var µvalue *πg.Object = πArgs[2]; _ = µvalue
						var µobject *πg.Object = πArgs[3]; _ = µobject
						var µregistry *πg.Object = πg.UnboundLocal; _ = µregistry
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Dict
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1299: registry = setdefault(self._registries, registry_name, {})
							πF.SetLineno(1299)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_registries, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µregistry_name, "registry_name"); πE != nil {
								continue
							}
							πTemp001[1] = µregistry_name
							πTemp003 = πg.NewDict()
							πTemp002 = πTemp003.ToObject()
							πTemp001[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetdefault); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µregistry = πTemp004
							// line 1300: registry[value] = object
							πF.SetLineno(1300)
							if πE = πg.CheckLocal(πF, µobject, "object"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µobject); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µregistry, "registry"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp004 = µvalue
							if πE = πg.SetItem(πF, µregistry, πTemp004, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßregister.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1302: def _registry_get(self, registry_name, value, default=None):
					πF.SetLineno(1302)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "registry_name", Def: nil}
					πTemp002[2] = πg.Param{Name: "value", Def: nil}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "default", Def: πTemp005}
					πTemp004 = πg.NewFunction(πg.NewCode("_registry_get", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µregistry_name *πg.Object = πArgs[1]; _ = µregistry_name
						var µvalue *πg.Object = πArgs[2]; _ = µvalue
						var µdefault *πg.Object = πArgs[3]; _ = µdefault
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1303: return self._registries[registry_name].get(value, default)
							πF.SetLineno(1303)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp001[0] = µvalue
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							πTemp001[1] = µdefault
							if πE = πg.CheckLocal(πF, µregistry_name, "registry_name"); πE != nil {
								continue
							}
							πTemp002 = µregistry_name
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_registries, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßget, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_registry_get.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1308: def set_defaults(self, **kwargs):
					πF.SetLineno(1308)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("set_defaults", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µkwargs *πg.Object = πArgs[1]; _ = µkwargs
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							// line 1309: self._defaults.update(kwargs)
							πF.SetLineno(1309)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp001[0] = µkwargs
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_defaults, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßupdate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µaction = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)            
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µkwargs, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 1314: if action.dest in kwargs:
							πF.SetLineno(1314)
						Label4:
							// line 1315: action.default = kwargs[action.dest]
							πF.SetLineno(1315)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							πTemp003 = πTemp006
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µkwargs, πTemp003); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µaction, ßdefault, πTemp003); πE != nil {
								continue
							}
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßset_defaults.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1317: def get_default(self, dest):
					πF.SetLineno(1317)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "dest", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("get_default", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µdest *πg.Object = πArgs[1]; _ = µdest
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µaction = πTemp002
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)            
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Eq(πF, πTemp006, µdest); πE != nil {
								continue
							}
							πTemp002 = πTemp005
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(πTemp006 != πTemp007).ToObject()
							πTemp002 = πTemp005
						Label4:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 1319: if action.dest == dest and action.default is not None:
							πF.SetLineno(1319)
						Label5:
							// line 1320: return action.default
							πF.SetLineno(1320)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1321: return self._defaults.get(dest, None)
							πF.SetLineno(1321)
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							πTemp008[0] = µdest
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp008[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_defaults, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßget_default.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1327: def add_argument(self, *args, **kwargs):
					πF.SetLineno(1327)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("add_argument", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagVarArg | πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µargs *πg.Object = πArgs[1]; _ = µargs
						var µkwargs *πg.Object = πArgs[2]; _ = µkwargs
						var µchars *πg.Object = πg.UnboundLocal; _ = µchars
						var µdest *πg.Object = πg.UnboundLocal; _ = µdest
						var µaction_class *πg.Object = πg.UnboundLocal; _ = µaction_class
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var µtype_func *πg.Object = πg.UnboundLocal; _ = µtype_func
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 bool
						_ = πTemp011
						var πTemp012 *πg.BaseException
						_ = πTemp012
						var πTemp013 *πg.Traceback
						_ = πTemp013
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 21: goto Label21
							default: panic("unexpected function state")
							}
							// line 1328: """
							πF.SetLineno(1328)
							// line 1336: chars = self.prefix_chars
							πF.SetLineno(1336)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
								continue
							}
							µchars = πTemp001
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µargs); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp004).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp006[0] = µargs
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp005, πE = πg.Eq(πF, πTemp008, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp005
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label2
							}
							πTemp007 = πg.NewInt(0).ToObject()
							πTemp009 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetItem(πF, µargs, πTemp009); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, πTemp010, πTemp007); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchars, "chars"); πE != nil {
								continue
							}
							if πTemp011, πE = πg.Contains(πF, µchars, πTemp008); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(!πTemp011).ToObject()
							πTemp003 = πTemp005
						Label2:
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 1337: if not args or len(args) == 1 and args[0][0] not in chars:
							πF.SetLineno(1337)
						Label3:
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001 = µargs
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label6
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, µkwargs, ßdest.ToObject()); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp004).ToObject()
							πTemp001 = πTemp003
						Label6:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label7
							}
							goto Label8
							// line 1338: if args and 'dest' in kwargs:
							πF.SetLineno(1338)
						Label7:
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("dest supplied twice for positional argument").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 1339: raise ValueError('dest supplied twice for positional argument')
							πF.SetLineno(1339)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label8
						Label8:
							// line 1340: kwargs = self._get_positional_kwargs(*args, **kwargs)
							πF.SetLineno(1340)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_positional_kwargs, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Invoke(πF, πTemp001, nil, µargs, nil, µkwargs); πE != nil {
								continue
							}
							µkwargs = πTemp003
							goto Label5
						Label4:
							// line 1344: kwargs = self._get_optional_kwargs(*args, **kwargs)
							πF.SetLineno(1344)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_optional_kwargs, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Invoke(πF, πTemp001, nil, µargs, nil, µkwargs); πE != nil {
								continue
							}
							µkwargs = πTemp003
							goto Label5
						Label5:
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, µkwargs, ßdefault.ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label9
							}
							goto Label10
							// line 1347: if 'default' not in kwargs:
							πF.SetLineno(1347)
						Label9:
							// line 1348: dest = kwargs['dest']
							πF.SetLineno(1348)
							πTemp001 = ßdest.ToObject()
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µkwargs, πTemp001); πE != nil {
								continue
							}
							µdest = πTemp003
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_defaults, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, πTemp003, µdest); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label11
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßargument_default, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp003 != πTemp005).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label12
							}
							goto Label13
							// line 1349: if dest in self._defaults:
							πF.SetLineno(1349)
						Label11:
							// line 1350: kwargs['default'] = self._defaults[dest]
							πF.SetLineno(1350)
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							πTemp001 = µdest
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ß_defaults, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp005 = ßdefault.ToObject()
							if πE = πg.SetItem(πF, µkwargs, πTemp005, πTemp001); πE != nil {
								continue
							}
							goto Label13
							// line 1351: elif self.argument_default is not None:
							πF.SetLineno(1351)
						Label12:
							// line 1352: kwargs['default'] = self.argument_default
							πF.SetLineno(1352)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßargument_default, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp005 = ßdefault.ToObject()
							if πE = πg.SetItem(πF, µkwargs, πTemp005, πTemp003); πE != nil {
								continue
							}
							goto Label13
						Label13:
							goto Label10
						Label10:
							// line 1355: action_class = self._pop_action_class(kwargs)
							πF.SetLineno(1355)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp006[0] = µkwargs
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_pop_action_class, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µaction_class = πTemp003
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction_class, "action_class"); πE != nil {
								continue
							}
							πTemp006[0] = µaction_class
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_callable); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label14
							}
							goto Label15
							// line 1356: if not _callable(action_class):
							πF.SetLineno(1356)
						Label14:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction_class, "action_class"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple1(µaction_class).ToObject()
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("unknown action \"%s\"").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 1357: raise ValueError('unknown action "%s"' % (action_class,))
							πF.SetLineno(1357)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label15
						Label15:
							// line 1358: action = action_class(**kwargs)
							πF.SetLineno(1358)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction_class, "action_class"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Invoke(πF, µaction_class, nil, nil, nil, µkwargs); πE != nil {
								continue
							}
							µaction = πTemp001
							// line 1361: type_func = self._registry_get('type', action.type, action.type)
							πF.SetLineno(1361)
							πTemp006 = πF.MakeArgs(3)
							πTemp006[0] = ßtype.ToObject()
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßtype, nil); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßtype, nil); πE != nil {
								continue
							}
							πTemp006[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_registry_get, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µtype_func = πTemp003
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype_func, "type_func"); πE != nil {
								continue
							}
							πTemp006[0] = µtype_func
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_callable); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label16
							}
							goto Label17
							// line 1362: if not _callable(type_func):
							πF.SetLineno(1362)
						Label16:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype_func, "type_func"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple1(µtype_func).ToObject()
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("%r is not callable").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 1363: raise ValueError('%r is not callable' % (type_func,))
							πF.SetLineno(1363)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label17
						Label17:
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp006[0] = µself
							πTemp006[1] = ß_get_formatter.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label18
							}
							goto Label19
							// line 1366: if hasattr(self, "_get_formatter"):
							πF.SetLineno(1366)
						Label18:
							// line 1367: try:
							πF.SetLineno(1367)
							πF.PushCheckpoint(21)
							// line 1368: self._get_formatter()._format_args(action, None)
							πF.SetLineno(1368)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp006[0] = µaction
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_formatter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ß_format_args, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πF.PopCheckpoint()
							goto Label20
						Label21:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp012, πTemp013 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTypeError); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsInstance(πF, πTemp012.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label22
							}
							πE = πF.Raise(πTemp012.ToObject(), nil, πTemp013.ToObject())
							continue
							// line 1369: except TypeError:
							πF.SetLineno(1369)
						Label22:
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("length of metavar tuple does not match nargs").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 1370: raise ValueError("length of metavar tuple does not match nargs")
							πF.SetLineno(1370)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label20
						Label20:
							goto Label19
						Label19:
							// line 1372: return self._add_action(action)
							πF.SetLineno(1372)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp006[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_add_action, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_argument.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 1374: def add_argument_group(self, *args, **kwargs):
					πF.SetLineno(1374)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("add_argument_group", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagVarArg | πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µargs *πg.Object = πArgs[1]; _ = µargs
						var µkwargs *πg.Object = πArgs[2]; _ = µkwargs
						var µgroup *πg.Object = πg.UnboundLocal; _ = µgroup
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1375: group = _ArgumentGroup(self, *args, **kwargs)
							πF.SetLineno(1375)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_ArgumentGroup); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Invoke(πF, πTemp002, πTemp001, µargs, nil, µkwargs); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µgroup = πTemp003
							// line 1376: self._action_groups.append(group)
							πF.SetLineno(1376)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							πTemp001[0] = µgroup
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_action_groups, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1377: return group
							πF.SetLineno(1377)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							πR = µgroup
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_argument_group.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 1379: def add_mutually_exclusive_group(self, **kwargs):
					πF.SetLineno(1379)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("add_mutually_exclusive_group", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µkwargs *πg.Object = πArgs[1]; _ = µkwargs
						var µgroup *πg.Object = πg.UnboundLocal; _ = µgroup
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1380: group = _MutuallyExclusiveGroup(self, **kwargs)
							πF.SetLineno(1380)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_MutuallyExclusiveGroup); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Invoke(πF, πTemp002, πTemp001, nil, nil, µkwargs); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µgroup = πTemp003
							// line 1381: self._mutually_exclusive_groups.append(group)
							πF.SetLineno(1381)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							πTemp001[0] = µgroup
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_mutually_exclusive_groups, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1382: return group
							πF.SetLineno(1382)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							πR = µgroup
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_mutually_exclusive_group.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 1384: def _add_action(self, action):
					πF.SetLineno(1384)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("_add_action", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							case 4: goto Label4
							case 5: goto Label5
							default: panic("unexpected function state")
							}
							// line 1386: self._check_conflict(action)
							πF.SetLineno(1386)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_check_conflict, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1389: self._actions.append(action)
							πF.SetLineno(1389)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1390: action.container = self
							πF.SetLineno(1390)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µself); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µaction, ßcontainer, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µoption_string = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)            
							// line 1394: self._option_string_actions[option_string] = action
							πF.SetLineno(1394)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µaction); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp007 = µoption_string
							if πE = πg.SetItem(πF, πTemp006, πTemp007, πTemp003); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(5)
							πTemp004 = false
						Label4:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label6
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µoption_string = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(4)            
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp001[0] = µoption_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_negative_number_matcher, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							goto Label8
							// line 1398: if self._negative_number_matcher.match(option_string):
							πF.SetLineno(1398)
						Label7:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_has_negative_number_optionals, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label9
							}
							goto Label10
							// line 1399: if not self._has_negative_number_optionals:
							πF.SetLineno(1399)
						Label9:
							// line 1400: self._has_negative_number_optionals.append(True)
							πF.SetLineno(1400)
							πTemp001 = πF.MakeArgs(1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_has_negative_number_optionals, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label10
						Label10:
							goto Label8
						Label8:
							continue
						Label5:
							if πE != nil || πR != nil {
								continue
							}
						Label6:
							// line 1403: return action
							πF.SetLineno(1403)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πR = µaction
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_add_action.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 1405: def _remove_action(self, action):
					πF.SetLineno(1405)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("_remove_action", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1407: list_remove(self._actions, action)
							πF.SetLineno(1407)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[1] = µaction
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlist_remove); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_remove_action.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 1409: def _add_container_actions(self, container):
					πF.SetLineno(1409)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("_add_container_actions", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µcontainer *πg.Object = πArgs[1]; _ = µcontainer
						var µtitle_group_map *πg.Object = πg.UnboundLocal; _ = µtitle_group_map
						var µgroup *πg.Object = πg.UnboundLocal; _ = µgroup
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var µgroup_map *πg.Object = πg.UnboundLocal; _ = µgroup_map
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var µmutex_group *πg.Object = πg.UnboundLocal; _ = µmutex_group
						var πTemp001 *πg.Dict
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 bool
						_ = πTemp011
						var πTemp012 []*πg.Object
						_ = πTemp012
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							case 6: goto Label6
							case 7: goto Label7
							case 11: goto Label11
							case 12: goto Label12
							case 14: goto Label14
							case 15: goto Label15
							case 17: goto Label17
							case 18: goto Label18
							case 20: goto Label20
							case 21: goto Label21
							default: panic("unexpected function state")
							}
							// line 1411: title_group_map = {}
							πF.SetLineno(1411)
							πTemp001 = πg.NewDict()
							πTemp002 = πTemp001.ToObject()
							µtitle_group_map = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_action_groups, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µgroup = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)            
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µgroup, ßtitle, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle_group_map, "title_group_map"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µtitle_group_map, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 1413: if group.title in title_group_map:
							πF.SetLineno(1413)
						Label4:
							// line 1414: msg = _('cannot merge actions - two groups are named %r')
							πF.SetLineno(1414)
							πTemp007 = πF.MakeArgs(1)
							πTemp007[0] = πg.NewStr("cannot merge actions - two groups are named %r").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							µmsg = πTemp006
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µgroup, ßtitle, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Mod(πF, µmsg, πTemp006); πE != nil {
								continue
							}
							πTemp007[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 1415: raise ValueError(msg % (group.title))
							πF.SetLineno(1415)
							πE = πF.Raise(πTemp006, nil, nil)
							continue
							goto Label5
						Label5:
							// line 1416: title_group_map[group.title] = group
							πF.SetLineno(1416)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µgroup); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle_group_map, "title_group_map"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µgroup, ßtitle, nil); πE != nil {
								continue
							}
							πTemp006 = πTemp008
							if πE = πg.SetItem(πF, µtitle_group_map, πTemp006, πTemp003); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1419: group_map = {}
							πF.SetLineno(1419)
							πTemp001 = πg.NewDict()
							πTemp002 = πTemp001.ToObject()
							µgroup_map = πTemp002
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ß_action_groups, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp004 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µgroup = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(6)            
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µgroup, ßtitle, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle_group_map, "title_group_map"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µtitle_group_map, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label9
							}
							goto Label10
							// line 1424: if group.title not in title_group_map:
							πF.SetLineno(1424)
						Label9:
							// line 1425: title_group_map[group.title] = self.add_argument_group(
							πF.SetLineno(1425)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µgroup, ßtitle, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µgroup, ßdescription, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µgroup, ßconflict_handler, nil); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"title", πTemp003},
								{"description", πTemp006},
								{"conflict_handler", πTemp008},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßadd_argument_group, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, πTemp009); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle_group_map, "title_group_map"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetAttr(πF, µgroup, ßtitle, nil); πE != nil {
								continue
							}
							πTemp008 = πTemp010
							if πE = πg.SetItem(πF, µtitle_group_map, πTemp008, πTemp003); πE != nil {
								continue
							}
							goto Label10
						Label10:
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µgroup, ß_group_actions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Iter(πF, πTemp006); πE != nil {
								continue
							}
							πF.PushCheckpoint(12)
							πTemp005 = false
						Label11:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label13
							}
							if πTemp006, πE = πg.Next(πF, πTemp003); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp011 = !isStop
							} else {
								πTemp011 = true
								µaction = πTemp006
							}
							if πE != nil || !πTemp011 {
								continue
							}
							πF.PushCheckpoint(11)            
							// line 1432: group_map[action] = title_group_map[group.title]
							πF.SetLineno(1432)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µgroup, ßtitle, nil); πE != nil {
								continue
							}
							πTemp006 = πTemp008
							if πE = πg.CheckLocal(πF, µtitle_group_map, "title_group_map"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtitle_group_map, πTemp006); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πTemp008); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup_map, "group_map"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp010 = µaction
							if πE = πg.SetItem(πF, µgroup_map, πTemp010, πTemp006); πE != nil {
								continue
							}
							continue
						Label12:
							if πE != nil || πR != nil {
								continue
							}
						Label13:
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ß_mutually_exclusive_groups, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(15)
							πTemp004 = false
						Label14:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label16
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µgroup = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(14)            
							// line 1438: mutex_group = self.add_mutually_exclusive_group(
							πF.SetLineno(1438)
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µgroup, ßrequired, nil); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"required", πTemp003},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßadd_mutually_exclusive_group, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, πTemp009); πE != nil {
								continue
							}
							µmutex_group = πTemp006
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µgroup, ß_group_actions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Iter(πF, πTemp006); πE != nil {
								continue
							}
							πF.PushCheckpoint(18)
							πTemp005 = false
						Label17:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label19
							}
							if πTemp006, πE = πg.Next(πF, πTemp003); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp011 = !isStop
							} else {
								πTemp011 = true
								µaction = πTemp006
							}
							if πE != nil || !πTemp011 {
								continue
							}
							πF.PushCheckpoint(17)            
							// line 1443: group_map[action] = mutex_group
							πF.SetLineno(1443)
							if πE = πg.CheckLocal(πF, µmutex_group, "mutex_group"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, µmutex_group); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup_map, "group_map"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp008 = µaction
							if πE = πg.SetItem(πF, µgroup_map, πTemp008, πTemp006); πE != nil {
								continue
							}
							continue
						Label18:
							if πE != nil || πR != nil {
								continue
							}
						Label19:
							continue
						Label15:
							if πE != nil || πR != nil {
								continue
							}
						Label16:
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ß_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(21)
							πTemp004 = false
						Label20:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label22
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µaction = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(20)            
							// line 1447: group_map.get(action, self)._add_action(action)
							πF.SetLineno(1447)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp007[0] = µaction
							πTemp012 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp012[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp012[1] = µself
							if πE = πg.CheckLocal(πF, µgroup_map, "group_map"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µgroup_map, ßget, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp012, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp012)
							if πTemp003, πE = πg.GetAttr(πF, πTemp006, ß_add_action, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							continue
						Label21:
							if πE != nil || πR != nil {
								continue
							}
						Label22:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_add_container_actions.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 1449: def _get_positional_kwargs(self, dest, **kwargs):
					πF.SetLineno(1449)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "dest", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("_get_positional_kwargs", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µdest *πg.Object = πArgs[1]; _ = µdest
						var µkwargs *πg.Object = πArgs[2]; _ = µkwargs
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, µkwargs, ßrequired.ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1451: if 'required' in kwargs:
							πF.SetLineno(1451)
						Label1:
							// line 1452: msg = _("'required' is an invalid argument for positionals")
							πF.SetLineno(1452)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("'required' is an invalid argument for positionals").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp004
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[0] = µmsg
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTypeError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1453: raise TypeError(msg)
							πF.SetLineno(1453)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
							goto Label2
						Label2:
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßnargs.ToObject()
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µkwargs, ßget, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp003 = make([]*πg.Object, 2)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßZERO_OR_MORE); πE != nil {
								continue
							}
							πTemp003[1] = πTemp004
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							if πTemp002, πE = πg.Contains(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 1457: if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:
							πF.SetLineno(1457)
						Label3:
							// line 1458: kwargs['required'] = True
							πF.SetLineno(1458)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp005 = ßrequired.ToObject()
							if πE = πg.SetItem(πF, µkwargs, πTemp005, πTemp004); πE != nil {
								continue
							}
							goto Label4
						Label4:
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßnargs.ToObject()
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µkwargs, ßget, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp005, πE = πg.ResolveGlobal(πF, ßZERO_OR_MORE); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Eq(πF, πTemp006, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µkwargs, ßdefault.ToObject()); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp007).ToObject()
							πTemp001 = πTemp004
						Label5:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label6
							}
							goto Label7
							// line 1459: if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:
							πF.SetLineno(1459)
						Label6:
							// line 1460: kwargs['required'] = True
							πF.SetLineno(1460)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp005 = ßrequired.ToObject()
							if πE = πg.SetItem(πF, µkwargs, πTemp005, πTemp004); πE != nil {
								continue
							}
							goto Label7
						Label7:
							// line 1463: return dict(kwargs, dest=dest, option_strings=[])
							πF.SetLineno(1463)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp003[0] = µkwargs
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							πTemp008 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp008...).ToObject()
							πTemp009 = πg.KWArgs{
								{"dest", µdest},
								{"option_strings", πTemp001},
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_positional_kwargs.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 1465: def _get_optional_kwargs(self, *args, **kwargs):
					πF.SetLineno(1465)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("_get_optional_kwargs", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagVarArg | πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µargs *πg.Object = πArgs[1]; _ = µargs
						var µkwargs *πg.Object = πArgs[2]; _ = µkwargs
						var µoption_strings *πg.Object = πg.UnboundLocal; _ = µoption_strings
						var µlong_option_strings *πg.Object = πg.UnboundLocal; _ = µlong_option_strings
						var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var µtup *πg.Object = πg.UnboundLocal; _ = µtup
						var µdest *πg.Object = πg.UnboundLocal; _ = µdest
						var µdest_option_string *πg.Object = πg.UnboundLocal; _ = µdest_option_string
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							// line 1467: option_strings = []
							πF.SetLineno(1467)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µoption_strings = πTemp002
							// line 1468: long_option_strings = []
							πF.SetLineno(1468)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µlong_option_strings = πTemp002
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µargs); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp005, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µoption_string = πTemp005
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)            
							πTemp007 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µoption_string, πTemp007); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp007, πTemp008); πE != nil {
								continue
							}
							πTemp006 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 1471: if not option_string[0] in self.prefix_chars:
							πF.SetLineno(1471)
						Label4:
							// line 1472: msg = _('invalid option string %r: '
							πF.SetLineno(1472)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("invalid option string %r: must start with a character %r").ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp006
							// line 1474: tup = option_string, self.prefix_chars
							πF.SetLineno(1474)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
								continue
							}
							πTemp005 = πg.NewTuple2(µoption_string, πTemp006).ToObject()
							µtup = πTemp005
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtup, "tup"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Mod(πF, µmsg, µtup); πE != nil {
								continue
							}
							πTemp001[0] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1475: raise ValueError(msg % tup)
							πF.SetLineno(1475)
							πE = πF.Raise(πTemp006, nil, nil)
							continue
							goto Label5
						Label5:
							// line 1478: option_strings.append(option_string)
							πF.SetLineno(1478)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp001[0] = µoption_string
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µoption_strings, ßappend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp006 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µoption_string, πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp006, πTemp007); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 1479: if option_string[0] in self.prefix_chars:
							πF.SetLineno(1479)
						Label6:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp001[0] = µoption_string
							if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.GT(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label8
							}
							goto Label9
							// line 1480: if len(option_string) > 1:
							πF.SetLineno(1480)
						Label8:
							πTemp006 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µoption_string, πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp006, πTemp007); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label10
							}
							goto Label11
							// line 1481: if option_string[1] in self.prefix_chars:
							πF.SetLineno(1481)
						Label10:
							// line 1482: long_option_strings.append(option_string)
							πF.SetLineno(1482)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp001[0] = µoption_string
							if πE = πg.CheckLocal(πF, µlong_option_strings, "long_option_strings"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µlong_option_strings, ßappend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label11
						Label11:
							goto Label9
						Label9:
							goto Label7
						Label7:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1486: dest = dict_pop(kwargs, 'dest', None)
							πF.SetLineno(1486)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp001[0] = µkwargs
							πTemp001[1] = ßdest.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdict_pop); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdest = πTemp005
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µdest == πTemp005).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label12
							}
							goto Label13
							// line 1487: if dest is None:
							πF.SetLineno(1487)
						Label12:
							if πE = πg.CheckLocal(πF, µlong_option_strings, "long_option_strings"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µlong_option_strings); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label14
							}
							goto Label15
							// line 1488: if long_option_strings:
							πF.SetLineno(1488)
						Label14:
							// line 1489: dest_option_string = long_option_strings[0]
							πF.SetLineno(1489)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µlong_option_strings, "long_option_strings"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µlong_option_strings, πTemp002); πE != nil {
								continue
							}
							µdest_option_string = πTemp005
							goto Label16
						Label15:
							// line 1491: dest_option_string = option_strings[0]
							πF.SetLineno(1491)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µoption_strings, πTemp002); πE != nil {
								continue
							}
							µdest_option_string = πTemp005
							goto Label16
						Label16:
							// line 1492: dest = dest_option_string.lstrip(self.prefix_chars)
							πF.SetLineno(1492)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µdest_option_string, "dest_option_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µdest_option_string, ßlstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdest = πTemp005
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µdest); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label17
							}
							goto Label18
							// line 1493: if not dest:
							πF.SetLineno(1493)
						Label17:
							// line 1494: msg = _('dest= is required for options like %r')
							πF.SetLineno(1494)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("dest= is required for options like %r").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp005
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, µmsg, µoption_string); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1495: raise ValueError(msg % option_string)
							πF.SetLineno(1495)
							πE = πF.Raise(πTemp005, nil, nil)
							continue
							goto Label18
						Label18:
							// line 1496: dest = dest.replace('-', '_')
							πF.SetLineno(1496)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("-").ToObject()
							πTemp001[1] = ß_.ToObject()
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µdest, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdest = πTemp005
							goto Label13
						Label13:
							// line 1499: return dict(kwargs, dest=dest, option_strings=option_strings)
							πF.SetLineno(1499)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp001[0] = µkwargs
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_strings, "option_strings"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"dest", µdest},
								{"option_strings", µoption_strings},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp005
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_optional_kwargs.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 1501: def _pop_action_class(self, kwargs, default=None):
					πF.SetLineno(1501)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "kwargs", Def: nil}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "default", Def: πTemp016}
					πTemp015 = πg.NewFunction(πg.NewCode("_pop_action_class", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µkwargs *πg.Object = πArgs[1]; _ = µkwargs
						var µdefault *πg.Object = πArgs[2]; _ = µdefault
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1503: action = dict_pop(kwargs, 'action', default)
							πF.SetLineno(1503)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp001[0] = µkwargs
							πTemp001[1] = ßaction.ToObject()
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							πTemp001[2] = µdefault
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdict_pop); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µaction = πTemp003
							// line 1504: return self._registry_get('action', action, action)
							πF.SetLineno(1504)
							πTemp001 = πF.MakeArgs(3)
							πTemp001[0] = ßaction.ToObject()
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[1] = µaction
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[2] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_registry_get, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_pop_action_class.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 1506: def _get_handler(self):
					πF.SetLineno(1506)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp016 = πg.NewFunction(πg.NewCode("_get_handler", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µhandler_func_name *πg.Object = πg.UnboundLocal; _ = µhandler_func_name
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.BaseException
						_ = πTemp004
						var πTemp005 *πg.Traceback
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							// line 1508: handler_func_name = '_handle_conflict_%s' % self.conflict_handler
							πF.SetLineno(1508)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßconflict_handler, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("_handle_conflict_%s").ToObject(), πTemp002); πE != nil {
								continue
							}
							µhandler_func_name = πTemp001
							// line 1509: try:
							πF.SetLineno(1509)
							πF.PushCheckpoint(2)
							// line 1510: return getattr(self, handler_func_name)
							πF.SetLineno(1510)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[0] = µself
							if πE = πg.CheckLocal(πF, µhandler_func_name, "handler_func_name"); πE != nil {
								continue
							}
							πTemp003[1] = µhandler_func_name
							if πTemp001, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πR = πTemp002
							continue
							πF.PopCheckpoint()
							goto Label1
						Label2:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp004, πTemp005 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßAttributeError); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsInstance(πF, πTemp004.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label3
							}
							πE = πF.Raise(πTemp004.ToObject(), nil, πTemp005.ToObject())
							continue
							// line 1511: except AttributeError:
							πF.SetLineno(1511)
						Label3:
							// line 1512: msg = _('invalid conflict_resolution value: %r')
							πF.SetLineno(1512)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("invalid conflict_resolution value: %r").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp002
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßconflict_handler, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, µmsg, πTemp002); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1513: raise ValueError(msg % self.conflict_handler)
							πF.SetLineno(1513)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label1
						Label1:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_handler.ToObject(), πTemp016); πE != nil {
						continue
					}
					// line 1515: def _check_conflict(self, action):
					πF.SetLineno(1515)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("_check_conflict", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µconfl_optionals *πg.Object = πg.UnboundLocal; _ = µconfl_optionals
						var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
						var µconfl_optional *πg.Object = πg.UnboundLocal; _ = µconfl_optional
						var µconflict_handler *πg.Object = πg.UnboundLocal; _ = µconflict_handler
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							// line 1518: confl_optionals = []
							πF.SetLineno(1518)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µconfl_optionals = πTemp002
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µoption_string = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)            
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp006, µoption_string); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 1520: if option_string in self._option_string_actions:
							πF.SetLineno(1520)
						Label4:
							// line 1521: confl_optional = self._option_string_actions[option_string]
							πF.SetLineno(1521)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp003 = µoption_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp007, πTemp003); πE != nil {
								continue
							}
							µconfl_optional = πTemp006
							// line 1522: confl_optionals.append((option_string, confl_optional))
							πF.SetLineno(1522)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µconfl_optional, "confl_optional"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(µoption_string, µconfl_optional).ToObject()
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µconfl_optionals, "confl_optionals"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µconfl_optionals, ßappend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							if πE = πg.CheckLocal(πF, µconfl_optionals, "confl_optionals"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µconfl_optionals); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 1525: if confl_optionals:
							πF.SetLineno(1525)
						Label6:
							// line 1526: conflict_handler = self._get_handler()
							πF.SetLineno(1526)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_get_handler, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µconflict_handler = πTemp003
							// line 1527: conflict_handler(action, confl_optionals)
							πF.SetLineno(1527)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µconfl_optionals, "confl_optionals"); πE != nil {
								continue
							}
							πTemp001[1] = µconfl_optionals
							if πE = πg.CheckLocal(πF, µconflict_handler, "conflict_handler"); πE != nil {
								continue
							}
							if πTemp002, πE = µconflict_handler.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label7
						Label7:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_check_conflict.ToObject(), πTemp017); πE != nil {
						continue
					}
					// line 1529: def _handle_conflict_error(self, action, conflicting_actions):
					πF.SetLineno(1529)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp002[2] = πg.Param{Name: "conflicting_actions", Def: nil}
					πTemp018 = πg.NewFunction(πg.NewCode("_handle_conflict_error", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µconflicting_actions *πg.Object = πArgs[2]; _ = µconflicting_actions
						var µmessage *πg.Object = πg.UnboundLocal; _ = µmessage
						var µconflict_string *πg.Object = πg.UnboundLocal; _ = µconflict_string
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1530: message = _('conflicting option string(s): %s')
							πF.SetLineno(1530)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("conflicting option string(s): %s").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmessage = πTemp003
							// line 1531: conflict_string = ', '.join([option_string
							πF.SetLineno(1531)
							πTemp001 = πF.MakeArgs(1)
							πTemp004 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
								var µaction *πg.Object = πg.UnboundLocal; _ = µaction
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µconflicting_actions, "conflicting_actions"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µconflicting_actions); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp004); πE != nil {
												continue
											}
											µoption_string = πTemp005
											µaction = πTemp006
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 1531: conflict_string = ', '.join([option_string
										πF.SetLineno(1531)
										if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
											continue
										}
										πF.PushCheckpoint(4)
										return µoption_string, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr(", ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µconflict_string = πTemp005
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µconflict_string, "conflict_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, µmessage, µconflict_string); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1534: raise ArgumentError(action, message % conflict_string)
							πF.SetLineno(1534)
							πE = πF.Raise(πTemp005, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_handle_conflict_error.ToObject(), πTemp018); πE != nil {
						continue
					}
					// line 1536: def _handle_conflict_resolve(self, action, conflicting_actions):
					πF.SetLineno(1536)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp002[2] = πg.Param{Name: "conflicting_actions", Def: nil}
					πTemp019 = πg.NewFunction(πg.NewCode("_handle_conflict_resolve", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µconflicting_actions *πg.Object = πArgs[2]; _ = µconflicting_actions
						var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µconflicting_actions, "conflicting_actions"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µconflicting_actions); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp002 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp003 = !isStop
							} else {
								πTemp003 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp004); πE != nil {
									continue
								}
								µoption_string = πTemp005
								µaction = πTemp006
							}
							if πE != nil || !πTemp003 {
								continue
							}
							πF.PushCheckpoint(1)            
							// line 1543: list_remove(action.option_strings, option_string)
							πF.SetLineno(1543)
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp004
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp007[1] = µoption_string
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlist_remove); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 1545: dict_pop(self._option_string_actions, option_string, None)
							πF.SetLineno(1545)
							πTemp007 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp004
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp007[1] = µoption_string
							if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp007[2] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßdict_pop); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 1549: if not action.option_strings:
							πF.SetLineno(1549)
						Label4:
							// line 1550: action.container._remove_action(action)
							πF.SetLineno(1550)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp007[0] = µaction
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßcontainer, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ß_remove_action, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_handle_conflict_resolve.ToObject(), πTemp019); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_ActionsContainer").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_ActionsContainer.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1553: class _ArgumentGroup(_ActionsContainer):
			πF.SetLineno(1553)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ß_ActionsContainer); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_ArgumentGroup", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1555: def __init__(self, container, title=None, description=None, **kwargs):
					πF.SetLineno(1555)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "title", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "description", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µcontainer *πg.Object = πArgs[1]; _ = µcontainer
						var µtitle *πg.Object = πArgs[2]; _ = µtitle
						var µdescription *πg.Object = πArgs[3]; _ = µdescription
						var µkwargs *πg.Object = πArgs[4]; _ = µkwargs
						var µsuper_init *πg.Object = πg.UnboundLocal; _ = µsuper_init
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1561: setdefault(kwargs, 'conflict_handler', container.conflict_handler)
							πF.SetLineno(1561)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp001[0] = µkwargs
							πTemp001[1] = ßconflict_handler.ToObject()
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßconflict_handler, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetdefault); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1562: setdefault(kwargs, 'prefix_chars', container.prefix_chars)
							πF.SetLineno(1562)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp001[0] = µkwargs
							πTemp001[1] = ßprefix_chars.ToObject()
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßprefix_chars, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetdefault); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1563: setdefault(kwargs, 'argument_default', container.argument_default)
							πF.SetLineno(1563)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp001[0] = µkwargs
							πTemp001[1] = ßargument_default.ToObject()
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßargument_default, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetdefault); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1564: super_init = super(_ArgumentGroup, self).__init__
							πF.SetLineno(1564)
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_ArgumentGroup); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[1] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ß__init__, nil); πE != nil {
								continue
							}
							µsuper_init = πTemp002
							// line 1565: super_init(description=description, **kwargs)
							πF.SetLineno(1565)
							if πE = πg.CheckLocal(πF, µdescription, "description"); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"description", µdescription},
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsuper_init, "super_init"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Invoke(πF, µsuper_init, nil, nil, πTemp004, µkwargs); πE != nil {
								continue
							}
							// line 1568: self.title = title
							πF.SetLineno(1568)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µtitle); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtitle, πTemp002); πE != nil {
								continue
							}
							// line 1569: self._group_actions = []
							πF.SetLineno(1569)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_group_actions, πTemp003); πE != nil {
								continue
							}
							// line 1572: self._registries = container._registries
							πF.SetLineno(1572)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ß_registries, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_registries, πTemp003); πE != nil {
								continue
							}
							// line 1573: self._actions = container._actions
							πF.SetLineno(1573)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ß_actions, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_actions, πTemp003); πE != nil {
								continue
							}
							// line 1574: self._option_string_actions = container._option_string_actions
							πF.SetLineno(1574)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_option_string_actions, πTemp003); πE != nil {
								continue
							}
							// line 1575: self._defaults = container._defaults
							πF.SetLineno(1575)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ß_defaults, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_defaults, πTemp003); πE != nil {
								continue
							}
							// line 1576: self._has_negative_number_optionals = \
							πF.SetLineno(1576)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ß_has_negative_number_optionals, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_has_negative_number_optionals, πTemp003); πE != nil {
								continue
							}
							// line 1578: self._mutually_exclusive_groups = container._mutually_exclusive_groups
							πF.SetLineno(1578)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ß_mutually_exclusive_groups, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_mutually_exclusive_groups, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1580: def _add_action(self, action):
					πF.SetLineno(1580)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("_add_action", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1581: action = super(_ArgumentGroup, self)._add_action(action)
							πF.SetLineno(1581)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							πTemp002 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_ArgumentGroup); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[1] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ß_add_action, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µaction = πTemp004
							// line 1582: self._group_actions.append(action)
							πF.SetLineno(1582)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_group_actions, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1583: return action
							πF.SetLineno(1583)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πR = µaction
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_add_action.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1585: def _remove_action(self, action):
					πF.SetLineno(1585)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("_remove_action", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []πg.Param
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1586: super(_ArgumentGroup, self)._remove_action(action)
							πF.SetLineno(1586)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							πTemp002 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_ArgumentGroup); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[1] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ß_remove_action, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1588: self._group_actions = [x for x in self._group_actions if x != action]
							πF.SetLineno(1588)
							πTemp005 = make([]πg.Param, 0)
							πTemp004 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µx *πg.Object = πg.UnboundLocal; _ = µx
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µself, ß_group_actions, nil); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp003 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp003 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp004 = !isStop
										} else {
											πTemp004 = true
											µx = πTemp002
										}
										if πE != nil || !πTemp004 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.NE(πF, µx, µaction); πE != nil {
											continue
										}
										if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
											continue
										}
										if πTemp004 {
											goto Label4
										}
										goto Label5
										// line 1588: self._group_actions = [x for x in self._group_actions if x != action]
										πF.SetLineno(1588)
									Label4:
										// line 1588: self._group_actions = [x for x in self._group_actions if x != action]
										πF.SetLineno(1588)
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										πF.PushCheckpoint(6)
										return µx, nil
									Label6:
										πTemp002 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp006, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ListType.Call(πF, πg.Args{πTemp006}, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_group_actions, πTemp006); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_remove_action.ToObject(), πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_ArgumentGroup").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_ArgumentGroup.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1591: class _MutuallyExclusiveGroup(_ArgumentGroup):
			πF.SetLineno(1591)
			πTemp001 = make([]*πg.Object, 1)
			if πTemp012, πE = πg.ResolveGlobal(πF, ß_ArgumentGroup); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("_MutuallyExclusiveGroup", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1593: def __init__(self, container, required=False):
					πF.SetLineno(1593)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "required", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µcontainer *πg.Object = πArgs[1]; _ = µcontainer
						var µrequired *πg.Object = πArgs[2]; _ = µrequired
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1594: super(_MutuallyExclusiveGroup, self).__init__(container)
							πF.SetLineno(1594)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							πTemp002 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_MutuallyExclusiveGroup); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[1] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1595: self.required = required
							πF.SetLineno(1595)
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µrequired); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßrequired, πTemp003); πE != nil {
								continue
							}
							// line 1596: self._container = container
							πF.SetLineno(1596)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µcontainer); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_container, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1598: def _add_action(self, action):
					πF.SetLineno(1598)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("_add_action", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßrequired, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1599: if action.required:
							πF.SetLineno(1599)
						Label1:
							// line 1600: msg = _('mutually exclusive arguments must be optional')
							πF.SetLineno(1600)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("mutually exclusive arguments must be optional").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp004
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[0] = µmsg
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1601: raise ValueError(msg)
							πF.SetLineno(1601)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
							goto Label2
						Label2:
							// line 1602: action = self._container._add_action(action)
							πF.SetLineno(1602)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_container, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ß_add_action, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µaction = πTemp001
							// line 1603: self._group_actions.append(action)
							πF.SetLineno(1603)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_group_actions, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßappend, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1604: return action
							πF.SetLineno(1604)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πR = µaction
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_add_action.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1606: def _remove_action(self, action):
					πF.SetLineno(1606)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("_remove_action", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1607: self._container._remove_action(action)
							πF.SetLineno(1607)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_container, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß_remove_action, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1609: self._group_actions = [x for x in self._group_actions if x != action]
							πF.SetLineno(1609)
							πTemp004 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µx *πg.Object = πg.UnboundLocal; _ = µx
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µself, ß_group_actions, nil); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp003 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp003 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp004 = !isStop
										} else {
											πTemp004 = true
											µx = πTemp002
										}
										if πE != nil || !πTemp004 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.NE(πF, µx, µaction); πE != nil {
											continue
										}
										if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
											continue
										}
										if πTemp004 {
											goto Label4
										}
										goto Label5
										// line 1609: self._group_actions = [x for x in self._group_actions if x != action]
										πF.SetLineno(1609)
									Label4:
										// line 1609: self._group_actions = [x for x in self._group_actions if x != action]
										πF.SetLineno(1609)
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										πF.PushCheckpoint(6)
										return µx, nil
									Label6:
										πTemp002 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_group_actions, πTemp005); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_remove_action.ToObject(), πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("_MutuallyExclusiveGroup").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ß_MutuallyExclusiveGroup.ToObject(), πTemp012); πE != nil {
				continue
			}
			// line 1612: class ArgumentParser(_AttributeHolder, _ActionsContainer):
			πF.SetLineno(1612)
			πTemp001 = make([]*πg.Object, 2)
			if πTemp012, πE = πg.ResolveGlobal(πF, ß_AttributeHolder); πE != nil {
				continue
			}
			πTemp001[0] = πTemp012
			if πTemp012, πE = πg.ResolveGlobal(πF, ß_ActionsContainer); πE != nil {
				continue
			}
			πTemp001[1] = πTemp012
			πTemp008 = πg.NewDict()
			if πTemp010, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp008.SetItem(πF, ß__module__.ToObject(), πTemp010); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ArgumentParser", "build/src/__python__/argparse.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp008
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 []*πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 *πg.Object
				_ = πTemp019
				var πTemp020 *πg.Object
				_ = πTemp020
				var πTemp021 *πg.Object
				_ = πTemp021
				var πTemp022 *πg.Object
				_ = πTemp022
				var πTemp023 *πg.Object
				_ = πTemp023
				var πTemp024 *πg.Object
				_ = πTemp024
				var πTemp025 *πg.Object
				_ = πTemp025
				var πTemp026 *πg.Object
				_ = πTemp026
				var πTemp027 *πg.Object
				_ = πTemp027
				var πTemp028 *πg.Object
				_ = πTemp028
				var πTemp029 *πg.Object
				_ = πTemp029
				var πTemp030 *πg.Object
				_ = πTemp030
				var πTemp031 *πg.Object
				_ = πTemp031
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default: panic("unexpected function state")
					}
					// line 1613: """Object for parsing command line strings into Python objects.
					πF.SetLineno(1613)
					// line 1630: def __init__(self,
					πF.SetLineno(1630)
					πTemp002 = make([]πg.Param, 13)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "prog", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "usage", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "description", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "epilog", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "version", Def: πTemp003}
					πTemp004 = make([]*πg.Object, 0)
					πTemp003 = πg.NewList(πTemp004...).ToObject()
					πTemp002[6] = πg.Param{Name: "parents", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßHelpFormatter); πE != nil {
						continue
					}
					πTemp002[7] = πg.Param{Name: "formatter_class", Def: πTemp003}
					πTemp002[8] = πg.Param{Name: "prefix_chars", Def: πg.NewStr("-").ToObject()}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[9] = πg.Param{Name: "fromfile_prefix_chars", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[10] = πg.Param{Name: "argument_default", Def: πTemp003}
					πTemp002[11] = πg.Param{Name: "conflict_handler", Def: ßerror.ToObject()}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					πTemp002[12] = πg.Param{Name: "add_help", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µprog *πg.Object = πArgs[1]; _ = µprog
						var µusage *πg.Object = πArgs[2]; _ = µusage
						var µdescription *πg.Object = πArgs[3]; _ = µdescription
						var µepilog *πg.Object = πArgs[4]; _ = µepilog
						var µversion *πg.Object = πArgs[5]; _ = µversion
						var µparents *πg.Object = πArgs[6]; _ = µparents
						var µformatter_class *πg.Object = πArgs[7]; _ = µformatter_class
						var µprefix_chars *πg.Object = πArgs[8]; _ = µprefix_chars
						var µfromfile_prefix_chars *πg.Object = πArgs[9]; _ = µfromfile_prefix_chars
						var µargument_default *πg.Object = πArgs[10]; _ = µargument_default
						var µconflict_handler *πg.Object = πArgs[11]; _ = µconflict_handler
						var µadd_help *πg.Object = πArgs[12]; _ = µadd_help
						var µsuperinit *πg.Object = πg.UnboundLocal; _ = µsuperinit
						var µadd_group *πg.Object = πg.UnboundLocal; _ = µadd_group
						var µidentity *πg.Object = πg.UnboundLocal; _ = µidentity
						var µdefault_prefix *πg.Object = πg.UnboundLocal; _ = µdefault_prefix
						var µparent *πg.Object = πg.UnboundLocal; _ = µparent
						var µdefaults *πg.Object = πg.UnboundLocal; _ = µdefaults
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 []πg.Param
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 bool
						_ = πTemp011
						var πTemp012 *πg.BaseException
						_ = πTemp012
						var πTemp013 *πg.Traceback
						_ = πTemp013
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 9: goto Label9
							case 10: goto Label10
							case 13: goto Label13
							default: panic("unexpected function state")
							}
							// line 1652: superinit = super(ArgumentParser, self).__init__
							πF.SetLineno(1652)
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßArgumentParser); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[1] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsuper); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ß__init__, nil); πE != nil {
								continue
							}
							µsuperinit = πTemp002
							// line 1653: superinit(description=description,
							πF.SetLineno(1653)
							if πE = πg.CheckLocal(πF, µdescription, "description"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µprefix_chars, "prefix_chars"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargument_default, "argument_default"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µconflict_handler, "conflict_handler"); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"description", µdescription},
								{"prefix_chars", µprefix_chars},
								{"argument_default", µargument_default},
								{"conflict_handler", µconflict_handler},
							}
							if πE = πg.CheckLocal(πF, µsuperinit, "superinit"); πE != nil {
								continue
							}
							if πTemp002, πE = µsuperinit.Call(πF, nil, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µprog == πTemp003).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1659: if prog is None:
							πF.SetLineno(1659)
						Label1:
							// line 1660: prog = _os.path.basename(_sys.argv[0])
							πF.SetLineno(1660)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πg.NewInt(0).ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßargv, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp007, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_os); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßpath, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßbasename, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µprog = πTemp003
							goto Label2
						Label2:
							// line 1662: self.prog = prog
							πF.SetLineno(1662)
							if πE = πg.CheckLocal(πF, µprog, "prog"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µprog); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßprog, πTemp002); πE != nil {
								continue
							}
							// line 1663: self.usage = usage
							πF.SetLineno(1663)
							if πE = πg.CheckLocal(πF, µusage, "usage"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µusage); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßusage, πTemp002); πE != nil {
								continue
							}
							// line 1664: self.epilog = epilog
							πF.SetLineno(1664)
							if πE = πg.CheckLocal(πF, µepilog, "epilog"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µepilog); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßepilog, πTemp002); πE != nil {
								continue
							}
							// line 1665: self.version = version
							πF.SetLineno(1665)
							if πE = πg.CheckLocal(πF, µversion, "version"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µversion); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßversion, πTemp002); πE != nil {
								continue
							}
							// line 1666: self.formatter_class = formatter_class
							πF.SetLineno(1666)
							if πE = πg.CheckLocal(πF, µformatter_class, "formatter_class"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µformatter_class); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßformatter_class, πTemp002); πE != nil {
								continue
							}
							// line 1667: self.fromfile_prefix_chars = fromfile_prefix_chars
							πF.SetLineno(1667)
							if πE = πg.CheckLocal(πF, µfromfile_prefix_chars, "fromfile_prefix_chars"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µfromfile_prefix_chars); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfromfile_prefix_chars, πTemp002); πE != nil {
								continue
							}
							// line 1668: self.add_help = add_help
							πF.SetLineno(1668)
							if πE = πg.CheckLocal(πF, µadd_help, "add_help"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µadd_help); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßadd_help, πTemp002); πE != nil {
								continue
							}
							// line 1670: add_group = self.add_argument_group
							πF.SetLineno(1670)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd_argument_group, nil); πE != nil {
								continue
							}
							µadd_group = πTemp002
							// line 1671: self._positionals = add_group(_('positional arguments'))
							πF.SetLineno(1671)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							πTemp008[0] = πg.NewStr("positional arguments").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µadd_group, "add_group"); πE != nil {
								continue
							}
							if πTemp002, πE = µadd_group.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_positionals, πTemp003); πE != nil {
								continue
							}
							// line 1672: self._optionals = add_group(_('optional arguments'))
							πF.SetLineno(1672)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							πTemp008[0] = πg.NewStr("optional arguments").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µadd_group, "add_group"); πE != nil {
								continue
							}
							if πTemp002, πE = µadd_group.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_optionals, πTemp003); πE != nil {
								continue
							}
							// line 1673: self._subparsers = None
							πF.SetLineno(1673)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_subparsers, πTemp003); πE != nil {
								continue
							}
							// line 1676: def identity(string):
							πF.SetLineno(1676)
							πTemp009 = make([]πg.Param, 1)
							πTemp009[0] = πg.Param{Name: "string", Def: nil}
							πTemp002 = πg.NewFunction(πg.NewCode("identity", "build/src/__python__/argparse.py", πTemp009, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µstring *πg.Object = πArgs[0]; _ = µstring
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default: panic("unexpected function state")
									}
									// line 1677: return string
									πF.SetLineno(1677)
									if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
										continue
									}
									πR = µstring
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µidentity = πTemp002
							// line 1678: self.register('type', None, identity)
							πF.SetLineno(1678)
							πTemp001 = πF.MakeArgs(3)
							πTemp001[0] = ßtype.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µidentity, "identity"); πE != nil {
								continue
							}
							πTemp001[2] = µidentity
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßregister, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1682: default_prefix = '-' if '-' in prefix_chars else prefix_chars[0]
							πF.SetLineno(1682)
							if πE = πg.CheckLocal(πF, µprefix_chars, "prefix_chars"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µprefix_chars, πg.NewStr("-").ToObject()); πE != nil {
								continue
							}
							πTemp006 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label3
							}
							πTemp003 = πg.NewStr("-").ToObject()
							goto Label4
						Label3:
							πTemp006 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µprefix_chars, "prefix_chars"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µprefix_chars, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πTemp007
						Label4:
							µdefault_prefix = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßadd_help, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 1683: if self.add_help:
							πF.SetLineno(1683)
						Label5:
							// line 1684: self.add_argument(
							πF.SetLineno(1684)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdefault_prefix, "default_prefix"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µdefault_prefix, ßh.ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µdefault_prefix, "default_prefix"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Mul(πF, µdefault_prefix, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp006, ßhelp.ToObject()); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp008 = πF.MakeArgs(1)
							πTemp008[0] = πg.NewStr("show this help message and exit").ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp004 = πg.KWArgs{
								{"action", ßhelp.ToObject()},
								{"default", πTemp003},
								{"help", πTemp007},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßadd_argument, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
						Label6:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßversion, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							goto Label8
							// line 1688: if self.version:
							πF.SetLineno(1688)
						Label7:
							// line 1689: self.add_argument(
							πF.SetLineno(1689)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdefault_prefix, "default_prefix"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µdefault_prefix, ßv.ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µdefault_prefix, "default_prefix"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Mul(πF, µdefault_prefix, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp006, ßversion.ToObject()); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßversion, nil); πE != nil {
								continue
							}
							πTemp008 = πF.MakeArgs(1)
							πTemp008[0] = πg.NewStr("show program's version number and exit").ToObject()
							if πTemp007, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp007.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp004 = πg.KWArgs{
								{"action", ßversion.ToObject()},
								{"default", πTemp003},
								{"version", πTemp006},
								{"help", πTemp010},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßadd_argument, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label8
						Label8:
							if πE = πg.CheckLocal(πF, µparents, "parents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Iter(πF, µparents); πE != nil {
								continue
							}
							πF.PushCheckpoint(10)
							πTemp005 = false
						Label9:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label11
							}
							if πTemp006, πE = πg.Next(πF, πTemp003); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp011 = !isStop
							} else {
								πTemp011 = true
								µparent = πTemp006
							}
							if πE != nil || !πTemp011 {
								continue
							}
							πF.PushCheckpoint(9)            
							// line 1697: self._add_container_actions(parent)
							πF.SetLineno(1697)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparent, "parent"); πE != nil {
								continue
							}
							πTemp001[0] = µparent
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_add_container_actions, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1698: try:
							πF.SetLineno(1698)
							πF.PushCheckpoint(13)
							// line 1699: defaults = parent._defaults
							πF.SetLineno(1699)
							if πE = πg.CheckLocal(πF, µparent, "parent"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µparent, ß_defaults, nil); πE != nil {
								continue
							}
							µdefaults = πTemp006
							πF.PopCheckpoint()
							// line 1703: self._defaults.update(defaults)
							πF.SetLineno(1703)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdefaults, "defaults"); πE != nil {
								continue
							}
							πTemp001[0] = µdefaults
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_defaults, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßupdate, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label12
						Label13:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp012, πTemp013 = πF.ExcInfo()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßAttributeError); πE != nil {
								continue
							}
							if πTemp011, πE = πg.IsInstance(πF, πTemp012.ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp011 {
								goto Label14
							}
							πE = πF.Raise(πTemp012.ToObject(), nil, πTemp013.ToObject())
							continue
							// line 1700: except AttributeError:
							πF.SetLineno(1700)
						Label14:
							// line 1701: pass
							πF.SetLineno(1701)
							πF.RestoreExc(nil, nil)
							goto Label12
						Label12:
							continue
						Label10:
							if πE != nil || πR != nil {
								continue
							}
						Label11:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1708: def _get_kwargs(self):
					πF.SetLineno(1708)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("_get_kwargs", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µnames *πg.Object = πg.UnboundLocal; _ = µnames
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1709: names = [
							πF.SetLineno(1709)
							πTemp001 = make([]*πg.Object, 7)
							πTemp001[0] = ßprog.ToObject()
							πTemp001[1] = ßusage.ToObject()
							πTemp001[2] = ßdescription.ToObject()
							πTemp001[3] = ßversion.ToObject()
							πTemp001[4] = ßformatter_class.ToObject()
							πTemp001[5] = ßconflict_handler.ToObject()
							πTemp001[6] = ßadd_help.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µnames = πTemp002
							// line 1718: return [(name, getattr(self, name)) for name in names]
							πF.SetLineno(1718)
							πTemp004 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µname *πg.Object = πg.UnboundLocal; _ = µname
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πTemp007 *πg.Object
								_ = πTemp007
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µnames, "names"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µnames); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µname = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 1718: return [(name, getattr(self, name)) for name in names]
										πF.SetLineno(1718)
										if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
											continue
										}
										πTemp005 = πF.MakeArgs(2)
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										πTemp005[0] = µself
										if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
											continue
										}
										πTemp005[1] = µname
										if πTemp006, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
											continue
										}
										if πTemp007, πE = πTemp006.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πTemp004 = πg.NewTuple2(µname, πTemp007).ToObject()
										πF.PushCheckpoint(4)
										return πTemp004, nil
									Label4:
										πTemp006 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_kwargs.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1723: def add_subparsers(self, **kwargs):
					πF.SetLineno(1723)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("add_subparsers", "build/src/__python__/argparse.py", πTemp002, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µkwargs *πg.Object = πArgs[1]; _ = µkwargs
						var µtitle *πg.Object = πg.UnboundLocal; _ = µtitle
						var µdescription *πg.Object = πg.UnboundLocal; _ = µdescription
						var µformatter *πg.Object = πg.UnboundLocal; _ = µformatter
						var µpositionals *πg.Object = πg.UnboundLocal; _ = µpositionals
						var µgroups *πg.Object = πg.UnboundLocal; _ = µgroups
						var µparsers_class *πg.Object = πg.UnboundLocal; _ = µparsers_class
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 πg.KWArgs
						_ = πTemp008
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_subparsers, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 != πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1724: if self._subparsers is not None:
							πF.SetLineno(1724)
						Label1:
							// line 1725: self.error(_('cannot have multiple subparser arguments'))
							πF.SetLineno(1725)
							πTemp005 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("cannot have multiple subparser arguments").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label2
						Label2:
							// line 1729: setdefault(kwargs, 'parser_class', type(self))
							πF.SetLineno(1729)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp005[0] = µkwargs
							πTemp005[1] = ßparser_class.ToObject()
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp006[0] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßtype); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[2] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsetdefault); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µkwargs, ßtitle.ToObject()); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp007).ToObject()
							πTemp001 = πTemp002
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µkwargs, ßdescription.ToObject()); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp007).ToObject()
							πTemp001 = πTemp002
						Label3:
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 1731: if 'title' in kwargs or 'description' in kwargs:
							πF.SetLineno(1731)
						Label4:
							// line 1733: title = dict_pop(kwargs, 'title', 'subcommands')
							πF.SetLineno(1733)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp005[0] = µkwargs
							πTemp005[1] = ßtitle.ToObject()
							πTemp005[2] = ßsubcommands.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdict_pop); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µtitle = πTemp002
							// line 1735: description = dict_pop(kwargs, 'description', None)
							πF.SetLineno(1735)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp005[0] = µkwargs
							πTemp005[1] = ßdescription.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp005[2] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdict_pop); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µdescription = πTemp002
							// line 1736: self._subparsers = self.add_argument_group(title, description)
							πF.SetLineno(1736)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							πTemp005[0] = µtitle
							if πE = πg.CheckLocal(πF, µdescription, "description"); πE != nil {
								continue
							}
							πTemp005[1] = µdescription
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßadd_argument_group, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_subparsers, πTemp001); πE != nil {
								continue
							}
							goto Label6
						Label5:
							// line 1738: self._subparsers = self._positionals
							πF.SetLineno(1738)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_positionals, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ß_subparsers, πTemp002); πE != nil {
								continue
							}
							goto Label6
						Label6:
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = ßprog.ToObject()
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µkwargs, ßget, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp003 == πTemp002).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label7
							}
							goto Label8
							// line 1742: if kwargs.get('prog') is None:
							πF.SetLineno(1742)
						Label7:
							// line 1743: formatter = self._get_formatter()
							πF.SetLineno(1743)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_formatter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µformatter = πTemp002
							// line 1744: positionals = self._get_positional_actions()
							πF.SetLineno(1744)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_positional_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µpositionals = πTemp002
							// line 1745: groups = self._mutually_exclusive_groups
							πF.SetLineno(1745)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_mutually_exclusive_groups, nil); πE != nil {
								continue
							}
							µgroups = πTemp001
							// line 1746: formatter.add_usage(self.usage, positionals, groups, '')
							πF.SetLineno(1746)
							πTemp005 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßusage, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
								continue
							}
							πTemp005[1] = µpositionals
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							πTemp005[2] = µgroups
							πTemp005[3] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßadd_usage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 1747: kwargs['prog'] = formatter.format_help().strip()
							πF.SetLineno(1747)
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßformat_help, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp003 = ßprog.ToObject()
							if πE = πg.SetItem(πF, µkwargs, πTemp003, πTemp001); πE != nil {
								continue
							}
							goto Label8
						Label8:
							// line 1750: parsers_class = self._pop_action_class(kwargs, 'parsers')
							πF.SetLineno(1750)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							πTemp005[0] = µkwargs
							πTemp005[1] = ßparsers.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_pop_action_class, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µparsers_class = πTemp002
							// line 1751: action = parsers_class(option_strings=[], **kwargs)
							πF.SetLineno(1751)
							πTemp005 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							πTemp008 = πg.KWArgs{
								{"option_strings", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µkwargs, "kwargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparsers_class, "parsers_class"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Invoke(πF, µparsers_class, nil, nil, πTemp008, µkwargs); πE != nil {
								continue
							}
							µaction = πTemp001
							// line 1752: self._subparsers._add_action(action)
							πF.SetLineno(1752)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp005[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_subparsers, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ß_add_action, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 1755: return action
							πF.SetLineno(1755)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πR = µaction
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_subparsers.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1757: def _add_action(self, action):
					πF.SetLineno(1757)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("_add_action", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1758: if action.option_strings:
							πF.SetLineno(1758)
						Label1:
							// line 1759: self._optionals._add_action(action)
							πF.SetLineno(1759)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_optionals, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ß_add_action, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label3
						Label2:
							// line 1761: self._positionals._add_action(action)
							πF.SetLineno(1761)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_positionals, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ß_add_action, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label3
						Label3:
							// line 1762: return action
							πF.SetLineno(1762)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πR = µaction
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_add_action.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1764: def _get_optional_actions(self):
					πF.SetLineno(1764)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("_get_optional_actions", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1765: return [action
							πF.SetLineno(1765)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µaction *πg.Object = πg.UnboundLocal; _ = µaction
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp003 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp003 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp004 = !isStop
										} else {
											πTemp004 = true
											µaction = πTemp002
										}
										if πE != nil || !πTemp004 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
											continue
										}
										if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
											continue
										}
										if πTemp004 {
											goto Label4
										}
										goto Label5
										// line 1765: return [action
										πF.SetLineno(1765)
									Label4:
										// line 1765: return [action
										πF.SetLineno(1765)
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										πF.PushCheckpoint(6)
										return µaction, nil
									Label6:
										πTemp002 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_optional_actions.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 1769: def _get_positional_actions(self):
					πF.SetLineno(1769)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("_get_positional_actions", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1770: return [action
							πF.SetLineno(1770)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µaction *πg.Object = πg.UnboundLocal; _ = µaction
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp003 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp003 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp004 = !isStop
										} else {
											πTemp004 = true
											µaction = πTemp002
										}
										if πE != nil || !πTemp004 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										if πTemp005, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
											continue
										}
										if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
											continue
										}
										πTemp002 = πg.GetBool(!πTemp004).ToObject()
										if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
											continue
										}
										if πTemp004 {
											goto Label4
										}
										goto Label5
										// line 1770: return [action
										πF.SetLineno(1770)
									Label4:
										// line 1770: return [action
										πF.SetLineno(1770)
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										πF.PushCheckpoint(6)
										return µaction, nil
									Label6:
										πTemp002 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_positional_actions.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 1777: def parse_args(self, args=None, namespace=None):
					πF.SetLineno(1777)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "args", Def: πTemp010}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "namespace", Def: πTemp010}
					πTemp009 = πg.NewFunction(πg.NewCode("parse_args", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µargs *πg.Object = πArgs[1]; _ = µargs
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µargv *πg.Object = πg.UnboundLocal; _ = µargv
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 1778: args, argv = self.parse_known_args(args, namespace)
							πF.SetLineno(1778)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001[0] = µargs
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp001[1] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparse_known_args, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µargs = πTemp002
							µargv = πTemp004
							if πE = πg.CheckLocal(πF, µargv, "argv"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µargv); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1779: if argv:
							πF.SetLineno(1779)
						Label1:
							// line 1780: msg = _('unrecognized arguments: %s')
							πF.SetLineno(1780)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("unrecognized arguments: %s").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp003
							// line 1781: self.error(msg % ' '.join(argv))
							πF.SetLineno(1781)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargv, "argv"); πE != nil {
								continue
							}
							πTemp006[0] = µargv
							if πTemp003, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Mod(πF, µmsg, πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label2
						Label2:
							// line 1782: return args
							πF.SetLineno(1782)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πR = µargs
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_args.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 1784: def parse_known_args(self, args=None, namespace=None):
					πF.SetLineno(1784)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "args", Def: πTemp011}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "namespace", Def: πTemp011}
					πTemp010 = πg.NewFunction(πg.NewCode("parse_known_args", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µargs *πg.Object = πArgs[1]; _ = µargs
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var µdest *πg.Object = πg.UnboundLocal; _ = µdest
						var µerr *πg.Object = πg.UnboundLocal; _ = µerr
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.BaseException
						_ = πTemp008
						var πTemp009 *πg.Traceback
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 16: goto Label16
							case 15: goto Label15
							case 21: goto Label21
							case 6: goto Label6
							case 7: goto Label7
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µargs == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1785: if args is None:
							πF.SetLineno(1785)
						Label1:
							// line 1787: args = _sys.argv[1:]
							πF.SetLineno(1787)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßargv, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							µargs = πTemp002
							goto Label3
						Label2:
							// line 1790: args = list(args)
							πF.SetLineno(1790)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp006[0] = µargs
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µargs = πTemp002
							goto Label3
						Label3:
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µnamespace == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 1793: if namespace is None:
							πF.SetLineno(1793)
						Label4:
							// line 1794: namespace = Namespace()
							πF.SetLineno(1794)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNamespace); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µnamespace = πTemp002
							goto Label5
						Label5:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp003 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µaction = πTemp002
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(6)            
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004 != πTemp005).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label9
							}
							goto Label10
							// line 1798: if action.dest is not SUPPRESS:
							πF.SetLineno(1798)
						Label9:
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp006[0] = µnamespace
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							πTemp006[1] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp007, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label11
							}
							goto Label12
							// line 1799: if not hasattr(namespace, action.dest):
							πF.SetLineno(1799)
						Label11:
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004 != πTemp005).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label13
							}
							goto Label14
							// line 1800: if action.default is not SUPPRESS:
							πF.SetLineno(1800)
						Label13:
							// line 1801: setattr(namespace, action.dest, action.default)
							πF.SetLineno(1801)
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp006[0] = µnamespace
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							πTemp006[1] = πTemp002
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							πTemp006[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							goto Label14
						Label14:
							goto Label12
						Label12:
							goto Label10
						Label10:
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_defaults, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(16)
							πTemp003 = false
						Label15:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label17
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µdest = πTemp002
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(15)            
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp006[0] = µnamespace
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							πTemp006[1] = µdest
							if πTemp004, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp007, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label18
							}
							goto Label19
							// line 1805: if not hasattr(namespace, dest):
							πF.SetLineno(1805)
						Label18:
							// line 1806: setattr(namespace, dest, self._defaults[dest])
							πF.SetLineno(1806)
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp006[0] = µnamespace
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							πTemp006[1] = µdest
							if πE = πg.CheckLocal(πF, µdest, "dest"); πE != nil {
								continue
							}
							πTemp002 = µdest
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ß_defaults, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp006[2] = πTemp004
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							goto Label19
						Label19:
							continue
						Label16:
							if πE != nil || πR != nil {
								continue
							}
						Label17:
							// line 1809: try:
							πF.SetLineno(1809)
							πF.PushCheckpoint(21)
							// line 1810: namespace, args = self._parse_known_args(args, namespace)
							πF.SetLineno(1810)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp006[0] = µargs
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp006[1] = µnamespace
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_parse_known_args, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µnamespace = πTemp001
							µargs = πTemp004
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp006[0] = µnamespace
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_UNRECOGNIZED_ARGS_ATTR); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label22
							}
							goto Label23
							// line 1811: if hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR):
							πF.SetLineno(1811)
						Label22:
							// line 1813: args += (getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))
							πF.SetLineno(1813)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp006[0] = µnamespace
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_UNRECOGNIZED_ARGS_ATTR); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.IAdd(πF, µargs, πTemp002); πE != nil {
								continue
							}
							µargs = πTemp001
							// line 1815: del namespace.__dict__[_UNRECOGNIZED_ARGS_ATTR]
							πF.SetLineno(1815)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µnamespace, ß__dict__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_UNRECOGNIZED_ARGS_ATTR); πE != nil {
								continue
							}
							πTemp002 = πTemp004
							if πE = πg.DelItem(πF, πTemp001, πTemp002); πE != nil {
								continue
							}
							goto Label23
						Label23:
							// line 1816: return namespace, args
							πF.SetLineno(1816)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µnamespace, µargs).ToObject()
							πR = πTemp001
							continue
							πF.PopCheckpoint()
							goto Label20
						Label21:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp008, πTemp009 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsInstance(πF, πTemp008.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label24
							}
							πE = πF.Raise(πTemp008.ToObject(), nil, πTemp009.ToObject())
							continue
							// line 1817: except ArgumentError:
							πF.SetLineno(1817)
						Label24:
							// line 1818: err = _sys.exc_info()[1]
							πF.SetLineno(1818)
							πTemp001 = πg.NewInt(1).ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßexc_info, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µerr = πTemp002
							// line 1819: self.error(str(err))
							πF.SetLineno(1819)
							πTemp006 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µerr, "err"); πE != nil {
								continue
							}
							πTemp010[0] = µerr
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp006[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πF.RestoreExc(nil, nil)
							goto Label20
						Label20:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_known_args.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 1821: def _parse_known_args(self, arg_strings, namespace):
					πF.SetLineno(1821)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "arg_strings", Def: nil}
					πTemp002[2] = πg.Param{Name: "namespace", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("_parse_known_args", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µarg_strings *πg.Object = πArgs[1]; _ = µarg_strings
						var µnamespace *πg.Object = πArgs[2]; _ = µnamespace
						var µaction_conflicts *πg.Object = πg.UnboundLocal; _ = µaction_conflicts
						var µmutex_group *πg.Object = πg.UnboundLocal; _ = µmutex_group
						var µgroup_actions *πg.Object = πg.UnboundLocal; _ = µgroup_actions
						var µi *πg.Object = πg.UnboundLocal; _ = µi
						var µmutex_action *πg.Object = πg.UnboundLocal; _ = µmutex_action
						var µconflicts *πg.Object = πg.UnboundLocal; _ = µconflicts
						var µoption_string_indices *πg.Object = πg.UnboundLocal; _ = µoption_string_indices
						var µarg_string_pattern_parts *πg.Object = πg.UnboundLocal; _ = µarg_string_pattern_parts
						var µarg_strings_iter *πg.Object = πg.UnboundLocal; _ = µarg_strings_iter
						var µarg_string *πg.Object = πg.UnboundLocal; _ = µarg_string
						var µoption_tuple *πg.Object = πg.UnboundLocal; _ = µoption_tuple
						var µpattern *πg.Object = πg.UnboundLocal; _ = µpattern
						var µarg_strings_pattern *πg.Object = πg.UnboundLocal; _ = µarg_strings_pattern
						var µseen_actions *πg.Object = πg.UnboundLocal; _ = µseen_actions
						var µseen_non_default_actions *πg.Object = πg.UnboundLocal; _ = µseen_non_default_actions
						var µtake_action *πg.Object = πg.UnboundLocal; _ = µtake_action
						var µconsume_optional *πg.Object = πg.UnboundLocal; _ = µconsume_optional
						var µpositionals *πg.Object = πg.UnboundLocal; _ = µpositionals
						var µconsume_positionals *πg.Object = πg.UnboundLocal; _ = µconsume_positionals
						var µextras *πg.Object = πg.UnboundLocal; _ = µextras
						var µstart_index *πg.Object = πg.UnboundLocal; _ = µstart_index
						var µmax_option_string_index *πg.Object = πg.UnboundLocal; _ = µmax_option_string_index
						var µnext_option_string_index *πg.Object = πg.UnboundLocal; _ = µnext_option_string_index
						var µpositionals_end_index *πg.Object = πg.UnboundLocal; _ = µpositionals_end_index
						var µstrings *πg.Object = πg.UnboundLocal; _ = µstrings
						var µstop_index *πg.Object = πg.UnboundLocal; _ = µstop_index
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var µname *πg.Object = πg.UnboundLocal; _ = µname
						var µgroup *πg.Object = πg.UnboundLocal; _ = µgroup
						var µnames *πg.Object = πg.UnboundLocal; _ = µnames
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Dict
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 []*πg.Object
						_ = πTemp011
						var πTemp012 []πg.Param
						_ = πTemp012
						var πTemp013 *πg.Object
						_ = πTemp013
						var πTemp014 *πg.Object
						_ = πTemp014
						var πTemp015 *πg.Object
						_ = πTemp015
						var πTemp016 *πg.Object
						_ = πTemp016
						var πTemp017 *πg.Object
						_ = πTemp017
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3: goto Label3
							case 4: goto Label4
							case 37: goto Label37
							case 6: goto Label6
							case 7: goto Label7
							case 9: goto Label9
							case 10: goto Label10
							case 45: goto Label45
							case 46: goto Label46
							case 15: goto Label15
							case 16: goto Label16
							case 50: goto Label50
							case 51: goto Label51
							case 24: goto Label24
							case 25: goto Label25
							case 36: goto Label36
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfromfile_prefix_chars, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 != πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1823: if self.fromfile_prefix_chars is not None:
							πF.SetLineno(1823)
						Label1:
							// line 1824: arg_strings = self._read_args_from_files(arg_strings)
							πF.SetLineno(1824)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							πTemp005[0] = µarg_strings
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_read_args_from_files, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µarg_strings = πTemp002
							goto Label2
						Label2:
							// line 1828: action_conflicts = {}
							πF.SetLineno(1828)
							πTemp006 = πg.NewDict()
							πTemp001 = πTemp006.ToObject()
							µaction_conflicts = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_mutually_exclusive_groups, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp004 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µmutex_group = πTemp002
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(3)            
							// line 1830: group_actions = mutex_group._group_actions
							πF.SetLineno(1830)
							if πE = πg.CheckLocal(πF, µmutex_group, "mutex_group"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmutex_group, ß_group_actions, nil); πE != nil {
								continue
							}
							µgroup_actions = πTemp002
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmutex_group, "mutex_group"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmutex_group, ß_group_actions, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßenumerate); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp002, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp007 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp009 = !isStop
							} else {
								πTemp009 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp008}, πg.TieTarget{Target: &πTemp010}}}, πTemp003); πE != nil {
									continue
								}
								µi = πTemp008
								µmutex_action = πTemp010
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(6)            
							// line 1835: conflicts = setdefault(action_conflicts, mutex_action, [])
							πF.SetLineno(1835)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µaction_conflicts, "action_conflicts"); πE != nil {
								continue
							}
							πTemp005[0] = µaction_conflicts
							if πE = πg.CheckLocal(πF, µmutex_action, "mutex_action"); πE != nil {
								continue
							}
							πTemp005[1] = µmutex_action
							πTemp011 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp011...).ToObject()
							πTemp005[2] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßsetdefault); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µconflicts = πTemp008
							// line 1836: conflicts += (group_actions[:i])
							πF.SetLineno(1836)
							if πE = πg.CheckLocal(πF, µconflicts, "conflicts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µi, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup_actions, "group_actions"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µgroup_actions, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µconflicts, πTemp008); πE != nil {
								continue
							}
							µconflicts = πTemp003
							// line 1837: conflicts += (group_actions[i + 1:])
							πF.SetLineno(1837)
							if πE = πg.CheckLocal(πF, µconflicts, "conflicts"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πTemp008, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µgroup_actions, "group_actions"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µgroup_actions, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µconflicts, πTemp008); πE != nil {
								continue
							}
							µconflicts = πTemp003
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 1842: option_string_indices = {}
							πF.SetLineno(1842)
							πTemp006 = πg.NewDict()
							πTemp001 = πTemp006.ToObject()
							µoption_string_indices = πTemp001
							// line 1843: arg_string_pattern_parts = []
							πF.SetLineno(1843)
							πTemp005 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							µarg_string_pattern_parts = πTemp001
							// line 1844: arg_strings_iter = iter(arg_strings)
							πF.SetLineno(1844)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							πTemp005[0] = µarg_strings
							if πTemp001, πE = πg.ResolveGlobal(πF, ßiter); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µarg_strings_iter = πTemp002
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_strings_iter, "arg_strings_iter"); πE != nil {
								continue
							}
							πTemp005[0] = µarg_strings_iter
							if πTemp002, πE = πg.ResolveGlobal(πF, ßenumerate); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(10)
							πTemp004 = false
						Label9:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label11
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp008}}}, πTemp002); πE != nil {
									continue
								}
								µi = πTemp003
								µarg_string = πTemp008
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(9)            
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µarg_string, πg.NewStr("--").ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label12
							}
							goto Label13
							// line 1848: if arg_string == '--':
							πF.SetLineno(1848)
						Label12:
							// line 1849: arg_string_pattern_parts.append('-')
							πF.SetLineno(1849)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr("-").ToObject()
							if πE = πg.CheckLocal(πF, µarg_string_pattern_parts, "arg_string_pattern_parts"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µarg_string_pattern_parts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.CheckLocal(πF, µarg_strings_iter, "arg_strings_iter"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µarg_strings_iter); πE != nil {
								continue
							}
							πF.PushCheckpoint(16)
							πTemp007 = false
						Label15:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label17
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp009 = !isStop
							} else {
								πTemp009 = true
								µarg_string = πTemp003
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(15)            
							// line 1851: arg_string_pattern_parts.append('A')
							πF.SetLineno(1851)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = ßA.ToObject()
							if πE = πg.CheckLocal(πF, µarg_string_pattern_parts, "arg_string_pattern_parts"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µarg_string_pattern_parts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							continue
						Label16:
							if πE != nil || πR != nil {
								continue
							}
						Label17:
							goto Label14
						Label13:
							// line 1856: option_tuple = self._parse_optional(arg_string)
							πF.SetLineno(1856)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp005[0] = µarg_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_parse_optional, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µoption_tuple = πTemp003
							if πE = πg.CheckLocal(πF, µoption_tuple, "option_tuple"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µoption_tuple == πTemp003).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label18
							}
							goto Label19
							// line 1857: if option_tuple is None:
							πF.SetLineno(1857)
						Label18:
							// line 1858: pattern = 'A'
							πF.SetLineno(1858)
							µpattern = ßA.ToObject()
							goto Label20
						Label19:
							// line 1860: option_string_indices[i] = option_tuple
							πF.SetLineno(1860)
							if πE = πg.CheckLocal(πF, µoption_tuple, "option_tuple"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µoption_tuple); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string_indices, "option_string_indices"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp003 = µi
							if πE = πg.SetItem(πF, µoption_string_indices, πTemp003, πTemp002); πE != nil {
								continue
							}
							// line 1861: pattern = 'O'
							πF.SetLineno(1861)
							µpattern = ßO.ToObject()
							goto Label20
						Label20:
							// line 1862: arg_string_pattern_parts.append(pattern)
							πF.SetLineno(1862)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpattern, "pattern"); πE != nil {
								continue
							}
							πTemp005[0] = µpattern
							if πE = πg.CheckLocal(πF, µarg_string_pattern_parts, "arg_string_pattern_parts"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µarg_string_pattern_parts, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label14
						Label14:
							continue
						Label10:
							if πE != nil || πR != nil {
								continue
							}
						Label11:
							// line 1865: arg_strings_pattern = ''.join(arg_string_pattern_parts)
							πF.SetLineno(1865)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_string_pattern_parts, "arg_string_pattern_parts"); πE != nil {
								continue
							}
							πTemp005[0] = µarg_string_pattern_parts
							if πTemp001, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µarg_strings_pattern = πTemp002
							// line 1868: seen_actions = set()
							πF.SetLineno(1868)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßset); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µseen_actions = πTemp002
							// line 1869: seen_non_default_actions = set()
							πF.SetLineno(1869)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßset); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µseen_non_default_actions = πTemp002
							// line 1871: def take_action(action, argument_strings, option_string=None):
							πF.SetLineno(1871)
							πTemp012 = make([]πg.Param, 3)
							πTemp012[0] = πg.Param{Name: "action", Def: nil}
							πTemp012[1] = πg.Param{Name: "argument_strings", Def: nil}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp012[2] = πg.Param{Name: "option_string", Def: πTemp002}
							πTemp001 = πg.NewFunction(πg.NewCode("take_action", "build/src/__python__/argparse.py", πTemp012, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µaction *πg.Object = πArgs[0]; _ = µaction
								var µargument_strings *πg.Object = πArgs[1]; _ = µargument_strings
								var µoption_string *πg.Object = πArgs[2]; _ = µoption_string
								var µargument_values *πg.Object = πg.UnboundLocal; _ = µargument_values
								var µconflict_action *πg.Object = πg.UnboundLocal; _ = µconflict_action
								var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
								var µaction_name *πg.Object = πg.UnboundLocal; _ = µaction_name
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πTemp007 bool
								_ = πTemp007
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									case 3: goto Label3
									case 4: goto Label4
									default: panic("unexpected function state")
									}
									// line 1872: seen_actions.add(action)
									πF.SetLineno(1872)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp001[0] = µaction
									if πE = πg.CheckLocal(πF, µseen_actions, "seen_actions"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µseen_actions, ßadd, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									// line 1873: argument_values = self._get_values(action, argument_strings)
									πF.SetLineno(1873)
									πTemp001 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp001[0] = µaction
									if πE = πg.CheckLocal(πF, µargument_strings, "argument_strings"); πE != nil {
										continue
									}
									πTemp001[1] = µargument_strings
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ß_get_values, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									µargument_values = πTemp003
									if πE = πg.CheckLocal(πF, µargument_values, "argument_values"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
										continue
									}
									πTemp002 = πg.GetBool(µargument_values != πTemp003).ToObject()
									if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label1
									}
									goto Label2
									// line 1878: if argument_values is not action.default:
									πF.SetLineno(1878)
								Label1:
									// line 1879: seen_non_default_actions.add(action)
									πF.SetLineno(1879)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp001[0] = µaction
									if πE = πg.CheckLocal(πF, µseen_non_default_actions, "seen_non_default_actions"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µseen_non_default_actions, ßadd, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πTemp001 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp001[0] = µaction
									πTemp005 = make([]*πg.Object, 0)
									πTemp003 = πg.NewList(πTemp005...).ToObject()
									πTemp001[1] = πTemp003
									if πE = πg.CheckLocal(πF, µaction_conflicts, "action_conflicts"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, µaction_conflicts, ßget, nil); πE != nil {
										continue
									}
									if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									if πTemp002, πE = πg.Iter(πF, πTemp006); πE != nil {
										continue
									}
									πF.PushCheckpoint(4)
									πTemp004 = false
								Label3:
									if πE != nil || πR != nil {
										continue
									}
									if πTemp004 {
										πF.PopCheckpoint()
										goto Label5
									}
									if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
										isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
										if exc != nil {
											πE = exc
										} else if isStop {
											πE = nil
											πF.RestoreExc(nil, nil)
										}
										πTemp007 = !isStop
									} else {
										πTemp007 = true
										µconflict_action = πTemp003
									}
									if πE != nil || !πTemp007 {
										continue
									}
									πF.PushCheckpoint(3)            
									if πE = πg.CheckLocal(πF, µconflict_action, "conflict_action"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µseen_non_default_actions, "seen_non_default_actions"); πE != nil {
										continue
									}
									if πTemp007, πE = πg.Contains(πF, µseen_non_default_actions, µconflict_action); πE != nil {
										continue
									}
									πTemp003 = πg.GetBool(πTemp007).ToObject()
									if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
										continue
									}
									if πTemp007 {
										goto Label6
									}
									goto Label7
									// line 1881: if conflict_action in seen_non_default_actions:
									πF.SetLineno(1881)
								Label6:
									// line 1882: msg = _('not allowed with argument %s')
									πF.SetLineno(1882)
									πTemp001 = πF.MakeArgs(1)
									πTemp001[0] = πg.NewStr("not allowed with argument %s").ToObject()
									if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
										continue
									}
									if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									µmsg = πTemp006
									// line 1883: action_name = _get_action_name(conflict_action)
									πF.SetLineno(1883)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µconflict_action, "conflict_action"); πE != nil {
										continue
									}
									πTemp001[0] = µconflict_action
									if πTemp003, πE = πg.ResolveGlobal(πF, ß_get_action_name); πE != nil {
										continue
									}
									if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									µaction_name = πTemp006
									πTemp001 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp001[0] = µaction
									if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µaction_name, "action_name"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.Mod(πF, µmsg, µaction_name); πE != nil {
										continue
									}
									πTemp001[1] = πTemp003
									if πTemp003, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
										continue
									}
									if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									// line 1884: raise ArgumentError(action, msg % action_name)
									πF.SetLineno(1884)
									πE = πF.Raise(πTemp006, nil, nil)
									continue
									goto Label7
								Label7:
									continue
								Label4:
									if πE != nil || πR != nil {
										continue
									}
								Label5:
									goto Label2
								Label2:
									if πE = πg.CheckLocal(πF, µargument_values, "argument_values"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
										continue
									}
									πTemp002 = πg.GetBool(µargument_values != πTemp003).ToObject()
									if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
										continue
									}
									if πTemp004 {
										goto Label8
									}
									goto Label9
									// line 1888: if argument_values is not SUPPRESS:
									πF.SetLineno(1888)
								Label8:
									// line 1889: action(self, namespace, argument_values, option_string)
									πF.SetLineno(1889)
									πTemp001 = πF.MakeArgs(4)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									πTemp001[0] = µself
									if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
										continue
									}
									πTemp001[1] = µnamespace
									if πE = πg.CheckLocal(πF, µargument_values, "argument_values"); πE != nil {
										continue
									}
									πTemp001[2] = µargument_values
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									πTemp001[3] = µoption_string
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									if πTemp002, πE = µaction.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									goto Label9
								Label9:
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µtake_action = πTemp001
							// line 1892: def consume_optional(start_index):
							πF.SetLineno(1892)
							πTemp012 = make([]πg.Param, 1)
							πTemp012[0] = πg.Param{Name: "start_index", Def: nil}
							πTemp002 = πg.NewFunction(πg.NewCode("consume_optional", "build/src/__python__/argparse.py", πTemp012, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µstart_index *πg.Object = πArgs[0]; _ = µstart_index
								var µoption_tuple *πg.Object = πg.UnboundLocal; _ = µoption_tuple
								var µaction *πg.Object = πg.UnboundLocal; _ = µaction
								var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
								var µexplicit_arg *πg.Object = πg.UnboundLocal; _ = µexplicit_arg
								var µmatch_argument *πg.Object = πg.UnboundLocal; _ = µmatch_argument
								var µaction_tuples *πg.Object = πg.UnboundLocal; _ = µaction_tuples
								var µarg_count *πg.Object = πg.UnboundLocal; _ = µarg_count
								var µchars *πg.Object = πg.UnboundLocal; _ = µchars
								var µchar *πg.Object = πg.UnboundLocal; _ = µchar
								var µnew_explicit_arg *πg.Object = πg.UnboundLocal; _ = µnew_explicit_arg
								var µoptionals_map *πg.Object = πg.UnboundLocal; _ = µoptionals_map
								var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
								var µstop *πg.Object = πg.UnboundLocal; _ = µstop
								var µargs *πg.Object = πg.UnboundLocal; _ = µargs
								var µstart *πg.Object = πg.UnboundLocal; _ = µstart
								var µselected_patterns *πg.Object = πg.UnboundLocal; _ = µselected_patterns
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 []*πg.Object
								_ = πTemp004
								var πTemp005 bool
								_ = πTemp005
								var πTemp006 bool
								_ = πTemp006
								var πTemp007 *πg.Object
								_ = πTemp007
								var πTemp008 bool
								_ = πTemp008
								var πTemp009 []*πg.Object
								_ = πTemp009
								var πTemp010 *πg.Object
								_ = πTemp010
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									case 1: goto Label1
									case 2: goto Label2
									case 19: goto Label19
									case 18: goto Label18
									default: panic("unexpected function state")
									}
									// line 1895: option_tuple = option_string_indices[start_index]
									πF.SetLineno(1895)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									πTemp001 = µstart_index
									if πE = πg.CheckLocal(πF, µoption_string_indices, "option_string_indices"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetItem(πF, µoption_string_indices, πTemp001); πE != nil {
										continue
									}
									µoption_tuple = πTemp002
									// line 1896: action, option_string, explicit_arg = option_tuple
									πF.SetLineno(1896)
									if πE = πg.CheckLocal(πF, µoption_tuple, "option_tuple"); πE != nil {
										continue
									}
									if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, µoption_tuple); πE != nil {
										continue
									}
									µaction = πTemp001
									µoption_string = πTemp002
									µexplicit_arg = πTemp003
									// line 1900: match_argument = self._match_argument
									πF.SetLineno(1900)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ß_match_argument, nil); πE != nil {
										continue
									}
									µmatch_argument = πTemp001
									// line 1901: action_tuples = []
									πF.SetLineno(1901)
									πTemp004 = make([]*πg.Object, 0)
									πTemp001 = πg.NewList(πTemp004...).ToObject()
									µaction_tuples = πTemp001
									// line 1902: while True:
									πF.SetLineno(1902)
									πF.PushCheckpoint(2)
									πTemp005 = false
								Label1:
									if πE != nil || πR != nil {
										continue
									}
									if πTemp005 {
										πF.PopCheckpoint()
										goto Label3
									}
									if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
										continue
									}
									if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πE != nil || !πTemp006 {
										continue
									}
									πF.PushCheckpoint(1)            
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(µaction == πTemp002).ToObject()
									if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp006 {
										goto Label4
									}
									goto Label5
									// line 1905: if action is None:
									πF.SetLineno(1905)
								Label4:
									// line 1906: extras.append(arg_strings[start_index])
									πF.SetLineno(1906)
									πTemp004 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									πTemp001 = µstart_index
									if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetItem(πF, µarg_strings, πTemp001); πE != nil {
										continue
									}
									πTemp004[0] = πTemp002
									if πE = πg.CheckLocal(πF, µextras, "extras"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µextras, ßappend, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									// line 1907: return start_index + 1
									πF.SetLineno(1907)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Add(πF, µstart_index, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									πR = πTemp001
									continue
									goto Label5
								Label5:
									if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(µexplicit_arg != πTemp002).ToObject()
									if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp006 {
										goto Label6
									}
									goto Label7
									// line 1911: if explicit_arg is not None:
									πF.SetLineno(1911)
								Label6:
									// line 1912: arg_count = match_argument(action, 'A')
									πF.SetLineno(1912)
									πTemp004 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp004[0] = µaction
									πTemp004[1] = ßA.ToObject()
									if πE = πg.CheckLocal(πF, µmatch_argument, "match_argument"); πE != nil {
										continue
									}
									if πTemp001, πE = µmatch_argument.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									µarg_count = πTemp001
									// line 1917: chars = self.prefix_chars
									πF.SetLineno(1917)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
										continue
									}
									µchars = πTemp001
									if πE = πg.CheckLocal(πF, µarg_count, "arg_count"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.Eq(πF, µarg_count, πg.NewInt(0).ToObject()); πE != nil {
										continue
									}
									πTemp001 = πTemp002
									if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if !πTemp006 {
										goto Label9
									}
									πTemp003 = πg.NewInt(1).ToObject()
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									if πTemp007, πE = πg.GetItem(πF, µoption_string, πTemp003); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µchars, "chars"); πE != nil {
										continue
									}
									if πTemp008, πE = πg.Contains(πF, µchars, πTemp007); πE != nil {
										continue
									}
									πTemp002 = πg.GetBool(!πTemp008).ToObject()
									πTemp001 = πTemp002
								Label9:
									if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp006 {
										goto Label10
									}
									if πE = πg.CheckLocal(πF, µarg_count, "arg_count"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Eq(πF, µarg_count, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp006 {
										goto Label11
									}
									goto Label12
									// line 1918: if arg_count == 0 and option_string[1] not in chars:
									πF.SetLineno(1918)
								Label10:
									// line 1919: action_tuples.append((action, [], option_string))
									πF.SetLineno(1919)
									πTemp004 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp009 = make([]*πg.Object, 0)
									πTemp002 = πg.NewList(πTemp009...).ToObject()
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									πTemp001 = πg.NewTuple3(µaction, πTemp002, µoption_string).ToObject()
									πTemp004[0] = πTemp001
									if πE = πg.CheckLocal(πF, µaction_tuples, "action_tuples"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µaction_tuples, ßappend, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									// line 1920: char = option_string[0]
									πF.SetLineno(1920)
									πTemp001 = πg.NewInt(0).ToObject()
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetItem(πF, µoption_string, πTemp001); πE != nil {
										continue
									}
									µchar = πTemp002
									// line 1921: option_string = char + explicit_arg[0]
									πF.SetLineno(1921)
									if πE = πg.CheckLocal(πF, µchar, "char"); πE != nil {
										continue
									}
									πTemp002 = πg.NewInt(0).ToObject()
									if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetItem(πF, µexplicit_arg, πTemp002); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Add(πF, µchar, πTemp003); πE != nil {
										continue
									}
									µoption_string = πTemp001
									// line 1922: new_explicit_arg = explicit_arg[1:] or None
									πF.SetLineno(1922)
									if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetItem(πF, µexplicit_arg, πTemp002); πE != nil {
										continue
									}
									πTemp001 = πTemp003
									if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp006 {
										goto Label14
									}
									if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
										continue
									}
									πTemp001 = πTemp002
								Label14:
									µnew_explicit_arg = πTemp001
									// line 1923: optionals_map = self._option_string_actions
									πF.SetLineno(1923)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
										continue
									}
									µoptionals_map = πTemp001
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µoptionals_map, "optionals_map"); πE != nil {
										continue
									}
									if πTemp006, πE = πg.Contains(πF, µoptionals_map, µoption_string); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(πTemp006).ToObject()
									if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
										continue
									}
									if πTemp006 {
										goto Label15
									}
									goto Label16
									// line 1924: if option_string in optionals_map:
									πF.SetLineno(1924)
								Label15:
									// line 1925: action = optionals_map[option_string]
									πF.SetLineno(1925)
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									πTemp001 = µoption_string
									if πE = πg.CheckLocal(πF, µoptionals_map, "optionals_map"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetItem(πF, µoptionals_map, πTemp001); πE != nil {
										continue
									}
									µaction = πTemp002
									// line 1926: explicit_arg = new_explicit_arg
									πF.SetLineno(1926)
									if πE = πg.CheckLocal(πF, µnew_explicit_arg, "new_explicit_arg"); πE != nil {
										continue
									}
									µexplicit_arg = µnew_explicit_arg
									goto Label17
								Label16:
									// line 1928: msg = _('ignored explicit argument %r')
									πF.SetLineno(1928)
									πTemp004 = πF.MakeArgs(1)
									πTemp004[0] = πg.NewStr("ignored explicit argument %r").ToObject()
									if πTemp001, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									µmsg = πTemp002
									πTemp004 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp004[0] = µaction
									if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Mod(πF, µmsg, µexplicit_arg); πE != nil {
										continue
									}
									πTemp004[1] = πTemp001
									if πTemp001, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									// line 1929: raise ArgumentError(action, msg % explicit_arg)
									πF.SetLineno(1929)
									πE = πF.Raise(πTemp002, nil, nil)
									continue
									goto Label17
								Label17:
									goto Label13
									// line 1933: elif arg_count == 1:
									πF.SetLineno(1933)
								Label11:
									// line 1934: stop = start_index + 1
									πF.SetLineno(1934)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Add(πF, µstart_index, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									µstop = πTemp001
									// line 1935: args = [explicit_arg]
									πF.SetLineno(1935)
									πTemp004 = make([]*πg.Object, 1)
									if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
										continue
									}
									πTemp004[0] = µexplicit_arg
									πTemp001 = πg.NewList(πTemp004...).ToObject()
									µargs = πTemp001
									// line 1936: action_tuples.append((action, args, option_string))
									πF.SetLineno(1936)
									πTemp004 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									πTemp001 = πg.NewTuple3(µaction, µargs, µoption_string).ToObject()
									πTemp004[0] = πTemp001
									if πE = πg.CheckLocal(πF, µaction_tuples, "action_tuples"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µaction_tuples, ßappend, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									// line 1937: break
									πF.SetLineno(1937)
									πTemp005 = true
									continue
									goto Label13
								Label12:
									// line 1942: msg = _('ignored explicit argument %r')
									πF.SetLineno(1942)
									πTemp004 = πF.MakeArgs(1)
									πTemp004[0] = πg.NewStr("ignored explicit argument %r").ToObject()
									if πTemp001, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									µmsg = πTemp002
									πTemp004 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp004[0] = µaction
									if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Mod(πF, µmsg, µexplicit_arg); πE != nil {
										continue
									}
									πTemp004[1] = πTemp001
									if πTemp001, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									// line 1943: raise ArgumentError(action, msg % explicit_arg)
									πF.SetLineno(1943)
									πE = πF.Raise(πTemp002, nil, nil)
									continue
									goto Label13
								Label13:
									goto Label8
								Label7:
									// line 1949: start = start_index + 1
									πF.SetLineno(1949)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Add(πF, µstart_index, πg.NewInt(1).ToObject()); πE != nil {
										continue
									}
									µstart = πTemp001
									// line 1950: selected_patterns = arg_strings_pattern[start:]
									πF.SetLineno(1950)
									if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µstart, πg.None, πg.None}, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µarg_strings_pattern, "arg_strings_pattern"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetItem(πF, µarg_strings_pattern, πTemp001); πE != nil {
										continue
									}
									µselected_patterns = πTemp002
									// line 1951: arg_count = match_argument(action, selected_patterns)
									πF.SetLineno(1951)
									πTemp004 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp004[0] = µaction
									if πE = πg.CheckLocal(πF, µselected_patterns, "selected_patterns"); πE != nil {
										continue
									}
									πTemp004[1] = µselected_patterns
									if πE = πg.CheckLocal(πF, µmatch_argument, "match_argument"); πE != nil {
										continue
									}
									if πTemp001, πE = µmatch_argument.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									µarg_count = πTemp001
									// line 1952: stop = start + arg_count
									πF.SetLineno(1952)
									if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µarg_count, "arg_count"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Add(πF, µstart, µarg_count); πE != nil {
										continue
									}
									µstop = πTemp001
									// line 1953: args = arg_strings[start:stop]
									πF.SetLineno(1953)
									if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µstop, "stop"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µstart, µstop, πg.None}, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetItem(πF, µarg_strings, πTemp001); πE != nil {
										continue
									}
									µargs = πTemp002
									// line 1954: action_tuples.append((action, args, option_string))
									πF.SetLineno(1954)
									πTemp004 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									πTemp001 = πg.NewTuple3(µaction, µargs, µoption_string).ToObject()
									πTemp004[0] = πTemp001
									if πE = πg.CheckLocal(πF, µaction_tuples, "action_tuples"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µaction_tuples, ßappend, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									// line 1955: break
									πF.SetLineno(1955)
									πTemp005 = true
									continue
									goto Label8
								Label8:
									continue
								Label2:
									if πE != nil || πR != nil {
										continue
									}
								Label3:
									// line 1959: assert action_tuples
									πF.SetLineno(1959)
									if πE = πg.CheckLocal(πF, µaction_tuples, "action_tuples"); πE != nil {
										continue
									}
									if πE = πg.Assert(πF, µaction_tuples, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µaction_tuples, "action_tuples"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.Iter(πF, µaction_tuples); πE != nil {
										continue
									}
									πF.PushCheckpoint(19)
									πTemp005 = false
								Label18:
									if πE != nil || πR != nil {
										continue
									}
									if πTemp005 {
										πF.PopCheckpoint()
										goto Label20
									}
									if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
										isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
										if exc != nil {
											πE = exc
										} else if isStop {
											πE = nil
											πF.RestoreExc(nil, nil)
										}
										πTemp006 = !isStop
									} else {
										πTemp006 = true
										if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp007}, πg.TieTarget{Target: &πTemp010}}}, πTemp002); πE != nil {
											continue
										}
										µaction = πTemp003
										µargs = πTemp007
										µoption_string = πTemp010
									}
									if πE != nil || !πTemp006 {
										continue
									}
									πF.PushCheckpoint(18)            
									// line 1961: take_action(action, args, option_string)
									πF.SetLineno(1961)
									πTemp004 = πF.MakeArgs(3)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp004[0] = µaction
									if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
										continue
									}
									πTemp004[1] = µargs
									if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
										continue
									}
									πTemp004[2] = µoption_string
									if πE = πg.CheckLocal(πF, µtake_action, "take_action"); πE != nil {
										continue
									}
									if πTemp002, πE = µtake_action.Call(πF, πTemp004, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp004)
									continue
								Label19:
									if πE != nil || πR != nil {
										continue
									}
								Label20:
									// line 1962: return stop
									πF.SetLineno(1962)
									if πE = πg.CheckLocal(πF, µstop, "stop"); πE != nil {
										continue
									}
									πR = µstop
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µconsume_optional = πTemp002
							// line 1966: positionals = self._get_positional_actions()
							πF.SetLineno(1966)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_get_positional_actions, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µpositionals = πTemp008
							// line 1969: def consume_positionals(start_index):
							πF.SetLineno(1969)
							πTemp012 = make([]πg.Param, 1)
							πTemp012[0] = πg.Param{Name: "start_index", Def: nil}
							πTemp003 = πg.NewFunction(πg.NewCode("consume_positionals", "build/src/__python__/argparse.py", πTemp012, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µstart_index *πg.Object = πArgs[0]; _ = µstart_index
								var µmatch_partial *πg.Object = πg.UnboundLocal; _ = µmatch_partial
								var µselected_pattern *πg.Object = πg.UnboundLocal; _ = µselected_pattern
								var µarg_counts *πg.Object = πg.UnboundLocal; _ = µarg_counts
								var µaction *πg.Object = πg.UnboundLocal; _ = µaction
								var µarg_count *πg.Object = πg.UnboundLocal; _ = µarg_count
								var µargs *πg.Object = πg.UnboundLocal; _ = µargs
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 []*πg.Object
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 bool
								_ = πTemp005
								var πTemp006 bool
								_ = πTemp006
								var πTemp007 *πg.Object
								_ = πTemp007
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									case 1: goto Label1
									case 2: goto Label2
									default: panic("unexpected function state")
									}
									// line 1971: match_partial = self._match_arguments_partial
									πF.SetLineno(1971)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ß_match_arguments_partial, nil); πE != nil {
										continue
									}
									µmatch_partial = πTemp001
									// line 1972: selected_pattern = arg_strings_pattern[start_index:]
									πF.SetLineno(1972)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µstart_index, πg.None, πg.None}, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µarg_strings_pattern, "arg_strings_pattern"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetItem(πF, µarg_strings_pattern, πTemp001); πE != nil {
										continue
									}
									µselected_pattern = πTemp002
									// line 1973: arg_counts = match_partial(positionals, selected_pattern)
									πF.SetLineno(1973)
									πTemp003 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
										continue
									}
									πTemp003[0] = µpositionals
									if πE = πg.CheckLocal(πF, µselected_pattern, "selected_pattern"); πE != nil {
										continue
									}
									πTemp003[1] = µselected_pattern
									if πE = πg.CheckLocal(πF, µmatch_partial, "match_partial"); πE != nil {
										continue
									}
									if πTemp001, πE = µmatch_partial.Call(πF, πTemp003, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp003)
									µarg_counts = πTemp001
									πTemp003 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
										continue
									}
									πTemp003[0] = µpositionals
									if πE = πg.CheckLocal(πF, µarg_counts, "arg_counts"); πE != nil {
										continue
									}
									πTemp003[1] = µarg_counts
									if πTemp002, πE = πg.ResolveGlobal(πF, ßzip); πE != nil {
										continue
									}
									if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp003)
									if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
										continue
									}
									πF.PushCheckpoint(2)
									πTemp005 = false
								Label1:
									if πE != nil || πR != nil {
										continue
									}
									if πTemp005 {
										πF.PopCheckpoint()
										goto Label3
									}
									if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
										isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
										if exc != nil {
											πE = exc
										} else if isStop {
											πE = nil
											πF.RestoreExc(nil, nil)
										}
										πTemp006 = !isStop
									} else {
										πTemp006 = true
										if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp007}}}, πTemp002); πE != nil {
											continue
										}
										µaction = πTemp004
										µarg_count = πTemp007
									}
									if πE != nil || !πTemp006 {
										continue
									}
									πF.PushCheckpoint(1)            
									// line 1978: args = arg_strings[start_index: start_index + arg_count]
									πF.SetLineno(1978)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µarg_count, "arg_count"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.Add(πF, µstart_index, µarg_count); πE != nil {
										continue
									}
									if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µstart_index, πTemp004, πg.None}, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.GetItem(πF, µarg_strings, πTemp002); πE != nil {
										continue
									}
									µargs = πTemp004
									// line 1979: start_index += arg_count
									πF.SetLineno(1979)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µarg_count, "arg_count"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.IAdd(πF, µstart_index, µarg_count); πE != nil {
										continue
									}
									µstart_index = πTemp002
									// line 1980: take_action(action, args)
									πF.SetLineno(1980)
									πTemp003 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
										continue
									}
									πTemp003[0] = µaction
									if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
										continue
									}
									πTemp003[1] = µargs
									if πE = πg.CheckLocal(πF, µtake_action, "take_action"); πE != nil {
										continue
									}
									if πTemp002, πE = µtake_action.Call(πF, πTemp003, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp003)
									continue
								Label2:
									if πE != nil || πR != nil {
										continue
									}
								Label3:
									// line 1984: positionals[:] = positionals[len(arg_counts):]
									πF.SetLineno(1984)
									πTemp003 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µarg_counts, "arg_counts"); πE != nil {
										continue
									}
									πTemp003[0] = µarg_counts
									if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
										continue
									}
									if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp003)
									if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp004, πg.None, πg.None}, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetItem(πF, µpositionals, πTemp001); πE != nil {
										continue
									}
									if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.None, πg.None}, nil); πE != nil {
										continue
									}
									if πE = πg.SetItem(πF, µpositionals, πTemp004, πTemp001); πE != nil {
										continue
									}
									// line 1985: return start_index
									πF.SetLineno(1985)
									if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
										continue
									}
									πR = µstart_index
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µconsume_positionals = πTemp003
							// line 1989: extras = []
							πF.SetLineno(1989)
							πTemp005 = make([]*πg.Object, 0)
							πTemp008 = πg.NewList(πTemp005...).ToObject()
							µextras = πTemp008
							// line 1990: start_index = 0
							πF.SetLineno(1990)
							µstart_index = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string_indices, "option_string_indices"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µoption_string_indices); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label21
							}
							goto Label22
							// line 1991: if option_string_indices:
							πF.SetLineno(1991)
						Label21:
							// line 1992: max_option_string_index = max(option_string_indices)
							πF.SetLineno(1992)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_string_indices, "option_string_indices"); πE != nil {
								continue
							}
							πTemp005[0] = µoption_string_indices
							if πTemp008, πE = πg.ResolveGlobal(πF, ßmax); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp008.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µmax_option_string_index = πTemp010
							goto Label23
						Label22:
							// line 1994: max_option_string_index = -1
							πF.SetLineno(1994)
							if πTemp008, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µmax_option_string_index = πTemp008
							goto Label23
						Label23:
							// line 1995: while start_index <= max_option_string_index:
							πF.SetLineno(1995)
							πF.PushCheckpoint(25)
							πTemp004 = false
						Label24:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label26
							}
							if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmax_option_string_index, "max_option_string_index"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.LE(πF, µstart_index, µmax_option_string_index); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(24)            
							// line 1998: next_option_string_index = min([
							πF.SetLineno(1998)
							πTemp005 = πF.MakeArgs(1)
							πTemp012 = make([]πg.Param, 0)
							πTemp010 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp012, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µindex *πg.Object = πg.UnboundLocal; _ = µindex
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µoption_string_indices, "option_string_indices"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µoption_string_indices); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µindex = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
											continue
										}
										if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GE(πF, µindex, µstart_index); πE != nil {
											continue
										}
										if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
											continue
										}
										if πTemp003 {
											goto Label4
										}
										goto Label5
										// line 1998: next_option_string_index = min([
										πF.SetLineno(1998)
									Label4:
										// line 1998: next_option_string_index = min([
										πF.SetLineno(1998)
										if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
											continue
										}
										πF.PushCheckpoint(6)
										return µindex, nil
									Label6:
										πTemp004 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp013, πE = πTemp010.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.ListType.Call(πF, πg.Args{πTemp013}, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp008
							if πTemp008, πE = πg.ResolveGlobal(πF, ßmin); πE != nil {
								continue
							}
							if πTemp013, πE = πTemp008.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µnext_option_string_index = πTemp013
							if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnext_option_string_index, "next_option_string_index"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.NE(πF, µstart_index, µnext_option_string_index); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label27
							}
							goto Label28
							// line 2002: if start_index != next_option_string_index:
							πF.SetLineno(2002)
						Label27:
							// line 2003: positionals_end_index = consume_positionals(start_index)
							πF.SetLineno(2003)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
								continue
							}
							πTemp005[0] = µstart_index
							if πE = πg.CheckLocal(πF, µconsume_positionals, "consume_positionals"); πE != nil {
								continue
							}
							if πTemp008, πE = µconsume_positionals.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µpositionals_end_index = πTemp008
							if πE = πg.CheckLocal(πF, µpositionals_end_index, "positionals_end_index"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GT(πF, µpositionals_end_index, µstart_index); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label29
							}
							goto Label30
							// line 2007: if positionals_end_index > start_index:
							πF.SetLineno(2007)
						Label29:
							// line 2008: start_index = positionals_end_index
							πF.SetLineno(2008)
							if πE = πg.CheckLocal(πF, µpositionals_end_index, "positionals_end_index"); πE != nil {
								continue
							}
							µstart_index = µpositionals_end_index
							// line 2009: continue
							πF.SetLineno(2009)
							continue
							goto Label31
						Label30:
							// line 2011: start_index = positionals_end_index
							πF.SetLineno(2011)
							if πE = πg.CheckLocal(πF, µpositionals_end_index, "positionals_end_index"); πE != nil {
								continue
							}
							µstart_index = µpositionals_end_index
							goto Label31
						Label31:
							goto Label28
						Label28:
							if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string_indices, "option_string_indices"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µoption_string_indices, µstart_index); πE != nil {
								continue
							}
							πTemp008 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label32
							}
							goto Label33
							// line 2015: if start_index not in option_string_indices:
							πF.SetLineno(2015)
						Label32:
							// line 2016: strings = arg_strings[start_index:next_option_string_index]
							πF.SetLineno(2016)
							if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnext_option_string_index, "next_option_string_index"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.SliceType.Call(πF, πg.Args{µstart_index, µnext_option_string_index, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetItem(πF, µarg_strings, πTemp008); πE != nil {
								continue
							}
							µstrings = πTemp013
							// line 2018: extras += (strings)
							πF.SetLineno(2018)
							if πE = πg.CheckLocal(πF, µextras, "extras"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstrings, "strings"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IAdd(πF, µextras, µstrings); πE != nil {
								continue
							}
							µextras = πTemp008
							// line 2019: start_index = next_option_string_index
							πF.SetLineno(2019)
							if πE = πg.CheckLocal(πF, µnext_option_string_index, "next_option_string_index"); πE != nil {
								continue
							}
							µstart_index = µnext_option_string_index
							goto Label33
						Label33:
							// line 2022: start_index = consume_optional(start_index)
							πF.SetLineno(2022)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
								continue
							}
							πTemp005[0] = µstart_index
							if πE = πg.CheckLocal(πF, µconsume_optional, "consume_optional"); πE != nil {
								continue
							}
							if πTemp008, πE = µconsume_optional.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µstart_index = πTemp008
							continue
						Label25:
							if πE != nil || πR != nil {
								continue
							}
						Label26:
							// line 2025: stop_index = consume_positionals(start_index)
							πF.SetLineno(2025)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstart_index, "start_index"); πE != nil {
								continue
							}
							πTemp005[0] = µstart_index
							if πE = πg.CheckLocal(πF, µconsume_positionals, "consume_positionals"); πE != nil {
								continue
							}
							if πTemp008, πE = µconsume_positionals.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µstop_index = πTemp008
							// line 2029: extras += (arg_strings[stop_index:])
							πF.SetLineno(2029)
							if πE = πg.CheckLocal(πF, µextras, "extras"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstop_index, "stop_index"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.SliceType.Call(πF, πg.Args{µstop_index, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetItem(πF, µarg_strings, πTemp008); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IAdd(πF, µextras, πTemp013); πE != nil {
								continue
							}
							µextras = πTemp008
							if πE = πg.CheckLocal(πF, µpositionals, "positionals"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µpositionals); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label34
							}
							goto Label35
							// line 2033: if positionals:
							πF.SetLineno(2033)
						Label34:
							// line 2034: self.error(_('too few arguments'))
							πF.SetLineno(2034)
							πTemp005 = πF.MakeArgs(1)
							πTemp011 = πF.MakeArgs(1)
							πTemp011[0] = πg.NewStr("too few arguments").ToObject()
							if πTemp008, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp013, πE = πTemp008.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp005[0] = πTemp013
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp013, πE = πTemp008.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label35
						Label35:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Iter(πF, πTemp013); πE != nil {
								continue
							}
							πF.PushCheckpoint(37)
							πTemp004 = false
						Label36:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label38
							}
							if πTemp013, πE = πg.Next(πF, πTemp008); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µaction = πTemp013
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(36)            
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µseen_actions, "seen_actions"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µseen_actions, µaction); πE != nil {
								continue
							}
							πTemp013 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp013); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label39
							}
							goto Label40
							// line 2038: if action not in seen_actions:
							πF.SetLineno(2038)
						Label39:
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µaction, ßrequired, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp013); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label41
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp015, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							if πTemp016, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp014 = πg.GetBool(πTemp015 != πTemp016).ToObject()
							πTemp013 = πTemp014
							if πTemp007, πE = πg.IsTrue(πF, πTemp013); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label42
							}
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp014, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp014
							if πTemp014, πE = πg.ResolveGlobal(πF, ßbasestring); πE != nil {
								continue
							}
							πTemp005[1] = πTemp014
							if πTemp014, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp015, πE = πTemp014.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp013 = πTemp015
							if πTemp007, πE = πg.IsTrue(πF, πTemp013); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label42
							}
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp005[0] = µnamespace
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp014, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							πTemp005[1] = πTemp014
							if πTemp014, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp015, πE = πTemp014.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp013 = πTemp015
							if πTemp007, πE = πg.IsTrue(πF, πTemp013); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label42
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp015, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp005[0] = µnamespace
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp016, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							πTemp005[1] = πTemp016
							if πTemp016, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp017, πE = πTemp016.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp014 = πg.GetBool(πTemp015 == πTemp017).ToObject()
							πTemp013 = πTemp014
						Label42:
							if πTemp007, πE = πg.IsTrue(πF, πTemp013); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label43
							}
							goto Label44
							// line 2039: if action.required:
							πF.SetLineno(2039)
						Label41:
							// line 2040: name = _get_action_name(action)
							πF.SetLineno(2040)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp005[0] = µaction
							if πTemp013, πE = πg.ResolveGlobal(πF, ß_get_action_name); πE != nil {
								continue
							}
							if πTemp014, πE = πTemp013.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µname = πTemp014
							// line 2041: self.error(_('argument %s is required') % name)
							πF.SetLineno(2041)
							πTemp005 = πF.MakeArgs(1)
							πTemp011 = πF.MakeArgs(1)
							πTemp011[0] = πg.NewStr("argument %s is required").ToObject()
							if πTemp014, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp015, πE = πTemp014.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.Mod(πF, πTemp015, µname); πE != nil {
								continue
							}
							πTemp005[0] = πTemp013
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp014, πE = πTemp013.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label44
							// line 2047: if (action.default is not None and
							πF.SetLineno(2047)
						Label43:
							// line 2051: setattr(namespace, action.dest,
							πF.SetLineno(2051)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							πTemp005[0] = µnamespace
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µaction, ßdest, nil); πE != nil {
								continue
							}
							πTemp005[1] = πTemp013
							πTemp011 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp011[0] = µaction
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							πTemp011[1] = πTemp013
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µself, ß_get_value, nil); πE != nil {
								continue
							}
							if πTemp014, πE = πTemp013.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp005[2] = πTemp014
							if πTemp013, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp014, πE = πTemp013.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label44
						Label44:
							goto Label40
						Label40:
							continue
						Label37:
							if πE != nil || πR != nil {
								continue
							}
						Label38:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µself, ß_mutually_exclusive_groups, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Iter(πF, πTemp013); πE != nil {
								continue
							}
							πF.PushCheckpoint(46)
							πTemp004 = false
						Label45:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label47
							}
							if πTemp013, πE = πg.Next(πF, πTemp008); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µgroup = πTemp013
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(45)            
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µgroup, ßrequired, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp013); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label48
							}
							goto Label49
							// line 2056: if group.required:
							πF.SetLineno(2056)
						Label48:
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp014, πE = πg.GetAttr(πF, µgroup, ß_group_actions, nil); πE != nil {
								continue
							}
							if πTemp013, πE = πg.Iter(πF, πTemp014); πE != nil {
								continue
							}
							πF.PushCheckpoint(51)
							πTemp007 = false
						Label50:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label52
							}
							if πTemp014, πE = πg.Next(πF, πTemp013); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp009 = !isStop
							} else {
								πTemp009 = true
								µaction = πTemp014
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(50)            
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µseen_non_default_actions, "seen_non_default_actions"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Contains(πF, µseen_non_default_actions, µaction); πE != nil {
								continue
							}
							πTemp014 = πg.GetBool(πTemp009).ToObject()
							if πTemp009, πE = πg.IsTrue(πF, πTemp014); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label53
							}
							goto Label54
							// line 2058: if action in seen_non_default_actions:
							πF.SetLineno(2058)
						Label53:
							// line 2059: break
							πF.SetLineno(2059)
							πTemp007 = true
							continue
							goto Label54
						Label54:
							continue
						Label51:
							if πE != nil || πR != nil {
								continue
							}
							// line 2063: names = [_get_action_name(action)
							πF.SetLineno(2063)
							πTemp012 = make([]πg.Param, 0)
							πTemp015 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp012, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µaction *πg.Object = πg.UnboundLocal; _ = µaction
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πTemp007 []*πg.Object
								_ = πTemp007
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µgroup, ß_group_actions, nil); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp003 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp003 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp004 = !isStop
										} else {
											πTemp004 = true
											µaction = πTemp002
										}
										if πE != nil || !πTemp004 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										if πTemp005, πE = πg.GetAttr(πF, µaction, ßhelp, nil); πE != nil {
											continue
										}
										if πTemp006, πE = πg.ResolveGlobal(πF, ßSUPPRESS); πE != nil {
											continue
										}
										πTemp002 = πg.GetBool(πTemp005 != πTemp006).ToObject()
										if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
											continue
										}
										if πTemp004 {
											goto Label4
										}
										goto Label5
										// line 2063: names = [_get_action_name(action)
										πF.SetLineno(2063)
									Label4:
										// line 2063: names = [_get_action_name(action)
										πF.SetLineno(2063)
										πTemp007 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										πTemp007[0] = µaction
										if πTemp002, πE = πg.ResolveGlobal(πF, ß_get_action_name); πE != nil {
											continue
										}
										if πTemp005, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp007)
										πF.PushCheckpoint(6)
										return πTemp005, nil
									Label6:
										πTemp002 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp016, πE = πTemp015.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp014, πE = πg.ListType.Call(πF, πg.Args{πTemp016}, nil); πE != nil {
								continue
							}
							µnames = πTemp014
							// line 2066: msg = _('one of the arguments %s is required')
							πF.SetLineno(2066)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr("one of the arguments %s is required").ToObject()
							if πTemp014, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp016, πE = πTemp014.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µmsg = πTemp016
							// line 2067: self.error(msg % ' '.join(names))
							πF.SetLineno(2067)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp011 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnames, "names"); πE != nil {
								continue
							}
							πTemp011[0] = µnames
							if πTemp016, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp017, πE = πTemp016.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							if πTemp014, πE = πg.Mod(πF, µmsg, πTemp017); πE != nil {
								continue
							}
							πTemp005[0] = πTemp014
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp014, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp016, πE = πTemp014.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
						Label52:
							goto Label49
						Label49:
							continue
						Label46:
							if πE != nil || πR != nil {
								continue
							}
						Label47:
							// line 2070: return namespace, extras
							πF.SetLineno(2070)
							if πE = πg.CheckLocal(πF, µnamespace, "namespace"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µextras, "extras"); πE != nil {
								continue
							}
							πTemp008 = πg.NewTuple2(µnamespace, µextras).ToObject()
							πR = πTemp008
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_parse_known_args.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 2072: def _read_args_from_files(self, arg_strings):
					πF.SetLineno(2072)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "arg_strings", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("_read_args_from_files", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µarg_strings *πg.Object = πArgs[1]; _ = µarg_strings
						var µnew_arg_strings *πg.Object = πg.UnboundLocal; _ = µnew_arg_strings
						var µarg_string *πg.Object = πg.UnboundLocal; _ = µarg_string
						var µargs_file *πg.Object = πg.UnboundLocal; _ = µargs_file
						var µarg_line *πg.Object = πg.UnboundLocal; _ = µarg_line
						var µarg *πg.Object = πg.UnboundLocal; _ = µarg
						var µerr *πg.Object = πg.UnboundLocal; _ = µerr
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πTemp011 *πg.BaseException
						_ = πTemp011
						var πTemp012 *πg.Traceback
						_ = πTemp012
						var πTemp013 []*πg.Object
						_ = πTemp013
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							case 9: goto Label9
							case 10: goto Label10
							case 11: goto Label11
							case 12: goto Label12
							case 14: goto Label14
							case 15: goto Label15
							default: panic("unexpected function state")
							}
							// line 2074: new_arg_strings = []
							πF.SetLineno(2074)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µnew_arg_strings = πTemp002
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µarg_strings); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp005, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µarg_string = πTemp005
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)            
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µarg_string); πE != nil {
								continue
							}
							πTemp006 = πg.GetBool(!πTemp007).ToObject()
							πTemp005 = πTemp006
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							πTemp008 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetItem(πF, µarg_string, πTemp008); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µself, ßfromfile_prefix_chars, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, πTemp008, πTemp009); πE != nil {
								continue
							}
							πTemp006 = πg.GetBool(!πTemp007).ToObject()
							πTemp005 = πTemp006
						Label4:
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 2078: if not arg_string or arg_string[0] not in self.fromfile_prefix_chars:
							πF.SetLineno(2078)
						Label5:
							// line 2079: new_arg_strings.append(arg_string)
							πF.SetLineno(2079)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp001[0] = µarg_string
							if πE = πg.CheckLocal(πF, µnew_arg_strings, "new_arg_strings"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µnew_arg_strings, ßappend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label7
						Label6:
							// line 2083: try:
							πF.SetLineno(2083)
							πF.PushCheckpoint(9)
							// line 2084: args_file = open(arg_string[1:])
							πF.SetLineno(2084)
							πTemp001 = πF.MakeArgs(1)
							if πTemp005, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µarg_string, πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp006
							if πTemp005, πE = πg.ResolveGlobal(πF, ßopen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µargs_file = πTemp006
							// line 2085: try:
							πF.SetLineno(2085)
							πF.PushCheckpoint(10)
							// line 2086: arg_strings = []
							πF.SetLineno(2086)
							πTemp001 = make([]*πg.Object, 0)
							πTemp005 = πg.NewList(πTemp001...).ToObject()
							µarg_strings = πTemp005
							if πE = πg.CheckLocal(πF, µargs_file, "args_file"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µargs_file, ßread, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp008, ßsplitlines, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(12)
							πTemp004 = false
						Label11:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label13
							}
							if πTemp006, πE = πg.Next(πF, πTemp005); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µarg_line = πTemp006
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(11)            
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_line, "arg_line"); πE != nil {
								continue
							}
							πTemp001[0] = µarg_line
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µself, ßconvert_arg_line_to_args, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp006, πE = πg.Iter(πF, πTemp009); πE != nil {
								continue
							}
							πF.PushCheckpoint(15)
							πTemp007 = false
						Label14:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label16
							}
							if πTemp008, πE = πg.Next(πF, πTemp006); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp010 = !isStop
							} else {
								πTemp010 = true
								µarg = πTemp008
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(14)            
							// line 2089: arg_strings.append(arg)
							πF.SetLineno(2089)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg, "arg"); πE != nil {
								continue
							}
							πTemp001[0] = µarg
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µarg_strings, ßappend, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label15:
							if πE != nil || πR != nil {
								continue
							}
						Label16:
							continue
						Label12:
							if πE != nil || πR != nil {
								continue
							}
						Label13:
							// line 2090: arg_strings = self._read_args_from_files(arg_strings)
							πF.SetLineno(2090)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							πTemp001[0] = µarg_strings
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ß_read_args_from_files, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µarg_strings = πTemp006
							// line 2092: new_arg_strings += (arg_strings)
							πF.SetLineno(2092)
							if πE = πg.CheckLocal(πF, µnew_arg_strings, "new_arg_strings"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IAdd(πF, µnew_arg_strings, µarg_strings); πE != nil {
								continue
							}
							µnew_arg_strings = πTemp005
							πF.PopCheckpoint()
							goto Label10
						Label10:
							πTemp011, πTemp012 = πF.RestoreExc(nil, nil)
							// line 2094: args_file.close()
							πF.SetLineno(2094)
							if πE = πg.CheckLocal(πF, µargs_file, "args_file"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µargs_file, ßclose, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp011 != nil {
								πE = πF.Raise(πTemp011.ToObject(), nil, πTemp012.ToObject())
								continue
							}
							if πR != nil {
								continue
							}
							πF.PopCheckpoint()
							goto Label8
						Label9:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp011, πTemp012 = πF.ExcInfo()
							if πTemp005, πE = πg.ResolveGlobal(πF, ßIOError); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsInstance(πF, πTemp011.ToObject(), πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label17
							}
							πE = πF.Raise(πTemp011.ToObject(), nil, πTemp012.ToObject())
							continue
							// line 2095: except IOError:
							πF.SetLineno(2095)
						Label17:
							// line 2096: err = _sys.exc_info()[1]
							πF.SetLineno(2096)
							πTemp005 = πg.NewInt(1).ToObject()
							if πTemp008, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, πTemp008, ßexc_info, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp009.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp008, πTemp005); πE != nil {
								continue
							}
							µerr = πTemp006
							// line 2097: self.error(str(err))
							πF.SetLineno(2097)
							πTemp001 = πF.MakeArgs(1)
							πTemp013 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µerr, "err"); πE != nil {
								continue
							}
							πTemp013[0] = µerr
							if πTemp005, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp013, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp013)
							πTemp001[0] = πTemp006
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πF.RestoreExc(nil, nil)
							goto Label8
						Label8:
							goto Label7
						Label7:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2100: return new_arg_strings
							πF.SetLineno(2100)
							if πE = πg.CheckLocal(πF, µnew_arg_strings, "new_arg_strings"); πE != nil {
								continue
							}
							πR = µnew_arg_strings
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_read_args_from_files.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 2102: def convert_arg_line_to_args(self, arg_line):
					πF.SetLineno(2102)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "arg_line", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("convert_arg_line_to_args", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µarg_line *πg.Object = πArgs[1]; _ = µarg_line
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 2103: return [arg_line]
							πF.SetLineno(2103)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µarg_line, "arg_line"); πE != nil {
								continue
							}
							πTemp001[0] = µarg_line
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßconvert_arg_line_to_args.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 2105: def _match_argument(self, action, arg_strings_pattern):
					πF.SetLineno(2105)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp002[2] = πg.Param{Name: "arg_strings_pattern", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("_match_argument", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µarg_strings_pattern *πg.Object = πArgs[2]; _ = µarg_strings_pattern
						var µnargs_pattern *πg.Object = πg.UnboundLocal; _ = µnargs_pattern
						var µmatch *πg.Object = πg.UnboundLocal; _ = µmatch
						var µnargs_errors *πg.Object = πg.UnboundLocal; _ = µnargs_errors
						var µdefault *πg.Object = πg.UnboundLocal; _ = µdefault
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Dict
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 2107: nargs_pattern = self._get_nargs_pattern(action)
							πF.SetLineno(2107)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_get_nargs_pattern, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µnargs_pattern = πTemp003
							// line 2108: match = _re.match(nargs_pattern, arg_strings_pattern)
							πF.SetLineno(2108)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnargs_pattern, "nargs_pattern"); πE != nil {
								continue
							}
							πTemp001[0] = µnargs_pattern
							if πE = πg.CheckLocal(πF, µarg_strings_pattern, "arg_strings_pattern"); πE != nil {
								continue
							}
							πTemp001[1] = µarg_strings_pattern
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmatch = πTemp002
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µmatch == πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 2111: if match is None:
							πF.SetLineno(2111)
						Label1:
							// line 2112: nargs_errors = {
							πF.SetLineno(2112)
							πTemp005 = πg.NewDict()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("expected one argument").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πTemp005.SetItem(πF, πTemp002, πTemp006); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("expected at most one argument").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πTemp005.SetItem(πF, πTemp002, πTemp006); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßONE_OR_MORE); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("expected at least one argument").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πTemp005.SetItem(πF, πTemp002, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πTemp005.ToObject()
							µnargs_errors = πTemp002
							// line 2117: default = _('expected %s argument(s)') % action.nargs
							πF.SetLineno(2117)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("expected %s argument(s)").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πTemp006, πTemp003); πE != nil {
								continue
							}
							µdefault = πTemp002
							// line 2118: msg = nargs_errors.get(action.nargs, default)
							πF.SetLineno(2118)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							πTemp001[1] = µdefault
							if πE = πg.CheckLocal(πF, µnargs_errors, "nargs_errors"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µnargs_errors, ßget, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp003
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp001[1] = µmsg
							if πTemp002, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2119: raise ArgumentError(action, msg)
							πF.SetLineno(2119)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label2
						Label2:
							// line 2122: return len(match.group(1))
							πF.SetLineno(2122)
							πTemp001 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							πTemp007[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_match_argument.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 2124: def _match_arguments_partial(self, actions, arg_strings_pattern):
					πF.SetLineno(2124)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "actions", Def: nil}
					πTemp002[2] = πg.Param{Name: "arg_strings_pattern", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("_match_arguments_partial", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µactions *πg.Object = πArgs[1]; _ = µactions
						var µarg_strings_pattern *πg.Object = πArgs[2]; _ = µarg_strings_pattern
						var µresult *πg.Object = πg.UnboundLocal; _ = µresult
						var µi *πg.Object = πg.UnboundLocal; _ = µi
						var µactions_slice *πg.Object = πg.UnboundLocal; _ = µactions_slice
						var µpattern *πg.Object = πg.UnboundLocal; _ = µpattern
						var µmatch *πg.Object = πg.UnboundLocal; _ = µmatch
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []πg.Param
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							// line 2127: result = []
							πF.SetLineno(2127)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µresult = πTemp002
							πTemp001 = πF.MakeArgs(3)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							πTemp003[0] = µactions
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp001[0] = πTemp005
							πTemp001[1] = πg.NewInt(0).ToObject()
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001[2] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µi = πTemp004
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)            
							// line 2129: actions_slice = actions[:i]
							πF.SetLineno(2129)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µi, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µactions, "actions"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µactions, πTemp004); πE != nil {
								continue
							}
							µactions_slice = πTemp005
							// line 2130: pattern = ''.join([self._get_nargs_pattern(action)
							πF.SetLineno(2130)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = make([]πg.Param, 0)
							πTemp005 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µaction *πg.Object = πg.UnboundLocal; _ = µaction
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µactions_slice, "actions_slice"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µactions_slice); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µaction = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 2130: pattern = ''.join([self._get_nargs_pattern(action)
										πF.SetLineno(2130)
										πTemp005 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										πTemp005[0] = µaction
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µself, ß_get_nargs_pattern, nil); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp009, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ListType.Call(πF, πg.Args{πTemp009}, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp004, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpattern = πTemp009
							// line 2132: match = _re.match(pattern, arg_strings_pattern)
							πF.SetLineno(2132)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpattern, "pattern"); πE != nil {
								continue
							}
							πTemp001[0] = µpattern
							if πE = πg.CheckLocal(πF, µarg_strings_pattern, "arg_strings_pattern"); πE != nil {
								continue
							}
							πTemp001[1] = µarg_strings_pattern
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_re); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, πTemp004, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp009.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmatch = πTemp004
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(µmatch != πTemp009).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 2133: if match is not None:
							πF.SetLineno(2133)
						Label4:
							// line 2135: result += ([len(string) for string in match.groups()])
							πF.SetLineno(2135)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πTemp008 = make([]πg.Param, 0)
							πTemp009 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µstring *πg.Object = πg.UnboundLocal; _ = µstring
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 bool
								_ = πTemp005
								var πTemp006 []*πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroups, nil); πE != nil {
											continue
										}
										if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp004 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp004 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp005 = !isStop
										} else {
											πTemp005 = true
											µstring = πTemp002
										}
										if πE != nil || !πTemp005 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 2135: result += ([len(string) for string in match.groups()])
										πF.SetLineno(2135)
										πTemp006 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
											continue
										}
										πTemp006[0] = µstring
										if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
											continue
										}
										if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp006)
										πF.PushCheckpoint(4)
										return πTemp003, nil
									Label4:
										πTemp002 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp010, πE = πTemp009.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ListType.Call(πF, πg.Args{πTemp010}, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IAdd(πF, µresult, πTemp004); πE != nil {
								continue
							}
							µresult = πTemp010
							// line 2136: break
							πF.SetLineno(2136)
							πTemp006 = true
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2139: return result
							πF.SetLineno(2139)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_match_arguments_partial.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 2141: def _parse_optional(self, arg_string):
					πF.SetLineno(2141)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "arg_string", Def: nil}
					πTemp016 = πg.NewFunction(πg.NewCode("_parse_optional", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µarg_string *πg.Object = πArgs[1]; _ = µarg_string
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
						var µexplicit_arg *πg.Object = πg.UnboundLocal; _ = µexplicit_arg
						var µoption_tuples *πg.Object = πg.UnboundLocal; _ = µoption_tuples
						var µoptions *πg.Object = πg.UnboundLocal; _ = µoptions
						var µtup *πg.Object = πg.UnboundLocal; _ = µtup
						var µoption_tuple *πg.Object = πg.UnboundLocal; _ = µoption_tuple
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []πg.Param
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µarg_string); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 2143: if not arg_string:
							πF.SetLineno(2143)
						Label1:
							// line 2144: return None
							πF.SetLineno(2144)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							πTemp004 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µarg_string, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 2147: if not arg_string[0] in self.prefix_chars:
							πF.SetLineno(2147)
						Label3:
							// line 2148: return None
							πF.SetLineno(2148)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, πTemp003, µarg_string); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label5
							}
							goto Label6
							// line 2151: if arg_string in self._option_string_actions:
							πF.SetLineno(2151)
						Label5:
							// line 2152: action = self._option_string_actions[arg_string]
							πF.SetLineno(2152)
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp001 = µarg_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µaction = πTemp003
							// line 2153: return action, arg_string, None
							πF.SetLineno(2153)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple3(µaction, µarg_string, πTemp003).ToObject()
							πR = πTemp001
							continue
							goto Label6
						Label6:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp006[0] = µarg_string
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label7
							}
							goto Label8
							// line 2156: if len(arg_string) == 1:
							πF.SetLineno(2156)
						Label7:
							// line 2157: return None
							πF.SetLineno(2157)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label8
						Label8:
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, µarg_string, πg.NewStr("=").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label9
							}
							goto Label10
							// line 2160: if '=' in arg_string:
							πF.SetLineno(2160)
						Label9:
							// line 2161: option_string, explicit_arg = arg_string.split('=', 1)
							πF.SetLineno(2161)
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr("=").ToObject()
							πTemp006[1] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µarg_string, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µoption_string = πTemp001
							µexplicit_arg = πTemp004
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, πTemp003, µoption_string); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label11
							}
							goto Label12
							// line 2162: if option_string in self._option_string_actions:
							πF.SetLineno(2162)
						Label11:
							// line 2163: action = self._option_string_actions[option_string]
							πF.SetLineno(2163)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp001 = µoption_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µaction = πTemp003
							// line 2164: return action, option_string, explicit_arg
							πF.SetLineno(2164)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple3(µaction, µoption_string, µexplicit_arg).ToObject()
							πR = πTemp001
							continue
							goto Label12
						Label12:
							goto Label10
						Label10:
							// line 2168: option_tuples = self._get_option_tuples(arg_string)
							πF.SetLineno(2168)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp006[0] = µarg_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_option_tuples, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µoption_tuples = πTemp003
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_tuples, "option_tuples"); πE != nil {
								continue
							}
							πTemp006[0] = µoption_tuples
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.GT(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label13
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_tuples, "option_tuples"); πE != nil {
								continue
							}
							πTemp006[0] = µoption_tuples
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label14
							}
							goto Label15
							// line 2171: if len(option_tuples) > 1:
							πF.SetLineno(2171)
						Label13:
							// line 2172: options = ', '.join([option_string
							πF.SetLineno(2172)
							πTemp006 = πF.MakeArgs(1)
							πTemp007 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µaction *πg.Object = πg.UnboundLocal; _ = µaction
								var µoption_string *πg.Object = πg.UnboundLocal; _ = µoption_string
								var µexplicit_arg *πg.Object = πg.UnboundLocal; _ = µexplicit_arg
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πTemp007 *πg.Object
								_ = πTemp007
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µoption_tuples, "option_tuples"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µoption_tuples); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp004); πE != nil {
												continue
											}
											µaction = πTemp005
											µoption_string = πTemp006
											µexplicit_arg = πTemp007
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 2172: options = ', '.join([option_string
										πF.SetLineno(2172)
										if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
											continue
										}
										πF.PushCheckpoint(4)
										return µoption_string, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr(", ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µoptions = πTemp004
							// line 2174: tup = arg_string, options
							πF.SetLineno(2174)
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µarg_string, µoptions).ToObject()
							µtup = πTemp001
							// line 2175: self.error(_('ambiguous option: %s could match %s') % tup)
							πF.SetLineno(2175)
							πTemp006 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							πTemp008[0] = πg.NewStr("ambiguous option: %s could match %s").ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πE = πg.CheckLocal(πF, µtup, "tup"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πTemp005, µtup); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							goto Label15
							// line 2179: elif len(option_tuples) == 1:
							πF.SetLineno(2179)
						Label14:
							// line 2180: option_tuple, = option_tuples
							πF.SetLineno(2180)
							if πE = πg.CheckLocal(πF, µoption_tuples, "option_tuples"); πE != nil {
								continue
							}
							µoption_tuple = µoption_tuples
							// line 2181: return option_tuple
							πF.SetLineno(2181)
							if πE = πg.CheckLocal(πF, µoption_tuple, "option_tuple"); πE != nil {
								continue
							}
							πR = µoption_tuple
							continue
							goto Label15
						Label15:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp006[0] = µarg_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_negative_number_matcher, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label16
							}
							goto Label17
							// line 2186: if self._negative_number_matcher.match(arg_string):
							πF.SetLineno(2186)
						Label16:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_has_negative_number_optionals, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label18
							}
							goto Label19
							// line 2187: if not self._has_negative_number_optionals:
							πF.SetLineno(2187)
						Label18:
							// line 2188: return None
							πF.SetLineno(2188)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label19
						Label19:
							goto Label17
						Label17:
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, µarg_string, πg.NewStr(" ").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label20
							}
							goto Label21
							// line 2191: if ' ' in arg_string:
							πF.SetLineno(2191)
						Label20:
							// line 2192: return None
							πF.SetLineno(2192)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label21
						Label21:
							// line 2196: return None, arg_string, None
							πF.SetLineno(2196)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple3(πTemp004, µarg_string, πTemp005).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_parse_optional.ToObject(), πTemp016); πE != nil {
						continue
					}
					// line 2198: def _get_option_tuples(self, option_string):
					πF.SetLineno(2198)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "option_string", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("_get_option_tuples", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µoption_string *πg.Object = πArgs[1]; _ = µoption_string
						var µresult *πg.Object = πg.UnboundLocal; _ = µresult
						var µchars *πg.Object = πg.UnboundLocal; _ = µchars
						var µoption_prefix *πg.Object = πg.UnboundLocal; _ = µoption_prefix
						var µexplicit_arg *πg.Object = πg.UnboundLocal; _ = µexplicit_arg
						var µaction *πg.Object = πg.UnboundLocal; _ = µaction
						var µtup *πg.Object = πg.UnboundLocal; _ = µtup
						var µshort_option_prefix *πg.Object = πg.UnboundLocal; _ = µshort_option_prefix
						var µshort_explicit_arg *πg.Object = πg.UnboundLocal; _ = µshort_explicit_arg
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 16: goto Label16
							case 10: goto Label10
							case 11: goto Label11
							case 15: goto Label15
							default: panic("unexpected function state")
							}
							// line 2199: result = []
							πF.SetLineno(2199)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µresult = πTemp002
							// line 2203: chars = self.prefix_chars
							πF.SetLineno(2203)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßprefix_chars, nil); πE != nil {
								continue
							}
							µchars = πTemp002
							πTemp005 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µoption_string, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchars, "chars"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µchars, πTemp006); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp007).ToObject()
							πTemp002 = πTemp004
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label1
							}
							πTemp005 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µoption_string, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchars, "chars"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µchars, πTemp006); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp007).ToObject()
							πTemp002 = πTemp004
						Label1:
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label2
							}
							πTemp005 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µoption_string, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchars, "chars"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µchars, πTemp006); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp007).ToObject()
							πTemp002 = πTemp004
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label3
							}
							πTemp005 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µoption_string, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchars, "chars"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µchars, πTemp006); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp007).ToObject()
							πTemp002 = πTemp004
						Label3:
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 2204: if option_string[0] in chars and option_string[1] in chars:
							πF.SetLineno(2204)
						Label2:
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, µoption_string, πg.NewStr("=").ToObject()); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label7
							}
							goto Label8
							// line 2205: if '=' in option_string:
							πF.SetLineno(2205)
						Label7:
							// line 2206: option_prefix, explicit_arg = option_string.split('=', 1)
							πF.SetLineno(2206)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("=").ToObject()
							πTemp001[1] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoption_string, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}}}, πTemp004); πE != nil {
								continue
							}
							µoption_prefix = πTemp002
							µexplicit_arg = πTemp005
							goto Label9
						Label8:
							// line 2208: option_prefix = option_string
							πF.SetLineno(2208)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							µoption_prefix = µoption_string
							// line 2209: explicit_arg = None
							πF.SetLineno(2209)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µexplicit_arg = πTemp002
							goto Label9
						Label9:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(11)
							πTemp003 = false
						Label10:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label12
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µoption_string = πTemp004
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(10)            
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_prefix, "option_prefix"); πE != nil {
								continue
							}
							πTemp001[0] = µoption_prefix
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µoption_string, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp007, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label13
							}
							goto Label14
							// line 2211: if option_string.startswith(option_prefix):
							πF.SetLineno(2211)
						Label13:
							// line 2212: action = self._option_string_actions[option_string]
							πF.SetLineno(2212)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp004 = µoption_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp004); πE != nil {
								continue
							}
							µaction = πTemp005
							// line 2213: tup = action, option_string, explicit_arg
							πF.SetLineno(2213)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple3(µaction, µoption_string, µexplicit_arg).ToObject()
							µtup = πTemp004
							// line 2214: result.append(tup)
							πF.SetLineno(2214)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtup, "tup"); πE != nil {
								continue
							}
							πTemp001[0] = µtup
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label14
						Label14:
							continue
						Label11:
							if πE != nil || πR != nil {
								continue
							}
						Label12:
							goto Label6
							// line 2219: elif option_string[0] in chars and option_string[1] not in chars:
							πF.SetLineno(2219)
						Label4:
							// line 2220: option_prefix = option_string
							πF.SetLineno(2220)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							µoption_prefix = µoption_string
							// line 2221: explicit_arg = None
							πF.SetLineno(2221)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µexplicit_arg = πTemp002
							// line 2222: short_option_prefix = option_string[:2]
							πF.SetLineno(2222)
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.NewInt(2).ToObject(), πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µoption_string, πTemp002); πE != nil {
								continue
							}
							µshort_option_prefix = πTemp004
							// line 2223: short_explicit_arg = option_string[2:]
							πF.SetLineno(2223)
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(2).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µoption_string, πTemp002); πE != nil {
								continue
							}
							µshort_explicit_arg = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(16)
							πTemp003 = false
						Label15:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label17
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µoption_string = πTemp004
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(15)            
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µshort_option_prefix, "short_option_prefix"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Eq(πF, µoption_string, µshort_option_prefix); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label18
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption_prefix, "option_prefix"); πE != nil {
								continue
							}
							πTemp001[0] = µoption_prefix
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µoption_string, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp007, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label19
							}
							goto Label20
							// line 2226: if option_string == short_option_prefix:
							πF.SetLineno(2226)
						Label18:
							// line 2227: action = self._option_string_actions[option_string]
							πF.SetLineno(2227)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp004 = µoption_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp004); πE != nil {
								continue
							}
							µaction = πTemp005
							// line 2228: tup = action, option_string, short_explicit_arg
							πF.SetLineno(2228)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µshort_explicit_arg, "short_explicit_arg"); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple3(µaction, µoption_string, µshort_explicit_arg).ToObject()
							µtup = πTemp004
							// line 2229: result.append(tup)
							πF.SetLineno(2229)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtup, "tup"); πE != nil {
								continue
							}
							πTemp001[0] = µtup
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label20
							// line 2230: elif option_string.startswith(option_prefix):
							πF.SetLineno(2230)
						Label19:
							// line 2231: action = self._option_string_actions[option_string]
							πF.SetLineno(2231)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							πTemp004 = µoption_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ß_option_string_actions, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp004); πE != nil {
								continue
							}
							µaction = πTemp005
							// line 2232: tup = action, option_string, explicit_arg
							πF.SetLineno(2232)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µexplicit_arg, "explicit_arg"); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple3(µaction, µoption_string, µexplicit_arg).ToObject()
							µtup = πTemp004
							// line 2233: result.append(tup)
							πF.SetLineno(2233)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtup, "tup"); πE != nil {
								continue
							}
							πTemp001[0] = µtup
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label20
						Label20:
							continue
						Label16:
							if πE != nil || πR != nil {
								continue
							}
						Label17:
							goto Label6
						Label5:
							// line 2237: self.error(_('unexpected option string: %s') % option_string)
							πF.SetLineno(2237)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							πTemp008[0] = πg.NewStr("unexpected option string: %s").ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πE = πg.CheckLocal(πF, µoption_string, "option_string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πTemp005, µoption_string); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßerror, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
						Label6:
							// line 2240: return result
							πF.SetLineno(2240)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_option_tuples.ToObject(), πTemp017); πE != nil {
						continue
					}
					// line 2242: def _get_nargs_pattern(self, action):
					πF.SetLineno(2242)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp018 = πg.NewFunction(πg.NewCode("_get_nargs_pattern", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µnargs *πg.Object = πg.UnboundLocal; _ = µnargs
						var µnargs_pattern *πg.Object = πg.UnboundLocal; _ = µnargs_pattern
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 2245: nargs = action.nargs
							πF.SetLineno(2245)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							µnargs = πTemp001
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µnargs == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µnargs, πTemp002); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label2
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßZERO_OR_MORE); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µnargs, πTemp002); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßONE_OR_MORE); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µnargs, πTemp002); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßREMAINDER); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µnargs, πTemp002); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßPARSER); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µnargs, πTemp002); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label6
							}
							goto Label7
							// line 2248: if nargs is None:
							πF.SetLineno(2248)
						Label1:
							// line 2249: nargs_pattern = '(-*A-*)'
							πF.SetLineno(2249)
							µnargs_pattern = πg.NewStr("(-*A-*)").ToObject()
							goto Label8
							// line 2252: elif nargs == OPTIONAL:
							πF.SetLineno(2252)
						Label2:
							// line 2253: nargs_pattern = '(-*A?-*)'
							πF.SetLineno(2253)
							µnargs_pattern = πg.NewStr("(-*A?-*)").ToObject()
							goto Label8
							// line 2256: elif nargs == ZERO_OR_MORE:
							πF.SetLineno(2256)
						Label3:
							// line 2257: nargs_pattern = '(-*[A-]*)'
							πF.SetLineno(2257)
							µnargs_pattern = πg.NewStr("(-*[A-]*)").ToObject()
							goto Label8
							// line 2260: elif nargs == ONE_OR_MORE:
							πF.SetLineno(2260)
						Label4:
							// line 2261: nargs_pattern = '(-*A[A-]*)'
							πF.SetLineno(2261)
							µnargs_pattern = πg.NewStr("(-*A[A-]*)").ToObject()
							goto Label8
							// line 2264: elif nargs == REMAINDER:
							πF.SetLineno(2264)
						Label5:
							// line 2265: nargs_pattern = '([-AO]*)'
							πF.SetLineno(2265)
							µnargs_pattern = πg.NewStr("([-AO]*)").ToObject()
							goto Label8
							// line 2268: elif nargs == PARSER:
							πF.SetLineno(2268)
						Label6:
							// line 2269: nargs_pattern = '(-*A[-AO]*)'
							πF.SetLineno(2269)
							µnargs_pattern = πg.NewStr("(-*A[-AO]*)").ToObject()
							goto Label8
						Label7:
							// line 2273: nargs_pattern = '(-*%s-*)' % '-*'.join('A' * nargs)
							πF.SetLineno(2273)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnargs, "nargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mul(πF, ßA.ToObject(), µnargs); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("-*").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("(-*%s-*)").ToObject(), πTemp005); πE != nil {
								continue
							}
							µnargs_pattern = πTemp001
							goto Label8
						Label8:
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label9
							}
							goto Label10
							// line 2276: if action.option_strings:
							πF.SetLineno(2276)
						Label9:
							// line 2277: nargs_pattern = nargs_pattern.replace('-*', '')
							πF.SetLineno(2277)
							πTemp004 = πF.MakeArgs(2)
							πTemp004[0] = πg.NewStr("-*").ToObject()
							πTemp004[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µnargs_pattern, "nargs_pattern"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µnargs_pattern, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µnargs_pattern = πTemp002
							// line 2278: nargs_pattern = nargs_pattern.replace('-', '')
							πF.SetLineno(2278)
							πTemp004 = πF.MakeArgs(2)
							πTemp004[0] = πg.NewStr("-").ToObject()
							πTemp004[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µnargs_pattern, "nargs_pattern"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µnargs_pattern, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µnargs_pattern = πTemp002
							goto Label10
						Label10:
							// line 2281: return nargs_pattern
							πF.SetLineno(2281)
							if πE = πg.CheckLocal(πF, µnargs_pattern, "nargs_pattern"); πE != nil {
								continue
							}
							πR = µnargs_pattern
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_nargs_pattern.ToObject(), πTemp018); πE != nil {
						continue
					}
					// line 2286: def _get_values(self, action, arg_strings):
					πF.SetLineno(2286)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp002[2] = πg.Param{Name: "arg_strings", Def: nil}
					πTemp019 = πg.NewFunction(πg.NewCode("_get_values", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µarg_strings *πg.Object = πArgs[2]; _ = µarg_strings
						var µvalue *πg.Object = πg.UnboundLocal; _ = µvalue
						var µarg_string *πg.Object = πg.UnboundLocal; _ = µarg_string
						var µv *πg.Object = πg.UnboundLocal; _ = µv
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []πg.Param
						_ = πTemp006
						var πTemp007 *πg.BaseException
						_ = πTemp007
						var πTemp008 *πg.Traceback
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 *πg.Object
						_ = πTemp011
						var πTemp012 *πg.Object
						_ = πTemp012
						var πTemp013 *πg.Object
						_ = πTemp013
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 24: goto Label24
							case 25: goto Label25
							case 4: goto Label4
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 2)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßPARSER); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßREMAINDER); πE != nil {
								continue
							}
							πTemp003[1] = πTemp004
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2288: if action.nargs not in [PARSER, REMAINDER]:
							πF.SetLineno(2288)
						Label1:
							// line 2289: try:
							πF.SetLineno(2289)
							πF.PushCheckpoint(4)
							// line 2291: arg_strings = [x for x in arg_strings if x != '--']
							πF.SetLineno(2291)
							πTemp006 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µx *πg.Object = πg.UnboundLocal; _ = µx
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 6: goto Label6
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µarg_strings); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µx = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.NE(πF, µx, πg.NewStr("--").ToObject()); πE != nil {
											continue
										}
										if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
											continue
										}
										if πTemp003 {
											goto Label4
										}
										goto Label5
										// line 2291: arg_strings = [x for x in arg_strings if x != '--']
										πF.SetLineno(2291)
									Label4:
										// line 2291: arg_strings = [x for x in arg_strings if x != '--']
										πF.SetLineno(2291)
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										πF.PushCheckpoint(6)
										return µx, nil
									Label6:
										πTemp004 = πSent
										goto Label5
									Label5:
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							µarg_strings = πTemp001
							πF.PopCheckpoint()
							goto Label3
						Label4:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp007, πTemp008 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsInstance(πF, πTemp007.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							πE = πF.Raise(πTemp007.ToObject(), nil, πTemp008.ToObject())
							continue
							// line 2292: except ValueError:
							πF.SetLineno(2292)
						Label5:
							// line 2293: pass
							πF.SetLineno(2293)
							πF.RestoreExc(nil, nil)
							goto Label3
						Label3:
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, µarg_strings); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp009).ToObject()
							πTemp001 = πTemp004
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label6
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp011, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Eq(πF, πTemp010, πTemp011); πE != nil {
								continue
							}
							πTemp001 = πTemp004
						Label6:
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, µarg_strings); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp009).ToObject()
							πTemp001 = πTemp004
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp011, πE = πg.ResolveGlobal(πF, ßZERO_OR_MORE); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Eq(πF, πTemp010, πTemp011); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, πTemp010); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp009).ToObject()
							πTemp001 = πTemp004
						Label8:
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label9
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							πTemp003[0] = µarg_strings
							if πTemp010, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp011, πE = πTemp010.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.Eq(πF, πTemp011, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label10
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 2)
							if πTemp011, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp003[0] = πTemp011
							if πTemp011, πE = πg.ResolveGlobal(πF, ßOPTIONAL); πE != nil {
								continue
							}
							πTemp003[1] = πTemp011
							πTemp011 = πg.NewList(πTemp003...).ToObject()
							if πTemp009, πE = πg.Contains(πF, πTemp011, πTemp010); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp009).ToObject()
							πTemp001 = πTemp004
						Label10:
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label11
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.ResolveGlobal(πF, ßREMAINDER); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp004, πTemp010); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label12
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßnargs, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.ResolveGlobal(πF, ßPARSER); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp004, πTemp010); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label13
							}
							goto Label14
							// line 2296: if not arg_strings and action.nargs == OPTIONAL:
							πF.SetLineno(2296)
						Label7:
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßoption_strings, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label16
							}
							goto Label17
							// line 2297: if action.option_strings:
							πF.SetLineno(2297)
						Label16:
							// line 2298: value = action.const
							πF.SetLineno(2298)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßconst, nil); πE != nil {
								continue
							}
							µvalue = πTemp001
							goto Label18
						Label17:
							// line 2300: value = action.default
							πF.SetLineno(2300)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							µvalue = πTemp001
							goto Label18
						Label18:
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp003[0] = µvalue
							if πTemp001, πE = πg.ResolveGlobal(πF, ßbasestring); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label19
							}
							goto Label20
							// line 2301: if isinstance(value, basestring):
							πF.SetLineno(2301)
						Label19:
							// line 2302: value = self._get_value(action, value)
							πF.SetLineno(2302)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp003[1] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_value, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µvalue = πTemp004
							// line 2303: self._check_value(action, value)
							πF.SetLineno(2303)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp003[1] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_check_value, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label20
						Label20:
							goto Label15
							// line 2307: elif (not arg_strings and action.nargs == ZERO_OR_MORE and
							πF.SetLineno(2307)
						Label9:
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp004 != πTemp010).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label21
							}
							goto Label22
							// line 2309: if action.default is not None:
							πF.SetLineno(2309)
						Label21:
							// line 2310: value = action.default
							πF.SetLineno(2310)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µaction, ßdefault, nil); πE != nil {
								continue
							}
							µvalue = πTemp001
							goto Label23
						Label22:
							// line 2312: value = arg_strings
							πF.SetLineno(2312)
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							µvalue = µarg_strings
							goto Label23
						Label23:
							// line 2313: self._check_value(action, value)
							πF.SetLineno(2313)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp003[1] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_check_value, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label15
							// line 2316: elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:
							πF.SetLineno(2316)
						Label11:
							// line 2317: arg_string, = arg_strings
							πF.SetLineno(2317)
							if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
								continue
							}
							µarg_string = µarg_strings
							// line 2318: value = self._get_value(action, arg_string)
							πF.SetLineno(2318)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp003[1] = µarg_string
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_value, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µvalue = πTemp004
							// line 2319: self._check_value(action, value)
							πF.SetLineno(2319)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp003[1] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_check_value, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label15
							// line 2322: elif action.nargs == REMAINDER:
							πF.SetLineno(2322)
						Label12:
							// line 2323: value = [self._get_value(action, v) for v in arg_strings]
							πF.SetLineno(2323)
							πTemp006 = make([]πg.Param, 0)
							πTemp004 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µv *πg.Object = πg.UnboundLocal; _ = µv
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µarg_strings); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µv = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 2323: value = [self._get_value(action, v) for v in arg_strings]
										πF.SetLineno(2323)
										πTemp005 = πF.MakeArgs(2)
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										πTemp005[0] = µaction
										if πE = πg.CheckLocal(πF, µv, "v"); πE != nil {
											continue
										}
										πTemp005[1] = µv
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µself, ß_get_value, nil); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp010, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp010}, nil); πE != nil {
								continue
							}
							µvalue = πTemp001
							goto Label15
							// line 2326: elif action.nargs == PARSER:
							πF.SetLineno(2326)
						Label13:
							// line 2327: value = [self._get_value(action, v) for v in arg_strings]
							πF.SetLineno(2327)
							πTemp006 = make([]πg.Param, 0)
							πTemp010 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µv *πg.Object = πg.UnboundLocal; _ = µv
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µarg_strings); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µv = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 2327: value = [self._get_value(action, v) for v in arg_strings]
										πF.SetLineno(2327)
										πTemp005 = πF.MakeArgs(2)
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										πTemp005[0] = µaction
										if πE = πg.CheckLocal(πF, µv, "v"); πE != nil {
											continue
										}
										πTemp005[1] = µv
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µself, ß_get_value, nil); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp011, πE = πTemp010.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp011}, nil); πE != nil {
								continue
							}
							µvalue = πTemp001
							// line 2328: self._check_value(action, value[0])
							πF.SetLineno(2328)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetItem(πF, µvalue, πTemp001); πE != nil {
								continue
							}
							πTemp003[1] = πTemp011
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_check_value, nil); πE != nil {
								continue
							}
							if πTemp011, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label15
						Label14:
							// line 2332: value = [self._get_value(action, v) for v in arg_strings]
							πF.SetLineno(2332)
							πTemp006 = make([]πg.Param, 0)
							πTemp011 = πg.NewFunction(πg.NewCode("<generator>", "build/src/__python__/argparse.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µv *πg.Object = πg.UnboundLocal; _ = µv
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object; _ = πR
								var πE *πg.BaseException; _ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1: goto Label1
										case 2: goto Label2
										case 4: goto Label4
										default: panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µarg_strings, "arg_strings"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µarg_strings); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µv = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)            
										// line 2332: value = [self._get_value(action, v) for v in arg_strings]
										πF.SetLineno(2332)
										πTemp005 = πF.MakeArgs(2)
										if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
											continue
										}
										πTemp005[0] = µaction
										if πE = πg.CheckLocal(πF, µv, "v"); πE != nil {
											continue
										}
										πTemp005[1] = µv
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µself, ß_get_value, nil); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp012, πE = πTemp011.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp012}, nil); πE != nil {
								continue
							}
							µvalue = πTemp001
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µvalue); πE != nil {
								continue
							}
							πF.PushCheckpoint(25)
							πTemp005 = false
						Label24:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label26
							}
							if πTemp012, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp009 = !isStop
							} else {
								πTemp009 = true
								µv = πTemp012
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(24)            
							// line 2334: self._check_value(action, v)
							πF.SetLineno(2334)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp003[0] = µaction
							if πE = πg.CheckLocal(πF, µv, "v"); πE != nil {
								continue
							}
							πTemp003[1] = µv
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetAttr(πF, µself, ß_check_value, nil); πE != nil {
								continue
							}
							if πTemp013, πE = πTemp012.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							continue
						Label25:
							if πE != nil || πR != nil {
								continue
							}
						Label26:
							goto Label15
						Label15:
							// line 2337: return value
							πF.SetLineno(2337)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πR = µvalue
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_values.ToObject(), πTemp019); πE != nil {
						continue
					}
					// line 2339: def _get_value(self, action, arg_string):
					πF.SetLineno(2339)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp002[2] = πg.Param{Name: "arg_string", Def: nil}
					πTemp020 = πg.NewFunction(πg.NewCode("_get_value", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µarg_string *πg.Object = πArgs[2]; _ = µarg_string
						var µtype_func *πg.Object = πg.UnboundLocal; _ = µtype_func
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var µresult *πg.Object = πg.UnboundLocal; _ = µresult
						var µname *πg.Object = πg.UnboundLocal; _ = µname
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.BaseException
						_ = πTemp006
						var πTemp007 *πg.Traceback
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4: goto Label4
							default: panic("unexpected function state")
							}
							// line 2340: type_func = self._registry_get('type', action.type, action.type)
							πF.SetLineno(2340)
							πTemp001 = πF.MakeArgs(3)
							πTemp001[0] = ßtype.ToObject()
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßtype, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßtype, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_registry_get, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtype_func = πTemp003
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype_func, "type_func"); πE != nil {
								continue
							}
							πTemp001[0] = µtype_func
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_callable); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2341: if not _callable(type_func):
							πF.SetLineno(2341)
						Label1:
							// line 2342: msg = _('%r is not callable')
							πF.SetLineno(2342)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("%r is not callable").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp003
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype_func, "type_func"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, µmsg, µtype_func); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2343: raise ArgumentError(action, msg % type_func)
							πF.SetLineno(2343)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label2
						Label2:
							// line 2346: try:
							πF.SetLineno(2346)
							πF.PushCheckpoint(4)
							// line 2347: result = type_func(arg_string)
							πF.SetLineno(2347)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp001[0] = µarg_string
							if πE = πg.CheckLocal(πF, µtype_func, "type_func"); πE != nil {
								continue
							}
							if πTemp002, πE = µtype_func.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µresult = πTemp002
							πF.PopCheckpoint()
							goto Label3
						Label4:
							if πE == nil {
							  continue
							}
							πE = nil
							πTemp006, πTemp007 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßArgumentTypeError); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsInstance(πF, πTemp006.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTypeError); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp003, πTemp004).ToObject()
							if πTemp005, πE = πg.IsInstance(πF, πTemp006.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							πE = πF.Raise(πTemp006.ToObject(), nil, πTemp007.ToObject())
							continue
							// line 2350: except ArgumentTypeError:
							πF.SetLineno(2350)
						Label5:
							// line 2351: name = getattr(action.type, '__name__', repr(action.type))
							πF.SetLineno(2351)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßtype, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							πTemp001[1] = ß__name__.ToObject()
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßtype, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßrepr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[2] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µname = πTemp003
							// line 2352: msg = str(_sys.exc_info()[1])
							πF.SetLineno(2352)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πg.NewInt(1).ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, πTemp004, ßexc_info, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp009.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp003
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp001[1] = µmsg
							if πTemp002, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2353: raise ArgumentError(action, msg)
							πF.SetLineno(2353)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
							// line 2356: except (TypeError, ValueError):
							πF.SetLineno(2356)
						Label6:
							// line 2357: name = getattr(action.type, '__name__', repr(action.type))
							πF.SetLineno(2357)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßtype, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							πTemp001[1] = ß__name__.ToObject()
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction, ßtype, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßrepr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[2] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µname = πTemp003
							// line 2358: msg = _('invalid %s value: %r')
							πF.SetLineno(2358)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("invalid %s value: %r").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp003
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp001[0] = µaction
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_string, "arg_string"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(µname, µarg_string).ToObject()
							if πTemp002, πE = πg.Mod(πF, µmsg, πTemp003); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2359: raise ArgumentError(action, msg % (name, arg_string))
							πF.SetLineno(2359)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
						Label3:
							// line 2362: return result
							πF.SetLineno(2362)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_value.ToObject(), πTemp020); πE != nil {
						continue
					}
					// line 2364: def _check_value(self, action, value):
					πF.SetLineno(2364)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "action", Def: nil}
					πTemp002[2] = πg.Param{Name: "value", Def: nil}
					πTemp021 = πg.NewFunction(πg.NewCode("_check_value", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µaction *πg.Object = πArgs[1]; _ = µaction
						var µvalue *πg.Object = πArgs[2]; _ = µvalue
						var µtup *πg.Object = πg.UnboundLocal; _ = µtup
						var µmsg *πg.Object = πg.UnboundLocal; _ = µmsg
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßchoices, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp004 != πTemp005).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µaction, ßchoices, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp004, µvalue); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 2366: if action.choices is not None and value not in action.choices:
							πF.SetLineno(2366)
						Label2:
							// line 2367: tup = value, ', '.join(map(repr, action.choices))
							πF.SetLineno(2367)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp007 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrepr); πE != nil {
								continue
							}
							πTemp008[0] = πTemp003
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaction, ßchoices, nil); πE != nil {
								continue
							}
							πTemp008[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßmap); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp007[0] = πTemp004
							if πTemp003, πE = πg.GetAttr(πF, πg.NewStr(", ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001 = πg.NewTuple2(µvalue, πTemp004).ToObject()
							µtup = πTemp001
							// line 2368: msg = _('invalid choice: %r (choose from %s)') % tup
							πF.SetLineno(2368)
							πTemp007 = πF.MakeArgs(1)
							πTemp007[0] = πg.NewStr("invalid choice: %r (choose from %s)").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πE = πg.CheckLocal(πF, µtup, "tup"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πTemp004, µtup); πE != nil {
								continue
							}
							µmsg = πTemp001
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaction, "action"); πE != nil {
								continue
							}
							πTemp007[0] = µaction
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp007[1] = µmsg
							if πTemp001, πE = πg.ResolveGlobal(πF, ßArgumentError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 2369: raise ArgumentError(action, msg)
							πF.SetLineno(2369)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_check_value.ToObject(), πTemp021); πE != nil {
						continue
					}
					// line 2374: def format_usage(self):
					πF.SetLineno(2374)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp022 = πg.NewFunction(πg.NewCode("format_usage", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µformatter *πg.Object = πg.UnboundLocal; _ = µformatter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 2375: formatter = self._get_formatter()
							πF.SetLineno(2375)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_formatter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µformatter = πTemp002
							// line 2376: formatter.add_usage(self.usage, self._actions,
							πF.SetLineno(2376)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßusage, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_mutually_exclusive_groups, nil); πE != nil {
								continue
							}
							πTemp003[2] = πTemp001
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßadd_usage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2378: return formatter.format_help()
							πF.SetLineno(2378)
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßformat_help, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßformat_usage.ToObject(), πTemp022); πE != nil {
						continue
					}
					// line 2380: def format_help(self):
					πF.SetLineno(2380)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp023 = πg.NewFunction(πg.NewCode("format_help", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µformatter *πg.Object = πg.UnboundLocal; _ = µformatter
						var µaction_group *πg.Object = πg.UnboundLocal; _ = µaction_group
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1: goto Label1
							case 2: goto Label2
							default: panic("unexpected function state")
							}
							// line 2381: formatter = self._get_formatter()
							πF.SetLineno(2381)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_formatter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µformatter = πTemp002
							// line 2384: formatter.add_usage(self.usage, self._actions,
							πF.SetLineno(2384)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßusage, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_actions, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_mutually_exclusive_groups, nil); πE != nil {
								continue
							}
							πTemp003[2] = πTemp001
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßadd_usage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2388: formatter.add_text(self.description)
							πF.SetLineno(2388)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdescription, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßadd_text, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_action_groups, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µaction_group = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)            
							// line 2392: formatter.start_section(action_group.title)
							πF.SetLineno(2392)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction_group, "action_group"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction_group, ßtitle, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µformatter, ßstart_section, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2393: formatter.add_text(action_group.description)
							πF.SetLineno(2393)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction_group, "action_group"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction_group, ßdescription, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µformatter, ßadd_text, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2394: formatter.add_arguments(action_group._group_actions)
							πF.SetLineno(2394)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaction_group, "action_group"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µaction_group, ß_group_actions, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µformatter, ßadd_arguments, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2395: formatter.end_section()
							πF.SetLineno(2395)
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µformatter, ßend_section, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2398: formatter.add_text(self.epilog)
							πF.SetLineno(2398)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßepilog, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßadd_text, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2401: return formatter.format_help()
							πF.SetLineno(2401)
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßformat_help, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßformat_help.ToObject(), πTemp023); πE != nil {
						continue
					}
					// line 2403: def format_version(self):
					πF.SetLineno(2403)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp024 = πg.NewFunction(πg.NewCode("format_version", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µformatter *πg.Object = πg.UnboundLocal; _ = µformatter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 2409: formatter = self._get_formatter()
							πF.SetLineno(2409)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_get_formatter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µformatter = πTemp002
							// line 2410: formatter.add_text(self.version)
							πF.SetLineno(2410)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßversion, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßadd_text, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2411: return formatter.format_help()
							πF.SetLineno(2411)
							if πE = πg.CheckLocal(πF, µformatter, "formatter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µformatter, ßformat_help, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßformat_version.ToObject(), πTemp024); πE != nil {
						continue
					}
					// line 2413: def _get_formatter(self):
					πF.SetLineno(2413)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp025 = πg.NewFunction(πg.NewCode("_get_formatter", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 πg.KWArgs
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 2414: return self.formatter_class(prog=self.prog)
							πF.SetLineno(2414)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßprog, nil); πE != nil {
								continue
							}
							πTemp002 = πg.KWArgs{
								{"prog", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßformatter_class, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, πTemp002); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_get_formatter.ToObject(), πTemp025); πE != nil {
						continue
					}
					// line 2419: def print_usage(self, file=None):
					πF.SetLineno(2419)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp027, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "file", Def: πTemp027}
					πTemp026 = πg.NewFunction(πg.NewCode("print_usage", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µfile *πg.Object = πArgs[1]; _ = µfile
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µfile, "file"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µfile == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 2420: if file is None:
							πF.SetLineno(2420)
						Label1:
							// line 2421: file = _sys.stdout
							πF.SetLineno(2421)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßstdout, nil); πE != nil {
								continue
							}
							µfile = πTemp002
							goto Label2
						Label2:
							// line 2422: self._print_message(self.format_usage(), file)
							πF.SetLineno(2422)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßformat_usage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µfile, "file"); πE != nil {
								continue
							}
							πTemp004[1] = µfile
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_print_message, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprint_usage.ToObject(), πTemp026); πE != nil {
						continue
					}
					// line 2424: def print_help(self, file=None):
					πF.SetLineno(2424)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp028, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "file", Def: πTemp028}
					πTemp027 = πg.NewFunction(πg.NewCode("print_help", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µfile *πg.Object = πArgs[1]; _ = µfile
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µfile, "file"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µfile == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 2425: if file is None:
							πF.SetLineno(2425)
						Label1:
							// line 2426: file = _sys.stdout
							πF.SetLineno(2426)
							if πTemp001, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßstdout, nil); πE != nil {
								continue
							}
							µfile = πTemp002
							goto Label2
						Label2:
							// line 2427: self._print_message(self.format_help(), file)
							πF.SetLineno(2427)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßformat_help, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µfile, "file"); πE != nil {
								continue
							}
							πTemp004[1] = µfile
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß_print_message, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprint_help.ToObject(), πTemp027); πE != nil {
						continue
					}
					// line 2429: def print_version(self, file=None):
					πF.SetLineno(2429)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp029, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "file", Def: πTemp029}
					πTemp028 = πg.NewFunction(πg.NewCode("print_version", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µfile *πg.Object = πArgs[1]; _ = µfile
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 2435: self._print_message(self.format_version(), file)
							πF.SetLineno(2435)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßformat_version, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µfile, "file"); πE != nil {
								continue
							}
							πTemp001[1] = µfile
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß_print_message, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprint_version.ToObject(), πTemp028); πE != nil {
						continue
					}
					// line 2437: def _print_message(self, message, file=None):
					πF.SetLineno(2437)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "message", Def: nil}
					if πTemp030, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "file", Def: πTemp030}
					πTemp029 = πg.NewFunction(πg.NewCode("_print_message", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µmessage *πg.Object = πArgs[1]; _ = µmessage
						var µfile *πg.Object = πArgs[2]; _ = µfile
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IsTrue(πF, µmessage); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label1
							}
							goto Label2
							// line 2438: if message:
							πF.SetLineno(2438)
						Label1:
							if πE = πg.CheckLocal(πF, µfile, "file"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µfile == πTemp003).ToObject()
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label3
							}
							goto Label4
							// line 2439: if file is None:
							πF.SetLineno(2439)
						Label3:
							// line 2440: file = _sys.stderr
							πF.SetLineno(2440)
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstderr, nil); πE != nil {
								continue
							}
							µfile = πTemp003
							goto Label4
						Label4:
							// line 2441: file.write(message)
							πF.SetLineno(2441)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp004[0] = µmessage
							if πE = πg.CheckLocal(πF, µfile, "file"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µfile, ßwrite, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß_print_message.ToObject(), πTemp029); πE != nil {
						continue
					}
					// line 2446: def exit(self, status=0, message=None):
					πF.SetLineno(2446)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "status", Def: πg.NewInt(0).ToObject()}
					if πTemp031, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "message", Def: πTemp031}
					πTemp030 = πg.NewFunction(πg.NewCode("exit", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µstatus *πg.Object = πArgs[1]; _ = µstatus
						var µmessage *πg.Object = πArgs[2]; _ = µmessage
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IsTrue(πF, µmessage); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label1
							}
							goto Label2
							// line 2447: if message:
							πF.SetLineno(2447)
						Label1:
							// line 2448: self._print_message(message, _sys.stderr)
							πF.SetLineno(2448)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp002[0] = µmessage
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstderr, nil); πE != nil {
								continue
							}
							πTemp002[1] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß_print_message, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label2
						Label2:
							// line 2449: _sys.exit(status)
							πF.SetLineno(2449)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstatus, "status"); πE != nil {
								continue
							}
							πTemp002[0] = µstatus
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßexit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßexit.ToObject(), πTemp030); πE != nil {
						continue
					}
					// line 2451: def error(self, message):
					πF.SetLineno(2451)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "message", Def: nil}
					πTemp031 = πg.NewFunction(πg.NewCode("error", "build/src/__python__/argparse.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]; _ = µself
						var µmessage *πg.Object = πArgs[1]; _ = µmessage
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object; _ = πR
						var πE *πg.BaseException; _ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default: panic("unexpected function state")
							}
							// line 2452: """error(message: string)
							πF.SetLineno(2452)
							// line 2460: self.print_usage(_sys.stderr)
							πF.SetLineno(2460)
							πTemp001 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ß_sys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstderr, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßprint_usage, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2461: self.exit(2, _('%s: error: %s\n') % (self.prog, message))
							πF.SetLineno(2461)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewInt(2).ToObject()
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("%s: error: %s\n").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ß_); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßprog, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(πTemp006, µmessage).ToObject()
							if πTemp002, πE = πg.Mod(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßexit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßerror.ToObject(), πTemp031); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp011, πE = πTemp008.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp011 == nil {
				πTemp011 = πg.TypeType.ToObject()
			}
			if πTemp012, πE = πTemp011.Call(πF, []*πg.Object{πg.NewStr("ArgumentParser").ToObject(), πg.NewTuple(πTemp001...).ToObject(), πTemp008.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßArgumentParser.ToObject(), πTemp012); πE != nil {
				continue
			}
		}
		return nil, πE
	})
	πg.RegisterModule("argparse", Code)
}
